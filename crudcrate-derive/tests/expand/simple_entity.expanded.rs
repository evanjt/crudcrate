//! Simple entity expansion test
//! Verifies that EntityToModels generates correct Create/Update/List models
use crudcrate::EntityToModels;
use sea_orm::entity::prelude::*;
use uuid::Uuid;
#[sea_orm(table_name = "items")]
#[crudcrate(api_struct = "Item")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key)]
    pub id: Uuid,
    #[crudcrate(sortable, filterable)]
    pub name: String,
    pub active: bool,
}
#[automatically_derived]
impl ::core::clone::Clone for Model {
    #[inline]
    fn clone(&self) -> Model {
        Model {
            id: ::core::clone::Clone::clone(&self.id),
            name: ::core::clone::Clone::clone(&self.name),
            active: ::core::clone::Clone::clone(&self.active),
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for Model {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "Model",
            "id",
            &self.id,
            "name",
            &self.name,
            "active",
            &&self.active,
        )
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for Model {}
#[automatically_derived]
impl ::core::cmp::PartialEq for Model {
    #[inline]
    fn eq(&self, other: &Model) -> bool {
        self.active == other.active && self.id == other.id && self.name == other.name
    }
}
/// Generated by sea-orm-macros
pub enum Column {
    /// Generated by sea-orm-macros
    Id,
    /// Generated by sea-orm-macros
    Name,
    /// Generated by sea-orm-macros
    Active,
}
#[automatically_derived]
impl ::core::marker::Copy for Column {}
#[automatically_derived]
impl ::core::clone::Clone for Column {
    #[inline]
    fn clone(&self) -> Column {
        *self
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for Column {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(
            f,
            match self {
                Column::Id => "Id",
                Column::Name => "Name",
                Column::Active => "Active",
            },
        )
    }
}
///An iterator over the variants of [Column]
#[allow(missing_copy_implementations)]
pub struct ColumnIter {
    idx: usize,
    back_idx: usize,
    marker: ::core::marker::PhantomData<()>,
}
impl ::core::fmt::Debug for ColumnIter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
    }
}
impl ColumnIter {
    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
        match idx {
            0usize => ::core::option::Option::Some(Column::Id),
            1usize => ::core::option::Option::Some(Column::Name),
            2usize => ::core::option::Option::Some(Column::Active),
            _ => ::core::option::Option::None,
        }
    }
}
impl sea_orm::strum::IntoEnumIterator for Column {
    type Iterator = ColumnIter;
    fn iter() -> ColumnIter {
        ColumnIter {
            idx: 0,
            back_idx: 0,
            marker: ::core::marker::PhantomData,
        }
    }
}
impl Iterator for ColumnIter {
    type Item = Column;
    fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
        self.nth(0)
    }
    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
        let t = if self.idx + self.back_idx >= 3usize {
            0
        } else {
            3usize - self.idx - self.back_idx
        };
        (t, Some(t))
    }
    fn nth(&mut self, n: usize) -> ::core::option::Option<<Self as Iterator>::Item> {
        let idx = self.idx + n + 1;
        if idx + self.back_idx > 3usize {
            self.idx = 3usize;
            ::core::option::Option::None
        } else {
            self.idx = idx;
            ColumnIter::get(self, idx - 1)
        }
    }
}
impl ExactSizeIterator for ColumnIter {
    fn len(&self) -> usize {
        self.size_hint().0
    }
}
impl DoubleEndedIterator for ColumnIter {
    fn next_back(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
        let back_idx = self.back_idx + 1;
        if self.idx + back_idx > 3usize {
            self.back_idx = 3usize;
            ::core::option::Option::None
        } else {
            self.back_idx = back_idx;
            ColumnIter::get(self, 3usize - self.back_idx)
        }
    }
}
impl ::core::iter::FusedIterator for ColumnIter {}
impl Clone for ColumnIter {
    fn clone(&self) -> ColumnIter {
        ColumnIter {
            idx: self.idx,
            back_idx: self.back_idx,
            marker: self.marker.clone(),
        }
    }
}
#[automatically_derived]
impl Column {
    fn default_as_str(&self) -> &str {
        match self {
            Self::Id => "id",
            Self::Name => "name",
            Self::Active => "active",
        }
    }
}
#[automatically_derived]
impl std::str::FromStr for Column {
    type Err = sea_orm::ColumnFromStrErr;
    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "id" | "id" | "id" => Ok(Column::Id),
            "name" | "name" | "name" => Ok(Column::Name),
            "active" | "active" | "active" => Ok(Column::Active),
            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
        }
    }
}
#[automatically_derived]
impl sea_orm::Iden for Column {
    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
        s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self))).unwrap();
    }
}
#[automatically_derived]
impl sea_orm::IdenStatic for Column {
    fn as_str(&self) -> &str {
        self.default_as_str()
    }
}
#[automatically_derived]
impl sea_orm::prelude::ColumnTrait for Column {
    type EntityName = Entity;
    fn def(&self) -> sea_orm::prelude::ColumnDef {
        match self {
            Self::Id => {
                sea_orm::prelude::ColumnTypeTrait::def(
                    sea_orm::prelude::ColumnType::Uuid,
                )
            }
            Self::Name => {
                sea_orm::prelude::ColumnTypeTrait::def(
                    sea_orm::prelude::ColumnType::string(None),
                )
            }
            Self::Active => {
                sea_orm::prelude::ColumnTypeTrait::def(
                    sea_orm::prelude::ColumnType::Boolean,
                )
            }
        }
    }
    fn enum_type_name(&self) -> Option<&'static str> {
        match self {
            Self::Id => <Uuid as sea_orm::sea_query::ValueType>::enum_type_name(),
            Self::Name => <String as sea_orm::sea_query::ValueType>::enum_type_name(),
            Self::Active => <bool as sea_orm::sea_query::ValueType>::enum_type_name(),
        }
    }
    fn select_as(
        &self,
        expr: sea_orm::sea_query::Expr,
    ) -> sea_orm::sea_query::SimpleExpr {
        match self {
            _ => sea_orm::prelude::ColumnTrait::select_enum_as(self, expr),
        }
    }
    fn save_as(&self, val: sea_orm::sea_query::Expr) -> sea_orm::sea_query::SimpleExpr {
        match self {
            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
        }
    }
}
/// Generated by sea-orm-macros
pub struct Entity;
#[automatically_derived]
impl ::core::marker::Copy for Entity {}
#[automatically_derived]
impl ::core::clone::Clone for Entity {
    #[inline]
    fn clone(&self) -> Entity {
        *self
    }
}
#[automatically_derived]
impl ::core::default::Default for Entity {
    #[inline]
    fn default() -> Entity {
        Entity {}
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for Entity {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(f, "Entity")
    }
}
#[automatically_derived]
impl sea_orm::entity::EntityTrait for Entity {
    type Model = Model;
    type ActiveModel = ActiveModel;
    type Column = Column;
    type PrimaryKey = PrimaryKey;
    type Relation = Relation;
}
#[automatically_derived]
impl sea_orm::Iden for Entity {
    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
        s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self))).unwrap();
    }
}
#[automatically_derived]
impl sea_orm::IdenStatic for Entity {
    fn as_str(&self) -> &str {
        <Self as sea_orm::EntityName>::table_name(self)
    }
}
#[automatically_derived]
impl sea_orm::prelude::EntityName for Entity {
    fn schema_name(&self) -> Option<&str> {
        None
    }
    fn table_name(&self) -> &str {
        "items"
    }
    fn comment(&self) -> Option<&str> {
        None
    }
}
/// Generated by sea-orm-macros
pub enum PrimaryKey {
    /// Generated by sea-orm-macros
    Id,
}
#[automatically_derived]
impl ::core::marker::Copy for PrimaryKey {}
#[automatically_derived]
impl ::core::clone::Clone for PrimaryKey {
    #[inline]
    fn clone(&self) -> PrimaryKey {
        *self
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for PrimaryKey {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(f, "Id")
    }
}
///An iterator over the variants of [PrimaryKey]
#[allow(missing_copy_implementations)]
pub struct PrimaryKeyIter {
    idx: usize,
    back_idx: usize,
    marker: ::core::marker::PhantomData<()>,
}
impl ::core::fmt::Debug for PrimaryKeyIter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PrimaryKeyIter").field("len", &self.len()).finish()
    }
}
impl PrimaryKeyIter {
    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
        match idx {
            0usize => ::core::option::Option::Some(PrimaryKey::Id),
            _ => ::core::option::Option::None,
        }
    }
}
impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
    type Iterator = PrimaryKeyIter;
    fn iter() -> PrimaryKeyIter {
        PrimaryKeyIter {
            idx: 0,
            back_idx: 0,
            marker: ::core::marker::PhantomData,
        }
    }
}
impl Iterator for PrimaryKeyIter {
    type Item = PrimaryKey;
    fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
        self.nth(0)
    }
    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
        let t = if self.idx + self.back_idx >= 1usize {
            0
        } else {
            1usize - self.idx - self.back_idx
        };
        (t, Some(t))
    }
    fn nth(&mut self, n: usize) -> ::core::option::Option<<Self as Iterator>::Item> {
        let idx = self.idx + n + 1;
        if idx + self.back_idx > 1usize {
            self.idx = 1usize;
            ::core::option::Option::None
        } else {
            self.idx = idx;
            PrimaryKeyIter::get(self, idx - 1)
        }
    }
}
impl ExactSizeIterator for PrimaryKeyIter {
    fn len(&self) -> usize {
        self.size_hint().0
    }
}
impl DoubleEndedIterator for PrimaryKeyIter {
    fn next_back(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
        let back_idx = self.back_idx + 1;
        if self.idx + back_idx > 1usize {
            self.back_idx = 1usize;
            ::core::option::Option::None
        } else {
            self.back_idx = back_idx;
            PrimaryKeyIter::get(self, 1usize - self.back_idx)
        }
    }
}
impl ::core::iter::FusedIterator for PrimaryKeyIter {}
impl Clone for PrimaryKeyIter {
    fn clone(&self) -> PrimaryKeyIter {
        PrimaryKeyIter {
            idx: self.idx,
            back_idx: self.back_idx,
            marker: self.marker.clone(),
        }
    }
}
#[automatically_derived]
impl sea_orm::Iden for PrimaryKey {
    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
        s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self))).unwrap();
    }
}
#[automatically_derived]
impl sea_orm::IdenStatic for PrimaryKey {
    fn as_str(&self) -> &str {
        match self {
            Self::Id => "id",
        }
    }
}
#[automatically_derived]
impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
    type Column = Column;
    fn into_column(self) -> Self::Column {
        match self {
            Self::Id => Self::Column::Id,
        }
    }
    fn from_column(col: Self::Column) -> Option<Self> {
        match col {
            Self::Column::Id => Some(Self::Id),
            _ => None,
        }
    }
}
#[automatically_derived]
impl PrimaryKeyTrait for PrimaryKey {
    type ValueType = Uuid;
    fn auto_increment() -> bool {
        false
    }
}
#[automatically_derived]
impl sea_orm::FromQueryResult for Model {
    fn from_query_result(
        row: &sea_orm::QueryResult,
        pre: &str,
    ) -> std::result::Result<Self, sea_orm::DbErr> {
        Ok(Self {
            id: row
                .try_get(
                    pre,
                    sea_orm::IdenStatic::as_str(
                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Id,
                        )
                        .into(),
                )?,
            name: row
                .try_get(
                    pre,
                    sea_orm::IdenStatic::as_str(
                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Name,
                        )
                        .into(),
                )?,
            active: row
                .try_get(
                    pre,
                    sea_orm::IdenStatic::as_str(
                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Active,
                        )
                        .into(),
                )?,
        })
    }
}
#[automatically_derived]
impl sea_orm::ModelTrait for Model {
    type Entity = Entity;
    fn get(
        &self,
        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
    ) -> sea_orm::Value {
        match c {
            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Id => {
                self.id.clone().into()
            }
            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Name => {
                self.name.clone().into()
            }
            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Active => {
                self.active.clone().into()
            }
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!("field does not exist on Model"),
                );
            }
        }
    }
    fn set(
        &mut self,
        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
        v: sea_orm::Value,
    ) {
        match c {
            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Id => {
                self.id = v.unwrap();
            }
            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Name => {
                self.name = v.unwrap();
            }
            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Active => {
                self.active = v.unwrap();
            }
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!("field does not exist on Model"),
                );
            }
        }
    }
}
/// Generated by sea-orm-macros
pub struct ActiveModel {
    /// Generated by sea-orm-macros
    pub id: sea_orm::ActiveValue<Uuid>,
    /// Generated by sea-orm-macros
    pub name: sea_orm::ActiveValue<String>,
    /// Generated by sea-orm-macros
    pub active: sea_orm::ActiveValue<bool>,
}
#[automatically_derived]
impl ::core::clone::Clone for ActiveModel {
    #[inline]
    fn clone(&self) -> ActiveModel {
        ActiveModel {
            id: ::core::clone::Clone::clone(&self.id),
            name: ::core::clone::Clone::clone(&self.name),
            active: ::core::clone::Clone::clone(&self.active),
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for ActiveModel {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "ActiveModel",
            "id",
            &self.id,
            "name",
            &self.name,
            "active",
            &&self.active,
        )
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for ActiveModel {}
#[automatically_derived]
impl ::core::cmp::PartialEq for ActiveModel {
    #[inline]
    fn eq(&self, other: &ActiveModel) -> bool {
        self.id == other.id && self.name == other.name && self.active == other.active
    }
}
#[automatically_derived]
impl std::default::Default for ActiveModel {
    fn default() -> Self {
        <Self as sea_orm::ActiveModelBehavior>::new()
    }
}
#[automatically_derived]
impl std::convert::From<Model> for ActiveModel {
    fn from(m: Model) -> Self {
        Self {
            id: sea_orm::ActiveValue::Unchanged(m.id),
            name: sea_orm::ActiveValue::Unchanged(m.name),
            active: sea_orm::ActiveValue::Unchanged(m.active),
        }
    }
}
#[automatically_derived]
impl sea_orm::IntoActiveModel<ActiveModel> for Model {
    fn into_active_model(self) -> ActiveModel {
        self.into()
    }
}
#[automatically_derived]
impl sea_orm::ActiveModelTrait for ActiveModel {
    type Entity = Entity;
    fn take(
        &mut self,
        c: <Self::Entity as sea_orm::EntityTrait>::Column,
    ) -> sea_orm::ActiveValue<sea_orm::Value> {
        match c {
            <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                let mut value = sea_orm::ActiveValue::NotSet;
                std::mem::swap(&mut value, &mut self.id);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                let mut value = sea_orm::ActiveValue::NotSet;
                std::mem::swap(&mut value, &mut self.name);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Active => {
                let mut value = sea_orm::ActiveValue::NotSet;
                std::mem::swap(&mut value, &mut self.active);
                value.into_wrapped_value()
            }
            _ => sea_orm::ActiveValue::NotSet,
        }
    }
    fn get(
        &self,
        c: <Self::Entity as sea_orm::EntityTrait>::Column,
    ) -> sea_orm::ActiveValue<sea_orm::Value> {
        match c {
            <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                self.id.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                self.name.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Active => {
                self.active.clone().into_wrapped_value()
            }
            _ => sea_orm::ActiveValue::NotSet,
        }
    }
    fn try_set(
        &mut self,
        c: <Self::Entity as sea_orm::EntityTrait>::Column,
        v: sea_orm::Value,
    ) -> Result<(), sea_orm::DbErr> {
        match c {
            <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                self.id = sea_orm::ActiveValue::set(
                    sea_orm::sea_query::ValueType::try_from(v)
                        .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                );
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                self.name = sea_orm::ActiveValue::set(
                    sea_orm::sea_query::ValueType::try_from(v)
                        .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                );
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Active => {
                self.active = sea_orm::ActiveValue::set(
                    sea_orm::sea_query::ValueType::try_from(v)
                        .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                );
            }
            _ => {
                return Err(
                    sea_orm::DbErr::Type(
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "This ActiveModel does not have this field: {0}",
                                    sea_orm::IdenStatic::as_str(& c),
                                ),
                            )
                        }),
                    ),
                );
            }
        }
        Ok(())
    }
    fn not_set(&mut self, c: <Self::Entity as sea_orm::EntityTrait>::Column) {
        match c {
            <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                self.id = sea_orm::ActiveValue::NotSet;
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                self.name = sea_orm::ActiveValue::NotSet;
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Active => {
                self.active = sea_orm::ActiveValue::NotSet;
            }
            _ => {}
        }
    }
    fn is_not_set(&self, c: <Self::Entity as sea_orm::EntityTrait>::Column) -> bool {
        match c {
            <Self::Entity as sea_orm::EntityTrait>::Column::Id => self.id.is_not_set(),
            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                self.name.is_not_set()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Active => {
                self.active.is_not_set()
            }
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!("This ActiveModel does not have this field"),
                );
            }
        }
    }
    fn default() -> Self {
        Self {
            id: sea_orm::ActiveValue::NotSet,
            name: sea_orm::ActiveValue::NotSet,
            active: sea_orm::ActiveValue::NotSet,
        }
    }
    fn default_values() -> Self {
        use sea_orm::value::{
            DefaultActiveValue, DefaultActiveValueNone, DefaultActiveValueNotSet,
        };
        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
        default.id = (&default.id).default_value();
        default.name = (&default.name).default_value();
        default.active = (&default.active).default_value();
        default
    }
    fn reset(&mut self, c: <Self::Entity as sea_orm::EntityTrait>::Column) {
        match c {
            <Self::Entity as sea_orm::EntityTrait>::Column::Id => self.id.reset(),
            <Self::Entity as sea_orm::EntityTrait>::Column::Name => self.name.reset(),
            <Self::Entity as sea_orm::EntityTrait>::Column::Active => self.active.reset(),
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!("This ActiveModel does not have this field"),
                );
            }
        }
    }
}
#[automatically_derived]
impl std::convert::TryFrom<ActiveModel> for Model {
    type Error = sea_orm::DbErr;
    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
        if #[allow(non_exhaustive_omitted_patterns)]
        match a.id {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("id".to_owned()));
        }
        if #[allow(non_exhaustive_omitted_patterns)]
        match a.name {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("name".to_owned()));
        }
        if #[allow(non_exhaustive_omitted_patterns)]
        match a.active {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("active".to_owned()));
        }
        Ok(Self {
            id: a.id.into_value().unwrap().unwrap(),
            name: a.name.into_value().unwrap().unwrap(),
            active: a.active.into_value().unwrap().unwrap(),
        })
    }
}
#[automatically_derived]
impl sea_orm::TryIntoModel<Model> for ActiveModel {
    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
        self.try_into()
    }
}
use sea_orm::ActiveValue;
use utoipa::ToSchema;
use serde::{Serialize, Deserialize};
use crudcrate::{ToUpdateModel, ToCreateModel};
#[active_model = "ActiveModel"]
pub struct Item {
    #[crudcrate(primary_key)]
    pub id: Uuid,
    #[crudcrate(sortable, filterable)]
    pub name: String,
    pub active: bool,
}
#[automatically_derived]
impl ::core::clone::Clone for Item {
    #[inline]
    fn clone(&self) -> Item {
        Item {
            id: ::core::clone::Clone::clone(&self.id),
            name: ::core::clone::Clone::clone(&self.name),
            active: ::core::clone::Clone::clone(&self.active),
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for Item {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "Item",
            "id",
            &self.id,
            "name",
            &self.name,
            "active",
            &&self.active,
        )
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Item {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private228::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "Item",
                false as usize + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "id",
                &self.id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "name",
                &self.name,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "active",
                &self.active,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for Item {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private228::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private228::Formatter,
                ) -> _serde::__private228::fmt::Result {
                    _serde::__private228::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private228::Ok(__Field::__field0),
                        1u64 => _serde::__private228::Ok(__Field::__field1),
                        2u64 => _serde::__private228::Ok(__Field::__field2),
                        _ => _serde::__private228::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "id" => _serde::__private228::Ok(__Field::__field0),
                        "name" => _serde::__private228::Ok(__Field::__field1),
                        "active" => _serde::__private228::Ok(__Field::__field2),
                        _ => _serde::__private228::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"id" => _serde::__private228::Ok(__Field::__field0),
                        b"name" => _serde::__private228::Ok(__Field::__field1),
                        b"active" => _serde::__private228::Ok(__Field::__field2),
                        _ => _serde::__private228::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private228::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private228::PhantomData<Item>,
                lifetime: _serde::__private228::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = Item;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private228::Formatter,
                ) -> _serde::__private228::fmt::Result {
                    _serde::__private228::Formatter::write_str(
                        __formatter,
                        "struct Item",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private228::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        Uuid,
                    >(&mut __seq)? {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            return _serde::__private228::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Item with 3 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            return _serde::__private228::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Item with 3 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        bool,
                    >(&mut __seq)? {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            return _serde::__private228::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct Item with 3 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private228::Ok(Item {
                        id: __field0,
                        name: __field1,
                        active: __field2,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private228::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private228::Option<Uuid> = _serde::__private228::None;
                    let mut __field1: _serde::__private228::Option<String> = _serde::__private228::None;
                    let mut __field2: _serde::__private228::Option<bool> = _serde::__private228::None;
                    while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private228::Option::is_some(&__field0) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                    );
                                }
                                __field0 = _serde::__private228::Some(
                                    _serde::de::MapAccess::next_value::<Uuid>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private228::Option::is_some(&__field1) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                    );
                                }
                                __field1 = _serde::__private228::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private228::Option::is_some(&__field2) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("active"),
                                    );
                                }
                                __field2 = _serde::__private228::Some(
                                    _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private228::Some(__field0) => __field0,
                        _serde::__private228::None => {
                            _serde::__private228::de::missing_field("id")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private228::Some(__field1) => __field1,
                        _serde::__private228::None => {
                            _serde::__private228::de::missing_field("name")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private228::Some(__field2) => __field2,
                        _serde::__private228::None => {
                            _serde::__private228::de::missing_field("active")?
                        }
                    };
                    _serde::__private228::Ok(Item {
                        id: __field0,
                        name: __field1,
                        active: __field2,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["id", "name", "active"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "Item",
                FIELDS,
                __Visitor {
                    marker: _serde::__private228::PhantomData::<Item>,
                    lifetime: _serde::__private228::PhantomData,
                },
            )
        }
    }
};
pub struct ItemCreate {
    pub id: Uuid,
    pub name: String,
    pub active: bool,
}
#[automatically_derived]
impl ::core::clone::Clone for ItemCreate {
    #[inline]
    fn clone(&self) -> ItemCreate {
        ItemCreate {
            id: ::core::clone::Clone::clone(&self.id),
            name: ::core::clone::Clone::clone(&self.name),
            active: ::core::clone::Clone::clone(&self.active),
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for ItemCreate {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "ItemCreate",
            "id",
            &self.id,
            "name",
            &self.name,
            "active",
            &&self.active,
        )
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for ItemCreate {}
#[automatically_derived]
impl ::core::cmp::PartialEq for ItemCreate {
    #[inline]
    fn eq(&self, other: &ItemCreate) -> bool {
        self.active == other.active && self.id == other.id && self.name == other.name
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for ItemCreate {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private228::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "ItemCreate",
                false as usize + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "id",
                &self.id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "name",
                &self.name,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "active",
                &self.active,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for ItemCreate {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private228::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private228::Formatter,
                ) -> _serde::__private228::fmt::Result {
                    _serde::__private228::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private228::Ok(__Field::__field0),
                        1u64 => _serde::__private228::Ok(__Field::__field1),
                        2u64 => _serde::__private228::Ok(__Field::__field2),
                        _ => _serde::__private228::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "id" => _serde::__private228::Ok(__Field::__field0),
                        "name" => _serde::__private228::Ok(__Field::__field1),
                        "active" => _serde::__private228::Ok(__Field::__field2),
                        _ => _serde::__private228::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"id" => _serde::__private228::Ok(__Field::__field0),
                        b"name" => _serde::__private228::Ok(__Field::__field1),
                        b"active" => _serde::__private228::Ok(__Field::__field2),
                        _ => _serde::__private228::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private228::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private228::PhantomData<ItemCreate>,
                lifetime: _serde::__private228::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = ItemCreate;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private228::Formatter,
                ) -> _serde::__private228::fmt::Result {
                    _serde::__private228::Formatter::write_str(
                        __formatter,
                        "struct ItemCreate",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private228::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        Uuid,
                    >(&mut __seq)? {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            return _serde::__private228::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct ItemCreate with 3 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            return _serde::__private228::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct ItemCreate with 3 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        bool,
                    >(&mut __seq)? {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            return _serde::__private228::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct ItemCreate with 3 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private228::Ok(ItemCreate {
                        id: __field0,
                        name: __field1,
                        active: __field2,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private228::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private228::Option<Uuid> = _serde::__private228::None;
                    let mut __field1: _serde::__private228::Option<String> = _serde::__private228::None;
                    let mut __field2: _serde::__private228::Option<bool> = _serde::__private228::None;
                    while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private228::Option::is_some(&__field0) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                    );
                                }
                                __field0 = _serde::__private228::Some(
                                    _serde::de::MapAccess::next_value::<Uuid>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private228::Option::is_some(&__field1) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                    );
                                }
                                __field1 = _serde::__private228::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private228::Option::is_some(&__field2) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("active"),
                                    );
                                }
                                __field2 = _serde::__private228::Some(
                                    _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private228::Some(__field0) => __field0,
                        _serde::__private228::None => {
                            _serde::__private228::de::missing_field("id")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private228::Some(__field1) => __field1,
                        _serde::__private228::None => {
                            _serde::__private228::de::missing_field("name")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private228::Some(__field2) => __field2,
                        _serde::__private228::None => {
                            _serde::__private228::de::missing_field("active")?
                        }
                    };
                    _serde::__private228::Ok(ItemCreate {
                        id: __field0,
                        name: __field1,
                        active: __field2,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["id", "name", "active"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "ItemCreate",
                FIELDS,
                __Visitor {
                    marker: _serde::__private228::PhantomData::<ItemCreate>,
                    lifetime: _serde::__private228::PhantomData,
                },
            )
        }
    }
};
impl utoipa::__dev::ComposeSchema for ItemCreate {
    fn compose(
        mut generics: Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>,
    ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
        {
            let mut object = utoipa::openapi::ObjectBuilder::new();
            object = object
                .property(
                    "id",
                    utoipa::openapi::ObjectBuilder::new()
                        .schema_type(
                            utoipa::openapi::schema::SchemaType::new(
                                utoipa::openapi::schema::Type::String,
                            ),
                        )
                        .format(
                            Some(
                                utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                    utoipa::openapi::schema::KnownFormat::Uuid,
                                ),
                            ),
                        ),
                )
                .required("id");
            object = object
                .property(
                    "name",
                    utoipa::openapi::ObjectBuilder::new()
                        .schema_type(
                            utoipa::openapi::schema::SchemaType::new(
                                utoipa::openapi::schema::Type::String,
                            ),
                        ),
                )
                .required("name");
            object = object
                .property(
                    "active",
                    utoipa::openapi::ObjectBuilder::new()
                        .schema_type(
                            utoipa::openapi::schema::SchemaType::new(
                                utoipa::openapi::schema::Type::Boolean,
                            ),
                        ),
                )
                .required("active");
            object
        }
            .into()
    }
}
impl utoipa::ToSchema for ItemCreate {
    fn name() -> std::borrow::Cow<'static, str> {
        std::borrow::Cow::Borrowed("ItemCreate")
    }
    fn schemas(
        schemas: &mut Vec<
            (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
        >,
    ) {
        schemas.extend([]);
    }
}
impl From<ItemCreate> for ActiveModel {
    fn from(create: ItemCreate) -> Self {
        ActiveModel {
            id: sea_orm::ActiveValue::Set(create.id.into()),
            name: sea_orm::ActiveValue::Set(create.name.into()),
            active: sea_orm::ActiveValue::Set(create.active.into()),
        }
    }
}
pub struct ItemUpdate {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        with = "crudcrate::serde_with::rust::double_option"
    )]
    pub id: Option<Option<Uuid>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        with = "crudcrate::serde_with::rust::double_option"
    )]
    pub name: Option<Option<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        with = "crudcrate::serde_with::rust::double_option"
    )]
    pub active: Option<Option<bool>>,
}
#[automatically_derived]
impl ::core::clone::Clone for ItemUpdate {
    #[inline]
    fn clone(&self) -> ItemUpdate {
        ItemUpdate {
            id: ::core::clone::Clone::clone(&self.id),
            name: ::core::clone::Clone::clone(&self.name),
            active: ::core::clone::Clone::clone(&self.active),
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for ItemUpdate {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "ItemUpdate",
            "id",
            &self.id,
            "name",
            &self.name,
            "active",
            &&self.active,
        )
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for ItemUpdate {}
#[automatically_derived]
impl ::core::cmp::PartialEq for ItemUpdate {
    #[inline]
    fn eq(&self, other: &ItemUpdate) -> bool {
        self.id == other.id && self.name == other.name && self.active == other.active
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for ItemUpdate {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private228::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "ItemUpdate",
                false as usize + if Option::is_none(&self.id) { 0 } else { 1 }
                    + if Option::is_none(&self.name) { 0 } else { 1 }
                    + if Option::is_none(&self.active) { 0 } else { 1 },
            )?;
            if !Option::is_none(&self.id) {
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &{
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Option<Option<Uuid>>,),
                            phantom: _serde::__private228::PhantomData<ItemUpdate>,
                        }
                        #[automatically_derived]
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                crudcrate::serde_with::rust::double_option::serialize(
                                    self.values.0,
                                    __s,
                                )
                            }
                        }
                        __SerializeWith {
                            values: (&self.id,),
                            phantom: _serde::__private228::PhantomData::<ItemUpdate>,
                        }
                    },
                )?;
            } else {
                _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "id")?;
            }
            if !Option::is_none(&self.name) {
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &{
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Option<Option<String>>,),
                            phantom: _serde::__private228::PhantomData<ItemUpdate>,
                        }
                        #[automatically_derived]
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                crudcrate::serde_with::rust::double_option::serialize(
                                    self.values.0,
                                    __s,
                                )
                            }
                        }
                        __SerializeWith {
                            values: (&self.name,),
                            phantom: _serde::__private228::PhantomData::<ItemUpdate>,
                        }
                    },
                )?;
            } else {
                _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "name")?;
            }
            if !Option::is_none(&self.active) {
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "active",
                    &{
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Option<Option<bool>>,),
                            phantom: _serde::__private228::PhantomData<ItemUpdate>,
                        }
                        #[automatically_derived]
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                crudcrate::serde_with::rust::double_option::serialize(
                                    self.values.0,
                                    __s,
                                )
                            }
                        }
                        __SerializeWith {
                            values: (&self.active,),
                            phantom: _serde::__private228::PhantomData::<ItemUpdate>,
                        }
                    },
                )?;
            } else {
                _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "active")?;
            }
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for ItemUpdate {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private228::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private228::Formatter,
                ) -> _serde::__private228::fmt::Result {
                    _serde::__private228::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private228::Ok(__Field::__field0),
                        1u64 => _serde::__private228::Ok(__Field::__field1),
                        2u64 => _serde::__private228::Ok(__Field::__field2),
                        _ => _serde::__private228::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "id" => _serde::__private228::Ok(__Field::__field0),
                        "name" => _serde::__private228::Ok(__Field::__field1),
                        "active" => _serde::__private228::Ok(__Field::__field2),
                        _ => _serde::__private228::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"id" => _serde::__private228::Ok(__Field::__field0),
                        b"name" => _serde::__private228::Ok(__Field::__field1),
                        b"active" => _serde::__private228::Ok(__Field::__field2),
                        _ => _serde::__private228::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private228::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private228::PhantomData<ItemUpdate>,
                lifetime: _serde::__private228::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = ItemUpdate;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private228::Formatter,
                ) -> _serde::__private228::fmt::Result {
                    _serde::__private228::Formatter::write_str(
                        __formatter,
                        "struct ItemUpdate",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private228::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match {
                        #[doc(hidden)]
                        struct __DeserializeWith<'de> {
                            value: Option<Option<Uuid>>,
                            phantom: _serde::__private228::PhantomData<ItemUpdate>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::__private228::Ok(__DeserializeWith {
                                    value: crudcrate::serde_with::rust::double_option::deserialize(
                                        __deserializer,
                                    )?,
                                    phantom: _serde::__private228::PhantomData,
                                    lifetime: _serde::__private228::PhantomData,
                                })
                            }
                        }
                        _serde::__private228::Option::map(
                            _serde::de::SeqAccess::next_element::<
                                __DeserializeWith<'de>,
                            >(&mut __seq)?,
                            |__wrap| __wrap.value,
                        )
                    } {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field1 = match {
                        #[doc(hidden)]
                        struct __DeserializeWith<'de> {
                            value: Option<Option<String>>,
                            phantom: _serde::__private228::PhantomData<ItemUpdate>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::__private228::Ok(__DeserializeWith {
                                    value: crudcrate::serde_with::rust::double_option::deserialize(
                                        __deserializer,
                                    )?,
                                    phantom: _serde::__private228::PhantomData,
                                    lifetime: _serde::__private228::PhantomData,
                                })
                            }
                        }
                        _serde::__private228::Option::map(
                            _serde::de::SeqAccess::next_element::<
                                __DeserializeWith<'de>,
                            >(&mut __seq)?,
                            |__wrap| __wrap.value,
                        )
                    } {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field2 = match {
                        #[doc(hidden)]
                        struct __DeserializeWith<'de> {
                            value: Option<Option<bool>>,
                            phantom: _serde::__private228::PhantomData<ItemUpdate>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::__private228::Ok(__DeserializeWith {
                                    value: crudcrate::serde_with::rust::double_option::deserialize(
                                        __deserializer,
                                    )?,
                                    phantom: _serde::__private228::PhantomData,
                                    lifetime: _serde::__private228::PhantomData,
                                })
                            }
                        }
                        _serde::__private228::Option::map(
                            _serde::de::SeqAccess::next_element::<
                                __DeserializeWith<'de>,
                            >(&mut __seq)?,
                            |__wrap| __wrap.value,
                        )
                    } {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    _serde::__private228::Ok(ItemUpdate {
                        id: __field0,
                        name: __field1,
                        active: __field2,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private228::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private228::Option<
                        Option<Option<Uuid>>,
                    > = _serde::__private228::None;
                    let mut __field1: _serde::__private228::Option<
                        Option<Option<String>>,
                    > = _serde::__private228::None;
                    let mut __field2: _serde::__private228::Option<
                        Option<Option<bool>>,
                    > = _serde::__private228::None;
                    while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private228::Option::is_some(&__field0) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                    );
                                }
                                __field0 = _serde::__private228::Some({
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Option<Option<Uuid>>,
                                        phantom: _serde::__private228::PhantomData<ItemUpdate>,
                                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private228::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private228::Ok(__DeserializeWith {
                                                value: crudcrate::serde_with::rust::double_option::deserialize(
                                                    __deserializer,
                                                )?,
                                                phantom: _serde::__private228::PhantomData,
                                                lifetime: _serde::__private228::PhantomData,
                                            })
                                        }
                                    }
                                    match _serde::de::MapAccess::next_value::<
                                        __DeserializeWith<'de>,
                                    >(&mut __map) {
                                        _serde::__private228::Ok(__wrapper) => __wrapper.value,
                                        _serde::__private228::Err(__err) => {
                                            return _serde::__private228::Err(__err);
                                        }
                                    }
                                });
                            }
                            __Field::__field1 => {
                                if _serde::__private228::Option::is_some(&__field1) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                    );
                                }
                                __field1 = _serde::__private228::Some({
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Option<Option<String>>,
                                        phantom: _serde::__private228::PhantomData<ItemUpdate>,
                                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private228::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private228::Ok(__DeserializeWith {
                                                value: crudcrate::serde_with::rust::double_option::deserialize(
                                                    __deserializer,
                                                )?,
                                                phantom: _serde::__private228::PhantomData,
                                                lifetime: _serde::__private228::PhantomData,
                                            })
                                        }
                                    }
                                    match _serde::de::MapAccess::next_value::<
                                        __DeserializeWith<'de>,
                                    >(&mut __map) {
                                        _serde::__private228::Ok(__wrapper) => __wrapper.value,
                                        _serde::__private228::Err(__err) => {
                                            return _serde::__private228::Err(__err);
                                        }
                                    }
                                });
                            }
                            __Field::__field2 => {
                                if _serde::__private228::Option::is_some(&__field2) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("active"),
                                    );
                                }
                                __field2 = _serde::__private228::Some({
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Option<Option<bool>>,
                                        phantom: _serde::__private228::PhantomData<ItemUpdate>,
                                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private228::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private228::Ok(__DeserializeWith {
                                                value: crudcrate::serde_with::rust::double_option::deserialize(
                                                    __deserializer,
                                                )?,
                                                phantom: _serde::__private228::PhantomData,
                                                lifetime: _serde::__private228::PhantomData,
                                            })
                                        }
                                    }
                                    match _serde::de::MapAccess::next_value::<
                                        __DeserializeWith<'de>,
                                    >(&mut __map) {
                                        _serde::__private228::Ok(__wrapper) => __wrapper.value,
                                        _serde::__private228::Err(__err) => {
                                            return _serde::__private228::Err(__err);
                                        }
                                    }
                                });
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private228::Some(__field0) => __field0,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private228::Some(__field1) => __field1,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private228::Some(__field2) => __field2,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    _serde::__private228::Ok(ItemUpdate {
                        id: __field0,
                        name: __field1,
                        active: __field2,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["id", "name", "active"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "ItemUpdate",
                FIELDS,
                __Visitor {
                    marker: _serde::__private228::PhantomData::<ItemUpdate>,
                    lifetime: _serde::__private228::PhantomData,
                },
            )
        }
    }
};
impl utoipa::__dev::ComposeSchema for ItemUpdate {
    fn compose(
        mut generics: Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>,
    ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
        {
            let mut object = utoipa::openapi::ObjectBuilder::new();
            object = object
                .property(
                    "id",
                    utoipa::openapi::ObjectBuilder::new()
                        .schema_type({
                            use std::iter::FromIterator;
                            utoipa::openapi::schema::SchemaType::from_iter([
                                utoipa::openapi::schema::Type::String,
                                utoipa::openapi::schema::Type::Null,
                            ])
                        })
                        .format(
                            Some(
                                utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                    utoipa::openapi::schema::KnownFormat::Uuid,
                                ),
                            ),
                        ),
                );
            object = object
                .property(
                    "name",
                    utoipa::openapi::ObjectBuilder::new()
                        .schema_type({
                            use std::iter::FromIterator;
                            utoipa::openapi::schema::SchemaType::from_iter([
                                utoipa::openapi::schema::Type::String,
                                utoipa::openapi::schema::Type::Null,
                            ])
                        }),
                );
            object = object
                .property(
                    "active",
                    utoipa::openapi::ObjectBuilder::new()
                        .schema_type({
                            use std::iter::FromIterator;
                            utoipa::openapi::schema::SchemaType::from_iter([
                                utoipa::openapi::schema::Type::Boolean,
                                utoipa::openapi::schema::Type::Null,
                            ])
                        }),
                );
            object
        }
            .into()
    }
}
impl utoipa::ToSchema for ItemUpdate {
    fn name() -> std::borrow::Cow<'static, str> {
        std::borrow::Cow::Borrowed("ItemUpdate")
    }
    fn schemas(
        schemas: &mut Vec<
            (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
        >,
    ) {
        schemas.extend([]);
    }
}
impl ItemUpdate {
    pub fn merge_fields(
        self,
        mut model: ActiveModel,
    ) -> Result<ActiveModel, crudcrate::ApiError> {
        model.id = match self.id {
            Some(Some(value)) => sea_orm::ActiveValue::Set(value.into()),
            Some(None) => {
                return Err(
                    crudcrate::ApiError::bad_request(
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Field \'{0}\' is required and cannot be set to null", "id",
                                ),
                            )
                        }),
                    ),
                );
            }
            None => sea_orm::ActiveValue::NotSet,
        };
        model.name = match self.name {
            Some(Some(value)) => sea_orm::ActiveValue::Set(value.into()),
            Some(None) => {
                return Err(
                    crudcrate::ApiError::bad_request(
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Field \'{0}\' is required and cannot be set to null",
                                    "name",
                                ),
                            )
                        }),
                    ),
                );
            }
            None => sea_orm::ActiveValue::NotSet,
        };
        model.active = match self.active {
            Some(Some(value)) => sea_orm::ActiveValue::Set(value.into()),
            Some(None) => {
                return Err(
                    crudcrate::ApiError::bad_request(
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Field \'{0}\' is required and cannot be set to null",
                                    "active",
                                ),
                            )
                        }),
                    ),
                );
            }
            None => sea_orm::ActiveValue::NotSet,
        };
        Ok(model)
    }
}
impl crudcrate::traits::MergeIntoActiveModel<ActiveModel> for ItemUpdate {
    fn merge_into_activemodel(
        self,
        model: ActiveModel,
    ) -> Result<ActiveModel, crudcrate::ApiError> {
        Self::merge_fields(self, model)
    }
}
impl utoipa::__dev::ComposeSchema for Item {
    fn compose(
        mut generics: Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>,
    ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
        {
            let mut object = utoipa::openapi::ObjectBuilder::new();
            object = object
                .property(
                    "id",
                    utoipa::openapi::ObjectBuilder::new()
                        .schema_type(
                            utoipa::openapi::schema::SchemaType::new(
                                utoipa::openapi::schema::Type::String,
                            ),
                        )
                        .format(
                            Some(
                                utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                    utoipa::openapi::schema::KnownFormat::Uuid,
                                ),
                            ),
                        ),
                )
                .required("id");
            object = object
                .property(
                    "name",
                    utoipa::openapi::ObjectBuilder::new()
                        .schema_type(
                            utoipa::openapi::schema::SchemaType::new(
                                utoipa::openapi::schema::Type::String,
                            ),
                        ),
                )
                .required("name");
            object = object
                .property(
                    "active",
                    utoipa::openapi::ObjectBuilder::new()
                        .schema_type(
                            utoipa::openapi::schema::SchemaType::new(
                                utoipa::openapi::schema::Type::Boolean,
                            ),
                        ),
                )
                .required("active");
            object
        }
            .into()
    }
}
impl utoipa::ToSchema for Item {
    fn name() -> std::borrow::Cow<'static, str> {
        std::borrow::Cow::Borrowed("Item")
    }
    fn schemas(
        schemas: &mut Vec<
            (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
        >,
    ) {
        schemas.extend([]);
    }
}
impl From<Model> for Item {
    fn from(model: Model) -> Self {
        Self {
            id: model.id,
            name: model.name,
            active: model.active,
        }
    }
}
impl crudcrate::CRUDResource for Item {
    type EntityType = Entity;
    type ColumnType = Column;
    type ActiveModelType = ActiveModel;
    type CreateModel = ItemCreate;
    type UpdateModel = ItemUpdate;
    type ListModel = ItemList;
    const ID_COLUMN: Self::ColumnType = Self::ColumnType::Id;
    const RESOURCE_NAME_SINGULAR: &'static str = "items";
    const RESOURCE_NAME_PLURAL: &'static str = "items";
    const TABLE_NAME: &'static str = "items";
    const RESOURCE_DESCRIPTION: &'static str = "This resource manages items items";
    const FULLTEXT_LANGUAGE: &'static str = "english";
    fn sortable_columns() -> Vec<(&'static str, Self::ColumnType)> {
        <[_]>::into_vec(::alloc::boxed::box_new([("name", Self::ColumnType::Name)]))
    }
    fn filterable_columns() -> Vec<(&'static str, Self::ColumnType)> {
        <[_]>::into_vec(::alloc::boxed::box_new([("name", Self::ColumnType::Name)]))
    }
    fn is_enum_field(field_name: &str) -> bool {
        match field_name {
            "id" => false,
            "name" => false,
            "active" => false,
            _ => false,
        }
    }
    fn like_filterable_columns() -> Vec<&'static str> {
        <[_]>::into_vec(::alloc::boxed::box_new(["name"]))
    }
    fn fulltext_searchable_columns() -> Vec<(&'static str, Self::ColumnType)> {
        ::alloc::vec::Vec::new()
    }
    #[allow(
        elided_named_lifetimes,
        clippy::async_yields_async,
        clippy::diverging_sub_expression,
        clippy::let_unit_value,
        clippy::needless_arbitrary_self_type,
        clippy::no_effect_underscore_binding,
        clippy::shadow_same,
        clippy::type_complexity,
        clippy::type_repetition_in_bounds,
        clippy::used_underscore_binding
    )]
    fn get_one<'life0, 'async_trait>(
        db: &'life0 sea_orm::DatabaseConnection,
        id: uuid::Uuid,
    ) -> ::core::pin::Pin<
        Box<
            dyn ::core::future::Future<
                Output = Result<Self, crudcrate::ApiError>,
            > + ::core::marker::Send + 'async_trait,
        >,
    >
    where
        'life0: 'async_trait,
        Self: 'async_trait,
    {
        Box::pin(async move {
            if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                Result<Self, crudcrate::ApiError>,
            > {
                #[allow(unreachable_code)] return __ret;
            }
            let id = id;
            let __ret: Result<Self, crudcrate::ApiError> = {
                let model = Self::EntityType::find_by_id(id).one(db).await?;
                let result = match model {
                    Some(model) => Self::from(model),
                    None => {
                        return Err(
                            crudcrate::ApiError::not_found(
                                Self::RESOURCE_NAME_SINGULAR,
                                Some(id.to_string()),
                            ),
                        );
                    }
                };
                Ok(result)
            };
            #[allow(unreachable_code)] __ret
        })
    }
    #[allow(
        elided_named_lifetimes,
        clippy::async_yields_async,
        clippy::diverging_sub_expression,
        clippy::let_unit_value,
        clippy::needless_arbitrary_self_type,
        clippy::no_effect_underscore_binding,
        clippy::shadow_same,
        clippy::type_complexity,
        clippy::type_repetition_in_bounds,
        clippy::used_underscore_binding
    )]
    fn get_all<'life0, 'life1, 'async_trait>(
        db: &'life0 sea_orm::DatabaseConnection,
        condition: &'life1 sea_orm::Condition,
        order_column: Self::ColumnType,
        order_direction: sea_orm::Order,
        offset: u64,
        limit: u64,
    ) -> ::core::pin::Pin<
        Box<
            dyn ::core::future::Future<
                Output = Result<Vec<Self::ListModel>, crudcrate::ApiError>,
            > + ::core::marker::Send + 'async_trait,
        >,
    >
    where
        'life0: 'async_trait,
        'life1: 'async_trait,
        Self: 'async_trait,
    {
        Box::pin(async move {
            if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                Result<Vec<Self::ListModel>, crudcrate::ApiError>,
            > {
                #[allow(unreachable_code)] return __ret;
            }
            let order_column = order_column;
            let order_direction = order_direction;
            let offset = offset;
            let limit = limit;
            let __ret: Result<Vec<Self::ListModel>, crudcrate::ApiError> = {
                use sea_orm::{QueryOrder, QuerySelect, EntityTrait};
                let models = Self::EntityType::find()
                    .filter(condition.clone())
                    .order_by(order_column, order_direction)
                    .offset(offset)
                    .limit(limit)
                    .all(db)
                    .await?;
                let result: Vec<Self::ListModel> = models
                    .into_iter()
                    .map(|model| Self::ListModel::from(Self::from(model)))
                    .collect();
                Ok(result)
            };
            #[allow(unreachable_code)] __ret
        })
    }
    #[allow(
        elided_named_lifetimes,
        clippy::async_yields_async,
        clippy::diverging_sub_expression,
        clippy::let_unit_value,
        clippy::needless_arbitrary_self_type,
        clippy::no_effect_underscore_binding,
        clippy::shadow_same,
        clippy::type_complexity,
        clippy::type_repetition_in_bounds,
        clippy::used_underscore_binding
    )]
    fn create<'life0, 'async_trait>(
        db: &'life0 sea_orm::DatabaseConnection,
        data: Self::CreateModel,
    ) -> ::core::pin::Pin<
        Box<
            dyn ::core::future::Future<
                Output = Result<Self, crudcrate::ApiError>,
            > + ::core::marker::Send + 'async_trait,
        >,
    >
    where
        'life0: 'async_trait,
        Self: 'async_trait,
    {
        Box::pin(async move {
            if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                Result<Self, crudcrate::ApiError>,
            > {
                #[allow(unreachable_code)] return __ret;
            }
            let data = data;
            let __ret: Result<Self, crudcrate::ApiError> = {
                let active_model: Self::ActiveModelType = data.into();
                let insert_result = Self::EntityType::insert(active_model)
                    .exec(db)
                    .await?;
                let result = Self::get_one(db, insert_result.last_insert_id.into())
                    .await?;
                Ok(result)
            };
            #[allow(unreachable_code)] __ret
        })
    }
    #[allow(
        elided_named_lifetimes,
        clippy::async_yields_async,
        clippy::diverging_sub_expression,
        clippy::let_unit_value,
        clippy::needless_arbitrary_self_type,
        clippy::no_effect_underscore_binding,
        clippy::shadow_same,
        clippy::type_complexity,
        clippy::type_repetition_in_bounds,
        clippy::used_underscore_binding
    )]
    fn create_many<'life0, 'async_trait>(
        db: &'life0 sea_orm::DatabaseConnection,
        data: Vec<Self::CreateModel>,
    ) -> ::core::pin::Pin<
        Box<
            dyn ::core::future::Future<
                Output = Result<Vec<Self>, crudcrate::ApiError>,
            > + ::core::marker::Send + 'async_trait,
        >,
    >
    where
        'life0: 'async_trait,
        Self: 'async_trait,
    {
        Box::pin(async move {
            if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                Result<Vec<Self>, crudcrate::ApiError>,
            > {
                #[allow(unreachable_code)] return __ret;
            }
            let data = data;
            let __ret: Result<Vec<Self>, crudcrate::ApiError> = {
                use sea_orm::ActiveModelTrait;
                const MAX_BATCH_CREATE_SIZE: usize = 100;
                if data.len() > MAX_BATCH_CREATE_SIZE {
                    return Err(
                        crudcrate::ApiError::bad_request(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "Batch create limited to {0} items. Received {1} items.",
                                        MAX_BATCH_CREATE_SIZE, data.len(),
                                    ),
                                )
                            }),
                        ),
                    );
                }
                let mut result = Vec::with_capacity(data.len());
                for create_model in data {
                    let active_model: Self::ActiveModelType = create_model.into();
                    let model = active_model.insert(db).await?;
                    result.push(Self::from(model));
                }
                Ok(result)
            };
            #[allow(unreachable_code)] __ret
        })
    }
    #[allow(
        elided_named_lifetimes,
        clippy::async_yields_async,
        clippy::diverging_sub_expression,
        clippy::let_unit_value,
        clippy::needless_arbitrary_self_type,
        clippy::no_effect_underscore_binding,
        clippy::shadow_same,
        clippy::type_complexity,
        clippy::type_repetition_in_bounds,
        clippy::used_underscore_binding
    )]
    fn update<'life0, 'async_trait>(
        db: &'life0 sea_orm::DatabaseConnection,
        id: uuid::Uuid,
        data: Self::UpdateModel,
    ) -> ::core::pin::Pin<
        Box<
            dyn ::core::future::Future<
                Output = Result<Self, crudcrate::ApiError>,
            > + ::core::marker::Send + 'async_trait,
        >,
    >
    where
        'life0: 'async_trait,
        Self: 'async_trait,
    {
        Box::pin(async move {
            if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                Result<Self, crudcrate::ApiError>,
            > {
                #[allow(unreachable_code)] return __ret;
            }
            let id = id;
            let data = data;
            let __ret: Result<Self, crudcrate::ApiError> = {
                use sea_orm::{EntityTrait, IntoActiveModel, ActiveModelTrait};
                use crudcrate::traits::MergeIntoActiveModel;
                let model = Self::EntityType::find_by_id(id)
                    .one(db)
                    .await?
                    .ok_or_else(|| crudcrate::ApiError::not_found(
                        Self::RESOURCE_NAME_SINGULAR,
                        Some(id.to_string()),
                    ))?;
                let existing: Self::ActiveModelType = model.into_active_model();
                let updated_model = data.merge_into_activemodel(existing)?;
                let updated = updated_model.update(db).await?;
                let result = Self::from(updated);
                Ok(result)
            };
            #[allow(unreachable_code)] __ret
        })
    }
    #[allow(
        elided_named_lifetimes,
        clippy::async_yields_async,
        clippy::diverging_sub_expression,
        clippy::let_unit_value,
        clippy::needless_arbitrary_self_type,
        clippy::no_effect_underscore_binding,
        clippy::shadow_same,
        clippy::type_complexity,
        clippy::type_repetition_in_bounds,
        clippy::used_underscore_binding
    )]
    fn update_many<'life0, 'async_trait>(
        db: &'life0 sea_orm::DatabaseConnection,
        updates: Vec<(uuid::Uuid, Self::UpdateModel)>,
    ) -> ::core::pin::Pin<
        Box<
            dyn ::core::future::Future<
                Output = Result<Vec<Self>, crudcrate::ApiError>,
            > + ::core::marker::Send + 'async_trait,
        >,
    >
    where
        'life0: 'async_trait,
        Self: 'async_trait,
    {
        Box::pin(async move {
            if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                Result<Vec<Self>, crudcrate::ApiError>,
            > {
                #[allow(unreachable_code)] return __ret;
            }
            let updates = updates;
            let __ret: Result<Vec<Self>, crudcrate::ApiError> = {
                use sea_orm::{EntityTrait, IntoActiveModel, ActiveModelTrait};
                use crudcrate::traits::MergeIntoActiveModel;
                const MAX_BATCH_UPDATE_SIZE: usize = 100;
                if updates.len() > MAX_BATCH_UPDATE_SIZE {
                    return Err(
                        crudcrate::ApiError::bad_request(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "Batch update limited to {0} items. Received {1} items.",
                                        MAX_BATCH_UPDATE_SIZE, updates.len(),
                                    ),
                                )
                            }),
                        ),
                    );
                }
                let mut result = Vec::with_capacity(updates.len());
                for (id, update_model) in updates {
                    let model = Self::EntityType::find_by_id(id)
                        .one(db)
                        .await?
                        .ok_or_else(|| crudcrate::ApiError::not_found(
                            Self::RESOURCE_NAME_SINGULAR,
                            Some(id.to_string()),
                        ))?;
                    let existing: Self::ActiveModelType = model.into_active_model();
                    let updated_model = update_model.merge_into_activemodel(existing)?;
                    let updated = updated_model.update(db).await?;
                    result.push(Self::from(updated));
                }
                Ok(result)
            };
            #[allow(unreachable_code)] __ret
        })
    }
    #[allow(
        elided_named_lifetimes,
        clippy::async_yields_async,
        clippy::diverging_sub_expression,
        clippy::let_unit_value,
        clippy::needless_arbitrary_self_type,
        clippy::no_effect_underscore_binding,
        clippy::shadow_same,
        clippy::type_complexity,
        clippy::type_repetition_in_bounds,
        clippy::used_underscore_binding
    )]
    fn delete<'life0, 'async_trait>(
        db: &'life0 sea_orm::DatabaseConnection,
        id: uuid::Uuid,
    ) -> ::core::pin::Pin<
        Box<
            dyn ::core::future::Future<
                Output = Result<uuid::Uuid, crudcrate::ApiError>,
            > + ::core::marker::Send + 'async_trait,
        >,
    >
    where
        'life0: 'async_trait,
    {
        Box::pin(async move {
            if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                Result<uuid::Uuid, crudcrate::ApiError>,
            > {
                #[allow(unreachable_code)] return __ret;
            }
            let id = id;
            let __ret: Result<uuid::Uuid, crudcrate::ApiError> = {
                use sea_orm::EntityTrait;
                let res = Self::EntityType::delete_by_id(id).exec(db).await?;
                let result = match res.rows_affected {
                    0 => {
                        return Err(
                            crudcrate::ApiError::not_found(
                                Self::RESOURCE_NAME_SINGULAR,
                                Some(id.to_string()),
                            ),
                        );
                    }
                    _ => id,
                };
                Ok(result)
            };
            #[allow(unreachable_code)] __ret
        })
    }
    #[allow(
        elided_named_lifetimes,
        clippy::async_yields_async,
        clippy::diverging_sub_expression,
        clippy::let_unit_value,
        clippy::needless_arbitrary_self_type,
        clippy::no_effect_underscore_binding,
        clippy::shadow_same,
        clippy::type_complexity,
        clippy::type_repetition_in_bounds,
        clippy::used_underscore_binding
    )]
    fn delete_many<'life0, 'async_trait>(
        db: &'life0 sea_orm::DatabaseConnection,
        ids: Vec<uuid::Uuid>,
    ) -> ::core::pin::Pin<
        Box<
            dyn ::core::future::Future<
                Output = Result<Vec<uuid::Uuid>, crudcrate::ApiError>,
            > + ::core::marker::Send + 'async_trait,
        >,
    >
    where
        'life0: 'async_trait,
    {
        Box::pin(async move {
            if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                Result<Vec<uuid::Uuid>, crudcrate::ApiError>,
            > {
                #[allow(unreachable_code)] return __ret;
            }
            let ids = ids;
            let __ret: Result<Vec<uuid::Uuid>, crudcrate::ApiError> = {
                use sea_orm::{EntityTrait, QueryFilter, ColumnTrait};
                const MAX_BATCH_DELETE_SIZE: usize = 100;
                if ids.len() > MAX_BATCH_DELETE_SIZE {
                    return Err(
                        crudcrate::ApiError::bad_request(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "Batch delete limited to {0} items. Received {1} items.",
                                        MAX_BATCH_DELETE_SIZE, ids.len(),
                                    ),
                                )
                            }),
                        ),
                    );
                }
                Self::EntityType::delete_many()
                    .filter(Self::ID_COLUMN.is_in(ids.clone()))
                    .exec(db)
                    .await?;
                let result = ids;
                Ok(result)
            };
            #[allow(unreachable_code)] __ret
        })
    }
}
pub struct ItemList {
    pub id: Uuid,
    pub name: String,
    pub active: bool,
}
#[automatically_derived]
impl ::core::clone::Clone for ItemList {
    #[inline]
    fn clone(&self) -> ItemList {
        ItemList {
            id: ::core::clone::Clone::clone(&self.id),
            name: ::core::clone::Clone::clone(&self.name),
            active: ::core::clone::Clone::clone(&self.active),
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for ItemList {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "ItemList",
            "id",
            &self.id,
            "name",
            &self.name,
            "active",
            &&self.active,
        )
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for ItemList {}
#[automatically_derived]
impl ::core::cmp::PartialEq for ItemList {
    #[inline]
    fn eq(&self, other: &ItemList) -> bool {
        self.active == other.active && self.id == other.id && self.name == other.name
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for ItemList {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private228::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "ItemList",
                false as usize + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "id",
                &self.id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "name",
                &self.name,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "active",
                &self.active,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for ItemList {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private228::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private228::Formatter,
                ) -> _serde::__private228::fmt::Result {
                    _serde::__private228::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private228::Ok(__Field::__field0),
                        1u64 => _serde::__private228::Ok(__Field::__field1),
                        2u64 => _serde::__private228::Ok(__Field::__field2),
                        _ => _serde::__private228::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "id" => _serde::__private228::Ok(__Field::__field0),
                        "name" => _serde::__private228::Ok(__Field::__field1),
                        "active" => _serde::__private228::Ok(__Field::__field2),
                        _ => _serde::__private228::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"id" => _serde::__private228::Ok(__Field::__field0),
                        b"name" => _serde::__private228::Ok(__Field::__field1),
                        b"active" => _serde::__private228::Ok(__Field::__field2),
                        _ => _serde::__private228::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private228::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private228::PhantomData<ItemList>,
                lifetime: _serde::__private228::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = ItemList;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private228::Formatter,
                ) -> _serde::__private228::fmt::Result {
                    _serde::__private228::Formatter::write_str(
                        __formatter,
                        "struct ItemList",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private228::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        Uuid,
                    >(&mut __seq)? {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            return _serde::__private228::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct ItemList with 3 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            return _serde::__private228::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct ItemList with 3 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        bool,
                    >(&mut __seq)? {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            return _serde::__private228::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct ItemList with 3 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private228::Ok(ItemList {
                        id: __field0,
                        name: __field1,
                        active: __field2,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private228::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private228::Option<Uuid> = _serde::__private228::None;
                    let mut __field1: _serde::__private228::Option<String> = _serde::__private228::None;
                    let mut __field2: _serde::__private228::Option<bool> = _serde::__private228::None;
                    while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private228::Option::is_some(&__field0) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                    );
                                }
                                __field0 = _serde::__private228::Some(
                                    _serde::de::MapAccess::next_value::<Uuid>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private228::Option::is_some(&__field1) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                    );
                                }
                                __field1 = _serde::__private228::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private228::Option::is_some(&__field2) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("active"),
                                    );
                                }
                                __field2 = _serde::__private228::Some(
                                    _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private228::Some(__field0) => __field0,
                        _serde::__private228::None => {
                            _serde::__private228::de::missing_field("id")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private228::Some(__field1) => __field1,
                        _serde::__private228::None => {
                            _serde::__private228::de::missing_field("name")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private228::Some(__field2) => __field2,
                        _serde::__private228::None => {
                            _serde::__private228::de::missing_field("active")?
                        }
                    };
                    _serde::__private228::Ok(ItemList {
                        id: __field0,
                        name: __field1,
                        active: __field2,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["id", "name", "active"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "ItemList",
                FIELDS,
                __Visitor {
                    marker: _serde::__private228::PhantomData::<ItemList>,
                    lifetime: _serde::__private228::PhantomData,
                },
            )
        }
    }
};
impl utoipa::__dev::ComposeSchema for ItemList {
    fn compose(
        mut generics: Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>,
    ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
        {
            let mut object = utoipa::openapi::ObjectBuilder::new();
            object = object
                .property(
                    "id",
                    utoipa::openapi::ObjectBuilder::new()
                        .schema_type(
                            utoipa::openapi::schema::SchemaType::new(
                                utoipa::openapi::schema::Type::String,
                            ),
                        )
                        .format(
                            Some(
                                utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                    utoipa::openapi::schema::KnownFormat::Uuid,
                                ),
                            ),
                        ),
                )
                .required("id");
            object = object
                .property(
                    "name",
                    utoipa::openapi::ObjectBuilder::new()
                        .schema_type(
                            utoipa::openapi::schema::SchemaType::new(
                                utoipa::openapi::schema::Type::String,
                            ),
                        ),
                )
                .required("name");
            object = object
                .property(
                    "active",
                    utoipa::openapi::ObjectBuilder::new()
                        .schema_type(
                            utoipa::openapi::schema::SchemaType::new(
                                utoipa::openapi::schema::Type::Boolean,
                            ),
                        ),
                )
                .required("active");
            object
        }
            .into()
    }
}
impl utoipa::ToSchema for ItemList {
    fn name() -> std::borrow::Cow<'static, str> {
        std::borrow::Cow::Borrowed("ItemList")
    }
    fn schemas(
        schemas: &mut Vec<
            (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
        >,
    ) {
        schemas.extend([]);
    }
}
impl From<Item> for ItemList {
    fn from(model: Item) -> Self {
        Self {
            id: model.id,
            name: model.name,
            active: model.active,
        }
    }
}
impl From<Model> for ItemList {
    fn from(model: Model) -> Self {
        Self {
            id: model.id,
            name: model.name,
            active: model.active,
        }
    }
}
pub struct ItemResponse {
    pub id: Uuid,
    pub name: String,
    pub active: bool,
}
#[automatically_derived]
impl ::core::clone::Clone for ItemResponse {
    #[inline]
    fn clone(&self) -> ItemResponse {
        ItemResponse {
            id: ::core::clone::Clone::clone(&self.id),
            name: ::core::clone::Clone::clone(&self.name),
            active: ::core::clone::Clone::clone(&self.active),
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for ItemResponse {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "ItemResponse",
            "id",
            &self.id,
            "name",
            &self.name,
            "active",
            &&self.active,
        )
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for ItemResponse {}
#[automatically_derived]
impl ::core::cmp::PartialEq for ItemResponse {
    #[inline]
    fn eq(&self, other: &ItemResponse) -> bool {
        self.active == other.active && self.id == other.id && self.name == other.name
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for ItemResponse {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private228::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "ItemResponse",
                false as usize + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "id",
                &self.id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "name",
                &self.name,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "active",
                &self.active,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for ItemResponse {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private228::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private228::Formatter,
                ) -> _serde::__private228::fmt::Result {
                    _serde::__private228::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private228::Ok(__Field::__field0),
                        1u64 => _serde::__private228::Ok(__Field::__field1),
                        2u64 => _serde::__private228::Ok(__Field::__field2),
                        _ => _serde::__private228::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "id" => _serde::__private228::Ok(__Field::__field0),
                        "name" => _serde::__private228::Ok(__Field::__field1),
                        "active" => _serde::__private228::Ok(__Field::__field2),
                        _ => _serde::__private228::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"id" => _serde::__private228::Ok(__Field::__field0),
                        b"name" => _serde::__private228::Ok(__Field::__field1),
                        b"active" => _serde::__private228::Ok(__Field::__field2),
                        _ => _serde::__private228::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private228::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private228::PhantomData<ItemResponse>,
                lifetime: _serde::__private228::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = ItemResponse;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private228::Formatter,
                ) -> _serde::__private228::fmt::Result {
                    _serde::__private228::Formatter::write_str(
                        __formatter,
                        "struct ItemResponse",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private228::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        Uuid,
                    >(&mut __seq)? {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            return _serde::__private228::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct ItemResponse with 3 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            return _serde::__private228::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct ItemResponse with 3 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        bool,
                    >(&mut __seq)? {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            return _serde::__private228::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct ItemResponse with 3 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private228::Ok(ItemResponse {
                        id: __field0,
                        name: __field1,
                        active: __field2,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private228::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private228::Option<Uuid> = _serde::__private228::None;
                    let mut __field1: _serde::__private228::Option<String> = _serde::__private228::None;
                    let mut __field2: _serde::__private228::Option<bool> = _serde::__private228::None;
                    while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private228::Option::is_some(&__field0) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                    );
                                }
                                __field0 = _serde::__private228::Some(
                                    _serde::de::MapAccess::next_value::<Uuid>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private228::Option::is_some(&__field1) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                    );
                                }
                                __field1 = _serde::__private228::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private228::Option::is_some(&__field2) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("active"),
                                    );
                                }
                                __field2 = _serde::__private228::Some(
                                    _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private228::Some(__field0) => __field0,
                        _serde::__private228::None => {
                            _serde::__private228::de::missing_field("id")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private228::Some(__field1) => __field1,
                        _serde::__private228::None => {
                            _serde::__private228::de::missing_field("name")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private228::Some(__field2) => __field2,
                        _serde::__private228::None => {
                            _serde::__private228::de::missing_field("active")?
                        }
                    };
                    _serde::__private228::Ok(ItemResponse {
                        id: __field0,
                        name: __field1,
                        active: __field2,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["id", "name", "active"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "ItemResponse",
                FIELDS,
                __Visitor {
                    marker: _serde::__private228::PhantomData::<ItemResponse>,
                    lifetime: _serde::__private228::PhantomData,
                },
            )
        }
    }
};
impl utoipa::__dev::ComposeSchema for ItemResponse {
    fn compose(
        mut generics: Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>,
    ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
        {
            let mut object = utoipa::openapi::ObjectBuilder::new();
            object = object
                .property(
                    "id",
                    utoipa::openapi::ObjectBuilder::new()
                        .schema_type(
                            utoipa::openapi::schema::SchemaType::new(
                                utoipa::openapi::schema::Type::String,
                            ),
                        )
                        .format(
                            Some(
                                utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                    utoipa::openapi::schema::KnownFormat::Uuid,
                                ),
                            ),
                        ),
                )
                .required("id");
            object = object
                .property(
                    "name",
                    utoipa::openapi::ObjectBuilder::new()
                        .schema_type(
                            utoipa::openapi::schema::SchemaType::new(
                                utoipa::openapi::schema::Type::String,
                            ),
                        ),
                )
                .required("name");
            object = object
                .property(
                    "active",
                    utoipa::openapi::ObjectBuilder::new()
                        .schema_type(
                            utoipa::openapi::schema::SchemaType::new(
                                utoipa::openapi::schema::Type::Boolean,
                            ),
                        ),
                )
                .required("active");
            object
        }
            .into()
    }
}
impl utoipa::ToSchema for ItemResponse {
    fn name() -> std::borrow::Cow<'static, str> {
        std::borrow::Cow::Borrowed("ItemResponse")
    }
    fn schemas(
        schemas: &mut Vec<
            (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
        >,
    ) {
        schemas.extend([]);
    }
}
impl From<Item> for ItemResponse {
    fn from(model: Item) -> Self {
        Self {
            id: model.id,
            name: model.name,
            active: model.active,
        }
    }
}
pub enum Relation {}
#[automatically_derived]
impl ::core::marker::Copy for Relation {}
#[automatically_derived]
impl ::core::clone::Clone for Relation {
    #[inline]
    fn clone(&self) -> Relation {
        *self
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for Relation {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {}
    }
}
///An iterator over the variants of [Relation]
#[allow(missing_copy_implementations)]
pub struct RelationIter {
    idx: usize,
    back_idx: usize,
    marker: ::core::marker::PhantomData<()>,
}
impl ::core::fmt::Debug for RelationIter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("RelationIter").field("len", &self.len()).finish()
    }
}
impl RelationIter {
    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
        match idx {
            _ => ::core::option::Option::None,
        }
    }
}
impl sea_orm::strum::IntoEnumIterator for Relation {
    type Iterator = RelationIter;
    fn iter() -> RelationIter {
        RelationIter {
            idx: 0,
            back_idx: 0,
            marker: ::core::marker::PhantomData,
        }
    }
}
impl Iterator for RelationIter {
    type Item = Relation;
    fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
        self.nth(0)
    }
    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
        let t = if self.idx + self.back_idx >= 0usize {
            0
        } else {
            0usize - self.idx - self.back_idx
        };
        (t, Some(t))
    }
    fn nth(&mut self, n: usize) -> ::core::option::Option<<Self as Iterator>::Item> {
        let idx = self.idx + n + 1;
        if idx + self.back_idx > 0usize {
            self.idx = 0usize;
            ::core::option::Option::None
        } else {
            self.idx = idx;
            RelationIter::get(self, idx - 1)
        }
    }
}
impl ExactSizeIterator for RelationIter {
    fn len(&self) -> usize {
        self.size_hint().0
    }
}
impl DoubleEndedIterator for RelationIter {
    fn next_back(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
        let back_idx = self.back_idx + 1;
        if self.idx + back_idx > 0usize {
            self.back_idx = 0usize;
            ::core::option::Option::None
        } else {
            self.back_idx = back_idx;
            RelationIter::get(self, 0usize - self.back_idx)
        }
    }
}
impl ::core::iter::FusedIterator for RelationIter {}
impl Clone for RelationIter {
    fn clone(&self) -> RelationIter {
        RelationIter {
            idx: self.idx,
            back_idx: self.back_idx,
            marker: self.marker.clone(),
        }
    }
}
#[automatically_derived]
impl sea_orm::entity::RelationTrait for Relation {
    fn def(&self) -> sea_orm::entity::RelationDef {
        match self {
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!("No RelationDef for Relation"),
                );
            }
        }
    }
}
impl ActiveModelBehavior for ActiveModel {}
fn main() {}
