<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CRUDCrate Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Transform Sea-ORM entities into Axum-based REST APIs with a single derive macro">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom-255ba322.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "ayu";
            window.path_to_searchindex_js = "searchindex-5bea4c1b.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-ccff9747.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">CRUDCrate Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/evanjt/crudcrate" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="crudcrate"><a class="header" href="#crudcrate">CRUDCrate</a></h1>
<p><strong>Transform Sea-ORM entities into Axum-based REST APIs with a single derive
macro.</strong></p>
<p>CRUDCrate eliminates unnecessary boilerplate in creating REST APIs. Its focus
is to autogenerate the repetitive code needed for basic CRUD operations but
leave open the opportunity to customise and extend wherever needed.</p>
<p>With a Sea-ORM entity definition, adding <code>#[derive(EntityToModels)]</code> to your
model and then <code>#[crudcrate(generate_router)]</code> is all that is needed for the
default behaviour that includes:</p>
<ul>
<li>CRUD endpoints</li>
<li>Utoipa OpenAPI documentation</li>
<li>Request/response models</li>
<li>Error handling</li>
<li>Filtering</li>
<li>Sorting</li>
<li>Pagination</li>
<li>Relationship loading</li>
</ul>
<!-- 
## Quick Example

```rust
use axum::{Router, Extension};
use sea_orm::DatabaseConnection;
use crudcrate::EntityToModels;

// Your Sea-ORM entity
#[derive(Clone, Debug, DeriveEntityModel, EntityToModels)]
#[crudcrate(generate_router)]
#[sea_orm(table_name = "todos")]
pub struct Model {
    #[sea_orm(primary_key)]
    #[crudcrate(primary_key, exclude(create, update))]
    pub id: i32,

    #[crudcrate(filterable, sortable)]
    pub email: String,

    #[crudcrate(exclude(one, list))]  
    pub password_hash: String,

    #[crudcrate(exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTime,
}

// In your main.rs
async fn main() {
    let db: DatabaseConnection = /* ... */;

    let app = Router::new()
        .merge(user::user_router())
        .layer(Extension(db));

    axum::serve(listener, app).await.unwrap();
}
```


## Installation

Add this to your `Cargo.toml`:

```bash
cargo add crudcrate
``` 
--><div style="break-before: page; page-break-before: always;"></div>
<h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Build a complete REST API in under 5 minutes.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Rust 1.70+ installed</li>
<li>A database (PostgreSQL, MySQL, or SQLite)</li>
<li>Basic familiarity with Sea-ORM</li>
</ul>
<h2 id="step-1-create-a-new-project"><a class="header" href="#step-1-create-a-new-project">Step 1: Create a New Project</a></h2>
<pre><code class="language-bash">cargo new my-api
cd my-api
</code></pre>
<h2 id="step-2-add-dependencies"><a class="header" href="#step-2-add-dependencies">Step 2: Add Dependencies</a></h2>
<pre><code class="language-toml"># Cargo.toml
[dependencies]
crudcrate = "0.1"
sea-orm = { version = "1.0", features = ["runtime-tokio-rustls", "sqlx-sqlite"] }
axum = "0.7"
tokio = { version = "1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
</code></pre>
<h2 id="step-3-define-your-entity"><a class="header" href="#step-3-define-your-entity">Step 3: Define Your Entity</a></h2>
<p>Create <code>src/entities/todo.rs</code>:</p>
<pre><code class="language-rust">use crudcrate::EntityToModels;
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(generate_router)]
#[sea_orm(table_name = "todos")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    #[crudcrate(filterable, sortable, fulltext)]
    pub title: String,

    pub description: Option&lt;String&gt;,

    #[crudcrate(filterable)]
    pub completed: bool,

    #[crudcrate(sortable, exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}</code></pre>
<h2 id="step-4-create-your-server"><a class="header" href="#step-4-create-your-server">Step 4: Create Your Server</a></h2>
<pre><code class="language-rust">// src/main.rs
mod entities;

use axum::{Extension, Router};
use sea_orm::{Database, DatabaseConnection};
use std::net::SocketAddr;

#[tokio::main]
async fn main() {
    // Connect to database
    let db: DatabaseConnection = Database::connect("sqlite::memory:")
        .await
        .expect("Failed to connect to database");

    // Create table (in production, use migrations)
    // sea_orm::Schema::create_table_from_entity(entities::todo::Entity);

    // Build router with generated CRUD endpoints
    let app = Router::new()
        .merge(entities::todo::todo_router())
        .layer(Extension(db));

    // Start server
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    println!("Server running at http://{}", addr);

    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}</code></pre>
<h2 id="step-5-run-it"><a class="header" href="#step-5-run-it">Step 5: Run It</a></h2>
<pre><code class="language-bash">cargo run
</code></pre>
<h2 id="step-6-test-your-api"><a class="header" href="#step-6-test-your-api">Step 6: Test Your API</a></h2>
<pre><code class="language-bash"># Create a todo
curl -X POST http://localhost:3000/todos \
  -H "Content-Type: application/json" \
  -d '{"title": "Learn CRUDCrate", "description": "Read the docs", "completed": false}'

# List all todos
curl http://localhost:3000/todos

# Get a specific todo
curl http://localhost:3000/todos/{id}

# Update a todo
curl -X PUT http://localhost:3000/todos/{id} \
  -H "Content-Type: application/json" \
  -d '{"completed": true}'

# Filter todos
curl "http://localhost:3000/todos?filter={\"completed\":false}"

# Search todos
curl "http://localhost:3000/todos?q=learn"

# Sort todos
curl "http://localhost:3000/todos?sort=[\"created_at\",\"DESC\"]"

# Delete a todo
curl -X DELETE http://localhost:3000/todos/{id}
</code></pre>
<h2 id="what-just-happened"><a class="header" href="#what-just-happened">What Just Happened?</a></h2>
<p>From a single <code>#[derive(EntityToModels)]</code>, CRUDCrate generated:</p>
<ol>
<li>
<p><strong>Four model structs:</strong></p>
<ul>
<li><code>Todo</code> - Full response model</li>
<li><code>TodoCreate</code> - Create request (excludes <code>id</code>, <code>created_at</code>)</li>
<li><code>TodoUpdate</code> - Update request (all fields optional)</li>
<li><code>TodoList</code> - List response model</li>
</ul>
</li>
<li>
<p><strong>Six HTTP endpoints:</strong></p>
<ul>
<li><code>GET /todos</code> - List with filtering, sorting, pagination</li>
<li><code>GET /todos/:id</code> - Get single item</li>
<li><code>POST /todos</code> - Create</li>
<li><code>PUT /todos/:id</code> - Update</li>
<li><code>DELETE /todos/:id</code> - Delete one</li>
<li><code>DELETE /todos</code> - Bulk delete</li>
</ul>
</li>
<li>
<p><strong>Query capabilities:</strong></p>
<ul>
<li>Filtering on <code>title</code>, <code>completed</code> fields</li>
<li>Sorting on <code>title</code>, <code>created_at</code> fields</li>
<li>Fulltext search on <code>title</code></li>
<li>Automatic pagination</li>
</ul>
</li>
</ol>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li>Learn about <a href="#attribute-system">Field Attributes</a> to customize your models</li>
<li>Add <a href="#relationships--joins">Relationships</a> for nested data</li>
<li>Implement <a href="#custom-operations">Custom Operations</a> for business logic</li>
<li>Configure <a href="#validation-1">Validation</a> for input checking</li>
</ul>
<div class="info">
<p><strong>Tip:</strong> Run <code>cargo doc --open</code> to see the generated documentation for your models and traits.</p>
</div>

<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>CRUDCrate integrates with the Rust ecosystem. Here’s how to set it up for your project.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li><strong>Rust</strong>: 1.70 or later (for stable proc-macro features)</li>
<li><strong>Sea-ORM</strong>: 1.0+ (the ORM layer)</li>
<li><strong>Axum</strong>: 0.7+ (the web framework)</li>
<li><strong>Database</strong>: PostgreSQL, MySQL, or SQLite</li>
</ul>
<h2 id="basic-installation"><a class="header" href="#basic-installation">Basic Installation</a></h2>
<p>Add CRUDCrate and its peer dependencies to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
crudcrate = "0.1"

# Sea-ORM - choose your database backend
sea-orm = { version = "1.0", features = [
    "runtime-tokio-rustls",
    "sqlx-postgres",  # or sqlx-mysql, sqlx-sqlite
] }

# Axum web framework
axum = "0.7"

# Async runtime
tokio = { version = "1", features = ["full"] }

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Common types
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
</code></pre>
<h2 id="database-specific-setup"><a class="header" href="#database-specific-setup">Database-Specific Setup</a></h2>
<h3 id="postgresql-recommended"><a class="header" href="#postgresql-recommended">PostgreSQL (Recommended)</a></h3>
<pre><code class="language-toml">[dependencies]
sea-orm = { version = "1.0", features = [
    "runtime-tokio-rustls",
    "sqlx-postgres",
] }
</code></pre>
<p>PostgreSQL gets the best optimizations:</p>
<ul>
<li>GIN indexes for fulltext search</li>
<li><code>tsvector</code> query optimization</li>
<li>Array operations for batch queries</li>
</ul>
<h3 id="mysql"><a class="header" href="#mysql">MySQL</a></h3>
<pre><code class="language-toml">[dependencies]
sea-orm = { version = "1.0", features = [
    "runtime-tokio-rustls",
    "sqlx-mysql",
] }
</code></pre>
<p>MySQL features:</p>
<ul>
<li>FULLTEXT index support</li>
<li><code>MATCH AGAINST</code> query optimization</li>
<li>Optimized <code>LIKE</code> queries</li>
</ul>
<h3 id="sqlite"><a class="header" href="#sqlite">SQLite</a></h3>
<pre><code class="language-toml">[dependencies]
sea-orm = { version = "1.0", features = [
    "runtime-tokio-rustls",
    "sqlx-sqlite",
] }
</code></pre>
<p>SQLite is great for:</p>
<ul>
<li>Development and testing</li>
<li>Embedded applications</li>
<li>Single-file databases</li>
</ul>
<h2 id="optional-features"><a class="header" href="#optional-features">Optional Features</a></h2>
<h3 id="validation-support"><a class="header" href="#validation-support">Validation Support</a></h3>
<pre><code class="language-toml">[dependencies]
crudcrate = { version = "0.1", features = ["validation"] }
validator = "0.18"
</code></pre>
<h3 id="tracinglogging"><a class="header" href="#tracinglogging">Tracing/Logging</a></h3>
<pre><code class="language-toml">[dependencies]
tracing = "0.1"
tracing-subscriber = "0.3"
</code></pre>
<p>CRUDCrate uses <code>tracing</code> for structured logging when available.</p>
<h2 id="verify-installation"><a class="header" href="#verify-installation">Verify Installation</a></h2>
<p>Create a simple test to verify everything works:</p>
<pre><code class="language-rust">use crudcrate::EntityToModels;
use sea_orm::entity::prelude::*;

#[derive(Clone, Debug, DeriveEntityModel, EntityToModels)]
#[sea_orm(table_name = "test")]
pub struct Model {
    #[sea_orm(primary_key)]
    #[crudcrate(primary_key)]
    pub id: i32,
    pub name: String,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

fn main() {
    // If this compiles, CRUDCrate is working!
    println!("CRUDCrate installed successfully!");
}</code></pre>
<p>Run:</p>
<pre><code class="language-bash">cargo build
</code></pre>
<p>If compilation succeeds, you’re ready to go!</p>
<h2 id="ide-setup"><a class="header" href="#ide-setup">IDE Setup</a></h2>
<h3 id="vs-code"><a class="header" href="#vs-code">VS Code</a></h3>
<p>Install the <code>rust-analyzer</code> extension for:</p>
<ul>
<li>Macro expansion preview</li>
<li>Type hints for generated models</li>
<li>Jump to definition for generated code</li>
</ul>
<h3 id="intellijclion"><a class="header" href="#intellijclion">IntelliJ/CLion</a></h3>
<p>The Rust plugin provides similar features. Enable “Expand macros” in settings.</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="cannot-find-derive-macro-entitytomodels"><a class="header" href="#cannot-find-derive-macro-entitytomodels">“cannot find derive macro <code>EntityToModels</code>”</a></h3>
<p>Make sure you’ve imported it:</p>
<pre><code class="language-rust">use crudcrate::EntityToModels;</code></pre>
<h3 id="unresolved-import-sea_ormentityprelude"><a class="header" href="#unresolved-import-sea_ormentityprelude">“unresolved import <code>sea_orm::entity::prelude</code>”</a></h3>
<p>Check your Sea-ORM features include the database backend:</p>
<pre><code class="language-toml">sea-orm = { version = "1.0", features = ["runtime-tokio-rustls", "sqlx-postgres"] }
</code></pre>
<h3 id="slow-compilation"><a class="header" href="#slow-compilation">Slow compilation</a></h3>
<p>Proc macros can slow down incremental builds. Tips:</p>
<ul>
<li>Use <code>cargo build --release</code> for production</li>
<li>Consider splitting entities into separate crates for large projects</li>
<li>Use <code>cargo check</code> during development</li>
</ul>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li>Follow the <a href="#first-api-in-5-minutes">First API</a> tutorial</li>
<li>Understand the <a href="#project-structure">Project Structure</a></li>
<li>Learn about <a href="#the-entity-model">The Entity Model</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="first-api-in-5-minutes"><a class="header" href="#first-api-in-5-minutes">First API in 5 Minutes</a></h1>
<p>Let’s build a task management API from scratch. By the end, you’ll have a fully functional REST API with filtering, sorting, and pagination.</p>
<h2 id="what-were-building"><a class="header" href="#what-were-building">What We’re Building</a></h2>
<p>A task management API with:</p>
<ul>
<li>Tasks that belong to projects</li>
<li>Filtering by status and priority</li>
<li>Fulltext search on task names</li>
<li>Sorting by due date</li>
<li>Pagination for large result sets</li>
</ul>
<h2 id="step-1-project-setup"><a class="header" href="#step-1-project-setup">Step 1: Project Setup</a></h2>
<pre><code class="language-bash">cargo new taskapi
cd taskapi
</code></pre>
<p>Update <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "taskapi"
version = "0.1.0"
edition = "2021"

[dependencies]
crudcrate = "0.1"
sea-orm = { version = "1.0", features = ["runtime-tokio-rustls", "sqlx-sqlite"] }
axum = "0.7"
tokio = { version = "1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
tower-http = { version = "0.5", features = ["cors"] }
</code></pre>
<h2 id="step-2-define-the-task-entity"><a class="header" href="#step-2-define-the-task-entity">Step 2: Define the Task Entity</a></h2>
<p>Create <code>src/task.rs</code>:</p>
<pre><code class="language-rust">use crudcrate::EntityToModels;
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Task priority levels
#[derive(Clone, Debug, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(StringLen::N(10))")]
pub enum Priority {
    #[sea_orm(string_value = "low")]
    Low,
    #[sea_orm(string_value = "medium")]
    Medium,
    #[sea_orm(string_value = "high")]
    High,
    #[sea_orm(string_value = "urgent")]
    Urgent,
}

/// Task status
#[derive(Clone, Debug, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(StringLen::N(15))")]
pub enum Status {
    #[sea_orm(string_value = "todo")]
    Todo,
    #[sea_orm(string_value = "in_progress")]
    InProgress,
    #[sea_orm(string_value = "done")]
    Done,
    #[sea_orm(string_value = "cancelled")]
    Cancelled,
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(generate_router)]
#[sea_orm(table_name = "tasks")]
pub struct Model {
    /// Unique task identifier (auto-generated)
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    /// Task title - searchable and sortable
    #[crudcrate(filterable, sortable, fulltext)]
    pub title: String,

    /// Detailed description (optional)
    pub description: Option&lt;String&gt;,

    /// Task priority - filterable for priority views
    #[crudcrate(filterable, sortable)]
    pub priority: Priority,

    /// Current status - filterable for kanban boards
    #[crudcrate(filterable)]
    pub status: Status,

    /// Due date - sortable for deadline views
    #[crudcrate(sortable, filterable)]
    pub due_date: Option&lt;DateTimeUtc&gt;,

    /// Project assignment (optional)
    #[crudcrate(filterable)]
    pub project_id: Option&lt;Uuid&gt;,

    /// Creation timestamp (auto-set)
    #[crudcrate(sortable, exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTimeUtc,

    /// Last update timestamp (auto-updated)
    #[crudcrate(exclude(create, update), on_create = chrono::Utc::now(), on_update = chrono::Utc::now())]
    pub updated_at: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}</code></pre>
<h2 id="step-3-create-the-server"><a class="header" href="#step-3-create-the-server">Step 3: Create the Server</a></h2>
<p>Update <code>src/main.rs</code>:</p>
<pre><code class="language-rust">mod task;

use axum::{Extension, Router};
use sea_orm::{Database, DatabaseConnection, DbBackend, Schema, ConnectionTrait};
use std::net::SocketAddr;
use tower_http::cors::CorsLayer;

#[tokio::main]
async fn main() {
    // Initialize logging
    tracing_subscriber::fmt::init();

    // Connect to SQLite (in-memory for demo)
    let db: DatabaseConnection = Database::connect("sqlite::memory:")
        .await
        .expect("Failed to connect to database");

    // Create table
    create_tables(&amp;db).await;

    // Build application with CORS enabled
    let app = Router::new()
        .merge(task::task_router())
        .layer(CorsLayer::permissive())
        .layer(Extension(db));

    // Start server
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    println!("Task API running at http://{}", addr);
    println!();
    println!("Try these commands:");
    println!("  Create task:  curl -X POST http://localhost:3000/tasks -H 'Content-Type: application/json' -d '{{\"title\":\"My Task\",\"priority\":\"high\",\"status\":\"todo\"}}'");
    println!("  List tasks:   curl http://localhost:3000/tasks");
    println!("  Filter:       curl 'http://localhost:3000/tasks?filter={{\"status\":\"todo\"}}'");

    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

async fn create_tables(db: &amp;DatabaseConnection) {
    let schema = Schema::new(DbBackend::Sqlite);
    let stmt = schema.create_table_from_entity(task::Entity);

    db.execute(db.get_database_backend().build(&amp;stmt))
        .await
        .expect("Failed to create table");
}</code></pre>
<h2 id="step-4-run-and-test"><a class="header" href="#step-4-run-and-test">Step 4: Run and Test</a></h2>
<pre><code class="language-bash">cargo run
</code></pre>
<p>Now test your API:</p>
<pre><code class="language-bash"># Create some tasks
curl -X POST http://localhost:3000/tasks \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Write documentation",
    "description": "Create user guide for CRUDCrate",
    "priority": "high",
    "status": "in_progress"
  }'

curl -X POST http://localhost:3000/tasks \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Fix login bug",
    "priority": "urgent",
    "status": "todo"
  }'

curl -X POST http://localhost:3000/tasks \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Review pull request",
    "priority": "medium",
    "status": "todo"
  }'
</code></pre>
<h2 id="step-5-explore-the-generated-api"><a class="header" href="#step-5-explore-the-generated-api">Step 5: Explore the Generated API</a></h2>
<h3 id="list-all-tasks"><a class="header" href="#list-all-tasks">List All Tasks</a></h3>
<pre><code class="language-bash">curl http://localhost:3000/tasks | jq
</code></pre>
<h3 id="filter-by-status"><a class="header" href="#filter-by-status">Filter by Status</a></h3>
<pre><code class="language-bash"># Get all todo tasks
curl 'http://localhost:3000/tasks?filter={"status":"todo"}' | jq
</code></pre>
<h3 id="filter-by-priority"><a class="header" href="#filter-by-priority">Filter by Priority</a></h3>
<pre><code class="language-bash"># Get urgent and high priority tasks
curl 'http://localhost:3000/tasks?priority_in=urgent,high' | jq
</code></pre>
<h3 id="search-tasks"><a class="header" href="#search-tasks">Search Tasks</a></h3>
<pre><code class="language-bash"># Fulltext search
curl 'http://localhost:3000/tasks?q=documentation' | jq
</code></pre>
<h3 id="sort-results"><a class="header" href="#sort-results">Sort Results</a></h3>
<pre><code class="language-bash"># Sort by priority descending
curl 'http://localhost:3000/tasks?sort=["priority","DESC"]' | jq

# Sort by creation date
curl 'http://localhost:3000/tasks?sort=["created_at","ASC"]' | jq
</code></pre>
<h3 id="pagination"><a class="header" href="#pagination">Pagination</a></h3>
<pre><code class="language-bash"># React Admin format (first 10)
curl 'http://localhost:3000/tasks?range=[0,9]' | jq

# Standard format
curl 'http://localhost:3000/tasks?page=1&amp;per_page=10' | jq
</code></pre>
<h3 id="update-a-task"><a class="header" href="#update-a-task">Update a Task</a></h3>
<pre><code class="language-bash"># Get task ID from list response, then:
curl -X PUT http://localhost:3000/tasks/{task-id} \
  -H "Content-Type: application/json" \
  -d '{"status": "done"}'
</code></pre>
<h3 id="delete-a-task"><a class="header" href="#delete-a-task">Delete a Task</a></h3>
<pre><code class="language-bash">curl -X DELETE http://localhost:3000/tasks/{task-id}
</code></pre>
<h2 id="what-crudcrate-generated"><a class="header" href="#what-crudcrate-generated">What CRUDCrate Generated</a></h2>
<p>From your 50-line entity definition, CRUDCrate generated:</p>
<h3 id="models"><a class="header" href="#models">Models</a></h3>
<pre><code class="language-rust">// Create request (no id, created_at, updated_at)
pub struct TaskCreate {
    pub title: String,
    pub description: Option&lt;String&gt;,
    pub priority: Priority,
    pub status: Status,
    pub due_date: Option&lt;DateTimeUtc&gt;,
    pub project_id: Option&lt;Uuid&gt;,
}

// Update request (all optional)
pub struct TaskUpdate {
    pub title: Option&lt;String&gt;,
    pub description: Option&lt;Option&lt;String&gt;&gt;,
    pub priority: Option&lt;Priority&gt;,
    pub status: Option&lt;Status&gt;,
    pub due_date: Option&lt;Option&lt;DateTimeUtc&gt;&gt;,
    pub project_id: Option&lt;Option&lt;Uuid&gt;&gt;,
}

// Response model
pub struct Task {
    pub id: Uuid,
    pub title: String,
    pub description: Option&lt;String&gt;,
    pub priority: Priority,
    pub status: Status,
    pub due_date: Option&lt;DateTimeUtc&gt;,
    pub project_id: Option&lt;Uuid&gt;,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
}</code></pre>
<h3 id="router"><a class="header" href="#router">Router</a></h3>
<pre><code class="language-rust">pub fn task_router() -&gt; Router {
    Router::new()
        .route("/tasks", get(list_tasks).post(create_task).delete(bulk_delete_tasks))
        .route("/tasks/:id", get(get_task).put(update_task).delete(delete_task))
}</code></pre>
<h3 id="handlers"><a class="header" href="#handlers">Handlers</a></h3>
<p>Each handler includes:</p>
<ul>
<li>Request parsing and validation</li>
<li>Database operations</li>
<li>Error handling with proper HTTP status codes</li>
<li>Response serialization</li>
</ul>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li>Add <a href="#relationships--joins">Relationships</a> to link tasks to projects</li>
<li>Implement <a href="#custom-operations">Custom Operations</a> for business logic</li>
<li>Add <a href="#validation-1">Validation</a> for input checking</li>
<li>Configure <a href="#security-best-practices">Security</a> for production</li>
</ul>
<div class="success">
<p><strong>Congratulations!</strong> You’ve built a production-grade REST API in 5 minutes. The same API built manually would require 500+ lines of boilerplate code.</p>
</div>

<div style="break-before: page; page-break-before: always;"></div>
<h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<p>How to organize a CRUDCrate project as it grows.</p>
<h2 id="minimal-structure"><a class="header" href="#minimal-structure">Minimal Structure</a></h2>
<p>For small projects with a few entities:</p>
<pre><code>my-api/
├── Cargo.toml
├── src/
│   ├── main.rs           # Server setup and routing
│   ├── user.rs           # User entity + CRUDCrate derives
│   ├── post.rs           # Post entity + CRUDCrate derives
│   └── comment.rs        # Comment entity + CRUDCrate derives
</code></pre>
<p><strong>main.rs:</strong></p>
<pre><code class="language-rust">mod user;
mod post;
mod comment;

use axum::Router;

#[tokio::main]
async fn main() {
    let db = /* database connection */;

    let app = Router::new()
        .merge(user::user_router())
        .merge(post::post_router())
        .merge(comment::comment_router())
        .layer(Extension(db));

    // ...
}</code></pre>
<h2 id="medium-projects"><a class="header" href="#medium-projects">Medium Projects</a></h2>
<p>For projects with 5-15 entities, group by domain:</p>
<pre><code>my-api/
├── Cargo.toml
├── src/
│   ├── main.rs
│   ├── lib.rs
│   ├── entities/
│   │   ├── mod.rs
│   │   ├── user.rs
│   │   ├── post.rs
│   │   └── comment.rs
│   ├── routes/
│   │   ├── mod.rs
│   │   └── api.rs        # Combines all entity routers
│   └── config.rs         # Database and app configuration
</code></pre>
<p><strong>entities/mod.rs:</strong></p>
<pre><code class="language-rust">pub mod user;
pub mod post;
pub mod comment;

pub use user::*;
pub use post::*;
pub use comment::*;</code></pre>
<p><strong>routes/api.rs:</strong></p>
<pre><code class="language-rust">use axum::Router;
use crate::entities;

pub fn api_router() -&gt; Router {
    Router::new()
        .nest("/api/v1", v1_routes())
}

fn v1_routes() -&gt; Router {
    Router::new()
        .merge(entities::user::user_router())
        .merge(entities::post::post_router())
        .merge(entities::comment::comment_router())
}</code></pre>
<h2 id="large-projects"><a class="header" href="#large-projects">Large Projects</a></h2>
<p>For enterprise applications with many entities:</p>
<pre><code>my-api/
├── Cargo.toml
├── src/
│   ├── main.rs
│   ├── lib.rs
│   │
│   ├── domain/                    # Domain modules
│   │   ├── mod.rs
│   │   │
│   │   ├── users/                 # User domain
│   │   │   ├── mod.rs
│   │   │   ├── entity.rs          # Sea-ORM entity
│   │   │   ├── operations.rs      # Custom CRUDOperations
│   │   │   ├── validation.rs      # Domain validation
│   │   │   └── service.rs         # Business logic
│   │   │
│   │   ├── posts/                 # Post domain
│   │   │   ├── mod.rs
│   │   │   ├── entity.rs
│   │   │   └── operations.rs
│   │   │
│   │   └── billing/               # Billing domain
│   │       ├── mod.rs
│   │       ├── invoice.rs
│   │       ├── payment.rs
│   │       └── subscription.rs
│   │
│   ├── infrastructure/
│   │   ├── mod.rs
│   │   ├── database.rs            # Database setup
│   │   ├── middleware.rs          # Auth, logging, etc.
│   │   └── config.rs              # Environment config
│   │
│   └── api/
│       ├── mod.rs
│       ├── router.rs              # Main router assembly
│       ├── v1/                    # API v1
│       │   ├── mod.rs
│       │   └── routes.rs
│       └── v2/                    # API v2 (when needed)
│           ├── mod.rs
│           └── routes.rs
</code></pre>
<h3 id="domain-module-pattern"><a class="header" href="#domain-module-pattern">Domain Module Pattern</a></h3>
<p><strong>domain/users/entity.rs:</strong></p>
<pre><code class="language-rust">use crudcrate::EntityToModels;
use sea_orm::entity::prelude::*;

#[derive(Clone, Debug, DeriveEntityModel, EntityToModels)]
#[crudcrate(
    generate_router,
    operations = super::operations::UserOperations
)]
#[sea_orm(table_name = "users")]
pub struct Model {
    #[sea_orm(primary_key)]
    #[crudcrate(primary_key, exclude(create, update))]
    pub id: i32,

    #[crudcrate(filterable, sortable)]
    pub email: String,

    #[crudcrate(exclude(one, list))]
    pub password_hash: String,
}

// ... Relation, ActiveModelBehavior</code></pre>
<p><strong>domain/users/operations.rs:</strong></p>
<pre><code class="language-rust">use crate::domain::users::entity;
use crudcrate::{CRUDOperations, ApiError};
use sea_orm::DatabaseConnection;

pub struct UserOperations;

#[async_trait::async_trait]
impl CRUDOperations for UserOperations {
    type Resource = entity::Model;

    async fn before_create(
        &amp;self,
        db: &amp;DatabaseConnection,
        data: &amp;mut entity::ModelCreate,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Hash password, validate email uniqueness, etc.
        Ok(())
    }
}</code></pre>
<p><strong>domain/users/mod.rs:</strong></p>
<pre><code class="language-rust">pub mod entity;
pub mod operations;
pub mod validation;
pub mod service;

pub use entity::*;</code></pre>
<h2 id="workspace-structure"><a class="header" href="#workspace-structure">Workspace Structure</a></h2>
<p>For very large projects, consider a Cargo workspace:</p>
<pre><code>my-platform/
├── Cargo.toml                    # Workspace root
│
├── crates/
│   ├── api/                      # Main API binary
│   │   ├── Cargo.toml
│   │   └── src/
│   │       └── main.rs
│   │
│   ├── entities/                 # Shared entities library
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── user.rs
│   │       └── post.rs
│   │
│   ├── domain/                   # Business logic library
│   │   ├── Cargo.toml
│   │   └── src/
│   │       └── lib.rs
│   │
│   └── migrations/               # Database migrations
│       ├── Cargo.toml
│       └── src/
│           └── lib.rs
│
└── tests/                        # Integration tests
    └── api_tests.rs
</code></pre>
<p><strong>Root Cargo.toml:</strong></p>
<pre><code class="language-toml">[workspace]
members = ["crates/*"]

[workspace.dependencies]
crudcrate = "0.1"
sea-orm = { version = "1.0", features = ["runtime-tokio-rustls", "sqlx-postgres"] }
axum = "0.7"
tokio = { version = "1", features = ["full"] }
</code></pre>
<p><strong>crates/entities/Cargo.toml:</strong></p>
<pre><code class="language-toml">[package]
name = "entities"
version = "0.1.0"
edition = "2021"

[dependencies]
crudcrate.workspace = true
sea-orm.workspace = true
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="entity-organization"><a class="header" href="#entity-organization">Entity Organization</a></h3>
<ol>
<li><strong>One entity per file</strong> - Keeps files focused and manageable</li>
<li><strong>Group by domain</strong> - Not by technical layer</li>
<li><strong>Co-locate related code</strong> - Operations, validation with entities</li>
</ol>
<h3 id="router-organization"><a class="header" href="#router-organization">Router Organization</a></h3>
<ol>
<li><strong>Version your API</strong> - Use <code>/api/v1/</code>, <code>/api/v2/</code> prefixes</li>
<li><strong>Merge routers in one place</strong> - Makes it easy to see all routes</li>
<li><strong>Add middleware at the router level</strong> - Auth, CORS, logging</li>
</ol>
<pre><code class="language-rust">pub fn api_router() -&gt; Router {
    Router::new()
        .nest("/api/v1", v1_routes())
        .layer(AuthLayer::new())
        .layer(CorsLayer::permissive())
        .layer(TraceLayer::new_for_http())
}</code></pre>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>Use environment variables with a config module:</p>
<pre><code class="language-rust">// src/config.rs
use std::env;

pub struct Config {
    pub database_url: String,
    pub port: u16,
    pub environment: String,
}

impl Config {
    pub fn from_env() -&gt; Self {
        Self {
            database_url: env::var("DATABASE_URL")
                .expect("DATABASE_URL must be set"),
            port: env::var("PORT")
                .unwrap_or_else(|_| "3000".to_string())
                .parse()
                .expect("PORT must be a number"),
            environment: env::var("RUST_ENV")
                .unwrap_or_else(|_| "development".to_string()),
        }
    }
}</code></pre>
<h3 id="testing-structure"><a class="header" href="#testing-structure">Testing Structure</a></h3>
<pre><code>my-api/
├── src/
│   └── ...
├── tests/
│   ├── common/
│   │   └── mod.rs           # Test utilities, fixtures
│   ├── user_tests.rs        # User entity tests
│   ├── post_tests.rs        # Post entity tests
│   └── integration.rs       # Full API integration tests
</code></pre>
<h2 id="migration-path"><a class="header" href="#migration-path">Migration Path</a></h2>
<h3 id="starting-small--growing-large"><a class="header" href="#starting-small--growing-large">Starting Small → Growing Large</a></h3>
<ol>
<li><strong>Start with minimal structure</strong> - Don’t over-engineer early</li>
<li><strong>Extract modules when pain appears</strong> - Files &gt; 500 lines, shared code</li>
<li><strong>Add domain folders when themes emerge</strong> - Related entities cluster</li>
<li><strong>Consider workspace when compilation slows</strong> - Parallel builds help</li>
</ol>
<div class="info">
<p><strong>Tip:</strong> Use <code>cargo modules structure</code> (from cargo-modules crate) to visualize your project structure as it grows.</p>
</div>

<div style="break-before: page; page-break-before: always;"></div>
<h1 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h1>
<p>Understanding CRUDCrate’s architecture helps you use it effectively and extend it when needed.</p>
<h2 id="the-big-picture"><a class="header" href="#the-big-picture">The Big Picture</a></h2>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                    Your Sea-ORM Entity                          │
│   #[derive(DeriveEntityModel, EntityToModels)]                  │
│   pub struct Model { ... }                                      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                 CRUDCrate Proc Macros                           │
│  (Compile-time code generation)                                 │
│                                                                 │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐        │
│  │ Create   │  │ Update   │  │ List     │  │ Response │        │
│  │ Model    │  │ Model    │  │ Model    │  │ Model    │        │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘        │
│                                                                 │
│  ┌──────────────────────────────────────────────────────┐      │
│  │              CRUDResource Implementation              │      │
│  │  (get_one, get_all, create, update, delete)          │      │
│  └──────────────────────────────────────────────────────┘      │
│                                                                 │
│  ┌──────────────────────────────────────────────────────┐      │
│  │              Axum Router (optional)                   │      │
│  │  GET /items, POST /items, PUT /items/:id, etc.       │      │
│  └──────────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                 CRUDCrate Runtime                               │
│  (Query parsing, filtering, pagination, error handling)         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Sea-ORM                                     │
│  (Database abstraction, queries, migrations)                    │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│              PostgreSQL / MySQL / SQLite                        │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="two-crates-one-system"><a class="header" href="#two-crates-one-system">Two Crates, One System</a></h2>
<p>CRUDCrate consists of two crates:</p>
<h3 id="1-crudcrate-derive-procedural-macros"><a class="header" href="#1-crudcrate-derive-procedural-macros">1. <code>crudcrate-derive</code> (Procedural Macros)</a></h3>
<p>This crate runs at <strong>compile time</strong>. It:</p>
<ul>
<li>Parses your entity struct and <code>#[crudcrate(...)]</code> attributes</li>
<li>Generates model structs (Create, Update, List, Response)</li>
<li>Implements the <code>CRUDResource</code> trait</li>
<li>Optionally generates an Axum router</li>
</ul>
<p>The generated code is type-safe and verified by the Rust compiler.</p>
<h3 id="2-crudcrate-runtime-library"><a class="header" href="#2-crudcrate-runtime-library">2. <code>crudcrate</code> (Runtime Library)</a></h3>
<p>This crate runs at <strong>runtime</strong>. It provides:</p>
<ul>
<li><code>CRUDResource</code> trait definition</li>
<li>Query parameter parsing (<code>FilterOptions</code>)</li>
<li>SQL condition building (filtering, sorting)</li>
<li>Pagination utilities</li>
<li>Error handling (<code>ApiError</code>)</li>
</ul>
<h2 id="code-generation-flow"><a class="header" href="#code-generation-flow">Code Generation Flow</a></h2>
<p>When you write:</p>
<pre><code class="language-rust">#[derive(EntityToModels)]
#[crudcrate(generate_router)]
pub struct Model {
    #[crudcrate(primary_key, exclude(create))]
    pub id: i32,

    #[crudcrate(filterable, sortable)]
    pub name: String,
}</code></pre>
<p>CRUDCrate generates (conceptually):</p>
<pre><code class="language-rust">// 1. Response model (your struct name without "Model")
pub struct Item {
    pub id: i32,
    pub name: String,
}

// 2. Create model (excludes `id`)
pub struct ItemCreate {
    pub name: String,
}

// 3. Update model (all optional)
pub struct ItemUpdate {
    pub name: Option&lt;String&gt;,
}

// 4. List model
pub struct ItemList {
    pub id: i32,
    pub name: String,
}

// 5. CRUDResource implementation
impl CRUDResource for Item {
    type EntityType = Entity;
    type CreateModel = ItemCreate;
    type UpdateModel = ItemUpdate;
    type ListModel = ItemList;

    async fn get_one(db: &amp;DatabaseConnection, id: i32) -&gt; Result&lt;Self, ApiError&gt; {
        // Generated query logic
    }

    async fn get_all(
        db: &amp;DatabaseConnection,
        condition: Condition,
        order: (Column, Order),
        offset: u64,
        limit: u64,
    ) -&gt; Result&lt;Vec&lt;Self::ListModel&gt;, ApiError&gt; {
        // Generated query logic with filtering
    }

    async fn create(db: &amp;DatabaseConnection, data: ItemCreate) -&gt; Result&lt;Self, ApiError&gt; {
        // Generated insert logic
    }

    async fn update(db: &amp;DatabaseConnection, id: i32, data: ItemUpdate) -&gt; Result&lt;Self, ApiError&gt; {
        // Generated update logic
    }

    async fn delete(db: &amp;DatabaseConnection, id: i32) -&gt; Result&lt;(), ApiError&gt; {
        // Generated delete logic
    }
}

// 6. Router (if generate_router enabled)
pub fn item_router() -&gt; Router {
    Router::new()
        .route("/items", get(list_handler).post(create_handler))
        .route("/items/:id", get(get_handler).put(update_handler).delete(delete_handler))
}</code></pre>
<h2 id="request-flow"><a class="header" href="#request-flow">Request Flow</a></h2>
<p>Here’s what happens when a request hits your API:</p>
<pre><code>HTTP Request: GET /items?filter={"name":"test"}&amp;sort=["id","DESC"]&amp;range=[0,9]
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  1. Axum Router                                                 │
│     - Matches route /items                                      │
│     - Extracts query parameters                                 │
│     - Calls list_handler                                        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. Query Parsing (CRUDCrate Runtime)                           │
│     - FilterOptions::from_query_params()                        │
│     - Parses filter JSON: {"name": "test"}                      │
│     - Parses sort: ["id", "DESC"]                               │
│     - Parses range: [0, 9] → offset=0, limit=10                │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  3. Condition Building                                          │
│     - apply_filters() converts JSON to Condition                │
│     - Validates "name" is marked filterable                     │
│     - Builds: Column::Name.eq("test")                          │
│     - SQL injection prevention applied                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  4. CRUDResource::get_all()                                     │
│     - Entity::find()                                            │
│     - .filter(condition)                                        │
│     - .order_by(Column::Id, Order::Desc)                       │
│     - .offset(0).limit(10)                                      │
│     - .all(db).await                                            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  5. Sea-ORM                                                     │
│     - Builds SQL: SELECT * FROM items                           │
│                   WHERE name = $1                               │
│                   ORDER BY id DESC                              │
│                   LIMIT 10 OFFSET 0                             │
│     - Executes against database                                 │
│     - Returns Vec&lt;Model&gt;                                        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  6. Response Building                                           │
│     - Convert Vec&lt;Model&gt; to Vec&lt;ItemList&gt;                       │
│     - Add Content-Range header                                  │
│     - Serialize to JSON                                         │
│     - Return HTTP 200 with body                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
HTTP Response: 200 OK
Content-Range: items 0-9/42
[{"id": 1, "name": "test"}, ...]
</code></pre>
<h2 id="compile-time-vs-runtime"><a class="header" href="#compile-time-vs-runtime">Compile-Time vs Runtime</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Compile-Time (Macros)</th><th>Runtime (Library)</th></tr>
</thead>
<tbody>
<tr><td><strong>When</strong></td><td><code>cargo build</code></td><td>Request handling</td></tr>
<tr><td><strong>What</strong></td><td>Code generation</td><td>Query execution</td></tr>
<tr><td><strong>Errors</strong></td><td>Compilation errors</td><td>HTTP error responses</td></tr>
<tr><td><strong>Cost</strong></td><td>Build time</td><td>Request latency</td></tr>
<tr><td><strong>Examples</strong></td><td>Missing attributes, type mismatches</td><td>Invalid filters, DB errors</td></tr>
</tbody>
</table>
</div>
<h2 id="extension-points"><a class="header" href="#extension-points">Extension Points</a></h2>
<p>CRUDCrate provides hooks at multiple levels:</p>
<h3 id="1-attribute-configuration"><a class="header" href="#1-attribute-configuration">1. Attribute Configuration</a></h3>
<p>Configure behavior at compile time:</p>
<pre><code class="language-rust">#[crudcrate(filterable, exclude(list))]
pub field: String,</code></pre>
<h3 id="2-crudoperations-trait"><a class="header" href="#2-crudoperations-trait">2. CRUDOperations Trait</a></h3>
<p>Add business logic:</p>
<pre><code class="language-rust">impl CRUDOperations for MyOps {
    async fn before_create(&amp;self, data: &amp;mut CreateModel) -&gt; Result&lt;(), ApiError&gt; {
        // Validation, transformation
    }
}</code></pre>
<h3 id="3-lifecycle-hooks"><a class="header" href="#3-lifecycle-hooks">3. Lifecycle Hooks</a></h3>
<p>Per-operation customization:</p>
<pre><code class="language-rust">#[crudcrate(
    create::one::pre = validate_fn,
    create::one::post = notify_fn,
)]</code></pre>
<h3 id="4-full-handler-override"><a class="header" href="#4-full-handler-override">4. Full Handler Override</a></h3>
<p>Complete control when needed:</p>
<pre><code class="language-rust">async fn custom_create(
    Extension(db): Extension&lt;DatabaseConnection&gt;,
    Json(data): Json&lt;ItemCreate&gt;,
) -&gt; Result&lt;Json&lt;Item&gt;, ApiError&gt; {
    // Your custom logic
}</code></pre>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<ul>
<li><strong>Zero runtime overhead</strong> for generated code (no reflection)</li>
<li><strong>Compile-time type checking</strong> catches errors early</li>
<li><strong>Database-native features</strong> used when available (indexes, fulltext)</li>
<li><strong>Parameterized queries</strong> prevent SQL injection without string escaping</li>
<li><strong>Pagination limits</strong> prevent DoS attacks (max 1000 items)</li>
</ul>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li>Understand <a href="#the-entity-model">The Entity Model</a></li>
<li>Learn about <a href="#generated-models">Generated Models</a></li>
<li>Explore the <a href="#the-crudresource-trait">CRUDResource Trait</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-entity-model"><a class="header" href="#the-entity-model">The Entity Model</a></h1>
<p>Your Sea-ORM entity is the foundation. CRUDCrate extends it with attributes to control API behavior.</p>
<h2 id="anatomy-of-a-crudcrate-entity"><a class="header" href="#anatomy-of-a-crudcrate-entity">Anatomy of a CRUDCrate Entity</a></h2>
<pre><code class="language-rust">use crudcrate::EntityToModels;
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(
    Clone,              // Required by Sea-ORM
    Debug,              // Useful for debugging
    PartialEq,          // Optional, for comparisons
    DeriveEntityModel,  // Sea-ORM: generates Entity, Column, etc.
    Serialize,          // For JSON responses
    Deserialize,        // For JSON requests
    EntityToModels,     // CRUDCrate: generates CRUD infrastructure
)]
#[crudcrate(generate_router)]       // CRUDCrate struct-level attribute
#[sea_orm(table_name = "products")] // Sea-ORM table mapping
pub struct Model {
    // Primary key - required
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    // Regular field with filtering
    #[crudcrate(filterable, sortable)]
    pub name: String,

    // Optional field
    pub description: Option&lt;String&gt;,

    // Excluded from responses
    #[crudcrate(exclude(one, list))]
    pub internal_notes: String,

    // Auto-managed timestamps
    #[crudcrate(exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTimeUtc,
}

// Required by Sea-ORM
#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}</code></pre>
<h2 id="required-derives"><a class="header" href="#required-derives">Required Derives</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Derive</th><th>Purpose</th><th>Required?</th></tr>
</thead>
<tbody>
<tr><td><code>Clone</code></td><td>Sea-ORM requirement</td><td>Yes</td></tr>
<tr><td><code>Debug</code></td><td>Debugging output</td><td>Recommended</td></tr>
<tr><td><code>DeriveEntityModel</code></td><td>Sea-ORM entity generation</td><td>Yes</td></tr>
<tr><td><code>Serialize</code></td><td>JSON response serialization</td><td>Yes</td></tr>
<tr><td><code>Deserialize</code></td><td>JSON request deserialization</td><td>Yes</td></tr>
<tr><td><code>EntityToModels</code></td><td>CRUDCrate generation</td><td>Yes</td></tr>
</tbody>
</table>
</div>
<h2 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h2>
<p>CRUDCrate follows these naming conventions:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Your Code</th><th>Generated</th></tr>
</thead>
<tbody>
<tr><td><code>pub struct Model</code></td><td><code>Product</code> (from table name)</td></tr>
<tr><td>Table: <code>products</code></td><td>Response: <code>Product</code></td></tr>
<tr><td></td><td>Create: <code>ProductCreate</code></td></tr>
<tr><td></td><td>Update: <code>ProductUpdate</code></td></tr>
<tr><td></td><td>List: <code>ProductList</code></td></tr>
<tr><td></td><td>Router: <code>product_router()</code></td></tr>
</tbody>
</table>
</div>
<h3 id="custom-naming"><a class="header" href="#custom-naming">Custom Naming</a></h3>
<p>Override with <code>api_struct</code>:</p>
<pre><code class="language-rust">#[crudcrate(api_struct = "Item")]
pub struct Model {
    // ...
}

// Generates: Item, ItemCreate, ItemUpdate, ItemList</code></pre>
<h2 id="field-types"><a class="header" href="#field-types">Field Types</a></h2>
<p>CRUDCrate handles common Rust and Sea-ORM types:</p>
<h3 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h3>
<pre><code class="language-rust">pub id: i32,           // Integers
pub id: i64,
pub price: f64,        // Floats
pub name: String,      // Strings
pub active: bool,      // Booleans
pub id: Uuid,          // UUIDs</code></pre>
<h3 id="optional-types"><a class="header" href="#optional-types">Optional Types</a></h3>
<pre><code class="language-rust">pub description: Option&lt;String&gt;,  // Nullable in DB
pub parent_id: Option&lt;i32&gt;,       // Optional foreign key</code></pre>
<h3 id="datetime-types"><a class="header" href="#datetime-types">Date/Time Types</a></h3>
<pre><code class="language-rust">use sea_orm::prelude::*;

pub created_at: DateTime,           // Without timezone
pub updated_at: DateTimeUtc,        // With UTC timezone
pub deleted_at: Option&lt;DateTimeUtc&gt;, // Soft delete</code></pre>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<pre><code class="language-rust">#[derive(EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(StringLen::N(20))")]
pub enum Status {
    #[sea_orm(string_value = "pending")]
    Pending,
    #[sea_orm(string_value = "active")]
    Active,
    #[sea_orm(string_value = "archived")]
    Archived,
}

// In your entity:
#[crudcrate(filterable)]
pub status: Status,</code></pre>
<h3 id="json-types"><a class="header" href="#json-types">JSON Types</a></h3>
<pre><code class="language-rust">use sea_orm::prelude::Json;

pub metadata: Json,                 // Arbitrary JSON
pub tags: Vec&lt;String&gt;,              // JSON array (with proper DB type)</code></pre>
<h2 id="primary-key-configuration"><a class="header" href="#primary-key-configuration">Primary Key Configuration</a></h2>
<p>Every entity needs exactly one primary key:</p>
<pre><code class="language-rust">// Integer auto-increment
#[sea_orm(primary_key)]
#[crudcrate(primary_key, exclude(create, update))]
pub id: i32,

// UUID (recommended)
#[sea_orm(primary_key, auto_increment = false)]
#[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
pub id: Uuid,

// String ID
#[sea_orm(primary_key, auto_increment = false)]
#[crudcrate(primary_key)]
pub slug: String,  // Client provides the ID</code></pre>
<h2 id="relationships"><a class="header" href="#relationships">Relationships</a></h2>
<p>Define relationships for join loading:</p>
<pre><code class="language-rust">// In your entity file
#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::comment::Entity")]
    Comments,

    #[sea_orm(
        belongs_to = "super::user::Entity",
        from = "Column::AuthorId",
        to = "super::user::Column::Id"
    )]
    Author,
}

// Implement Related trait
impl Related&lt;super::comment::Entity&gt; for Entity {
    fn to() -&gt; RelationDef {
        Relation::Comments.def()
    }
}

impl Related&lt;super::user::Entity&gt; for Entity {
    fn to() -&gt; RelationDef {
        Relation::Author.def()
    }
}

// In your Model struct, add join fields
#[sea_orm(ignore)]
#[crudcrate(non_db_attr, join(one, all))]
pub comments: Vec&lt;Comment&gt;,

#[sea_orm(ignore)]
#[crudcrate(non_db_attr, join(one))]
pub author: Option&lt;User&gt;,</code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre><code class="language-rust">use crudcrate::EntityToModels;
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Clone, Debug, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(StringLen::N(20))")]
pub enum PostStatus {
    #[sea_orm(string_value = "draft")]
    Draft,
    #[sea_orm(string_value = "published")]
    Published,
    #[sea_orm(string_value = "archived")]
    Archived,
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(generate_router, name_singular = "post", name_plural = "posts")]
#[sea_orm(table_name = "posts")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    #[crudcrate(filterable, sortable, fulltext)]
    pub title: String,

    #[crudcrate(fulltext)]
    pub content: String,

    pub excerpt: Option&lt;String&gt;,

    #[crudcrate(filterable)]
    pub status: PostStatus,

    #[crudcrate(filterable)]
    pub author_id: Uuid,

    #[crudcrate(sortable, filterable)]
    pub published_at: Option&lt;DateTimeUtc&gt;,

    #[crudcrate(sortable, exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTimeUtc,

    #[crudcrate(exclude(create, update), on_create = chrono::Utc::now(), on_update = chrono::Utc::now())]
    pub updated_at: DateTimeUtc,

    // Relationships
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one, all, depth = 1))]
    pub author: Option&lt;super::user::User&gt;,

    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one))]
    pub comments: Vec&lt;super::comment::Comment&gt;,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::user::Entity",
        from = "Column::AuthorId",
        to = "super::user::Column::Id"
    )]
    Author,

    #[sea_orm(has_many = "super::comment::Entity")]
    Comments,
}

impl Related&lt;super::user::Entity&gt; for Entity {
    fn to() -&gt; RelationDef {
        Relation::Author.def()
    }
}

impl Related&lt;super::comment::Entity&gt; for Entity {
    fn to() -&gt; RelationDef {
        Relation::Comments.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}</code></pre>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li>Learn about <a href="#generated-models">Generated Models</a></li>
<li>Understand the <a href="#attribute-system">Attribute System</a></li>
<li>Configure <a href="#relationships--joins">Relationships</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="generated-models"><a class="header" href="#generated-models">Generated Models</a></h1>
<p>CRUDCrate generates four model types from your entity. Each serves a specific purpose in your API.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>From this entity:</p>
<pre><code class="language-rust">#[derive(EntityToModels)]
#[sea_orm(table_name = "users")]
pub struct Model {
    #[crudcrate(primary_key, exclude(create, update))]
    pub id: i32,

    #[crudcrate(filterable)]
    pub email: String,

    #[crudcrate(exclude(one, list))]
    pub password_hash: String,

    pub display_name: Option&lt;String&gt;,

    #[crudcrate(exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTimeUtc,
}</code></pre>
<p>CRUDCrate generates:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Model</th><th>Purpose</th><th>Used In</th></tr>
</thead>
<tbody>
<tr><td><code>User</code></td><td>Full response</td><td><code>GET /users/:id</code></td></tr>
<tr><td><code>UserCreate</code></td><td>Create request</td><td><code>POST /users</code></td></tr>
<tr><td><code>UserUpdate</code></td><td>Update request</td><td><code>PUT /users/:id</code></td></tr>
<tr><td><code>UserList</code></td><td>List response</td><td><code>GET /users</code></td></tr>
</tbody>
</table>
</div>
<h2 id="response-model-user"><a class="header" href="#response-model-user">Response Model (User)</a></h2>
<p>The main response model, returned from <code>get_one</code>:</p>
<pre><code class="language-rust">// Generated
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct User {
    pub id: i32,
    pub email: String,
    // password_hash excluded via exclude(one)
    pub display_name: Option&lt;String&gt;,
    pub created_at: DateTimeUtc,
}</code></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Includes all fields except those with <code>exclude(one)</code></li>
<li>Used for single-item responses</li>
<li>Can include loaded relationships</li>
</ul>
<h2 id="create-model-usercreate"><a class="header" href="#create-model-usercreate">Create Model (UserCreate)</a></h2>
<p>Used for <code>POST</code> requests:</p>
<pre><code class="language-rust">// Generated
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct UserCreate {
    // id excluded via exclude(create)
    pub email: String,
    pub password_hash: String,  // NOT excluded from create
    pub display_name: Option&lt;String&gt;,
    // created_at excluded via exclude(create)
}</code></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Excludes primary keys (usually auto-generated)</li>
<li>Excludes timestamp fields</li>
<li>Includes fields the client should provide</li>
</ul>
<h2 id="update-model-userupdate"><a class="header" href="#update-model-userupdate">Update Model (UserUpdate)</a></h2>
<p>Used for <code>PUT</code> requests:</p>
<pre><code class="language-rust">// Generated
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct UserUpdate {
    // id excluded via exclude(update)
    pub email: Option&lt;String&gt;,
    pub password_hash: Option&lt;String&gt;,
    pub display_name: Option&lt;Option&lt;String&gt;&gt;,  // Double Option for nullable fields
    // created_at excluded via exclude(update)
}</code></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li>All fields are <code>Option&lt;T&gt;</code> for partial updates</li>
<li>Nullable fields become <code>Option&lt;Option&lt;T&gt;&gt;</code></li>
<li>Only provided fields are updated</li>
</ul>
<h3 id="double-option-explained"><a class="header" href="#double-option-explained">Double Option Explained</a></h3>
<p>For nullable database fields:</p>
<pre><code class="language-rust">// In entity
pub bio: Option&lt;String&gt;,

// In UserUpdate
pub bio: Option&lt;Option&lt;String&gt;&gt;,

// Usage:
// None = don't change
// Some(None) = set to NULL
// Some(Some("text")) = set to "text"</code></pre>
<pre><code class="language-json">// Don't change bio
{}

// Set bio to null
{"bio": null}

// Set bio to value
{"bio": "Hello world"}
</code></pre>
<h2 id="list-model-userlist"><a class="header" href="#list-model-userlist">List Model (UserList)</a></h2>
<p>Used for <code>GET</code> collection responses:</p>
<pre><code class="language-rust">// Generated
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct UserList {
    pub id: i32,
    pub email: String,
    // password_hash excluded via exclude(list)
    pub display_name: Option&lt;String&gt;,
    pub created_at: DateTimeUtc,
}</code></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Often identical to Response model</li>
<li>Can exclude expensive fields (e.g., large text, relationships)</li>
<li>Optimized for list performance</li>
</ul>
<h2 id="field-exclusion-matrix"><a class="header" href="#field-exclusion-matrix">Field Exclusion Matrix</a></h2>
<p>Control which fields appear in which models:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th><code>exclude(one)</code></th><th><code>exclude(create)</code></th><th><code>exclude(update)</code></th><th><code>exclude(list)</code></th></tr>
</thead>
<tbody>
<tr><td><code>id</code></td><td>In response</td><td><strong>Not in create</strong></td><td><strong>Not in update</strong></td><td>In list</td></tr>
<tr><td><code>email</code></td><td>In response</td><td>In create</td><td>In update</td><td>In list</td></tr>
<tr><td><code>password</code></td><td><strong>Not in response</strong></td><td>In create</td><td>In update</td><td><strong>Not in list</strong></td></tr>
<tr><td><code>created_at</code></td><td>In response</td><td><strong>Not in create</strong></td><td><strong>Not in update</strong></td><td>In list</td></tr>
</tbody>
</table>
</div>
<p>Example:</p>
<pre><code class="language-rust">// Never expose password
#[crudcrate(exclude(one, list))]
pub password_hash: String,

// Client can't set ID or timestamps
#[crudcrate(primary_key, exclude(create, update))]
pub id: Uuid,

#[crudcrate(exclude(create, update))]
pub created_at: DateTimeUtc,

// Exclude expensive content from lists
#[crudcrate(exclude(list))]
pub full_content: String,</code></pre>
<h2 id="model-traits"><a class="header" href="#model-traits">Model Traits</a></h2>
<p>All generated models implement:</p>
<pre><code class="language-rust">// Serialization
impl Serialize for User { }
impl Deserialize for User { }

// Cloning
impl Clone for User { }

// Debug output
impl Debug for User { }</code></pre>
<p>Additionally:</p>
<pre><code class="language-rust">// Response model implements From&lt;Sea-ORM Model&gt;
impl From&lt;Model&gt; for User { }

// Create model implements Into&lt;ActiveModel&gt;
impl From&lt;UserCreate&gt; for ActiveModel { }

// Update model implements merge
impl MergeIntoActiveModel&lt;ActiveModel&gt; for UserUpdate { }</code></pre>
<h2 id="conversions"><a class="header" href="#conversions">Conversions</a></h2>
<h3 id="entity-to-response"><a class="header" href="#entity-to-response">Entity to Response</a></h3>
<pre><code class="language-rust">let db_model: Model = Entity::find_by_id(1).one(db).await?;
let response: User = db_model.into();</code></pre>
<h3 id="create-to-activemodel"><a class="header" href="#create-to-activemodel">Create to ActiveModel</a></h3>
<pre><code class="language-rust">let create_data: UserCreate = /* from request */;
let active_model: ActiveModel = create_data.into();
let result = active_model.insert(db).await?;</code></pre>
<h3 id="update-merge"><a class="header" href="#update-merge">Update Merge</a></h3>
<pre><code class="language-rust">let update_data: UserUpdate = /* from request */;
let mut active_model: ActiveModel = existing.into();

// Only updates fields that were provided
update_data.merge_into(&amp;mut active_model);

let result = active_model.update(db).await?;</code></pre>
<h2 id="customization"><a class="header" href="#customization">Customization</a></h2>
<h3 id="custom-model-names"><a class="header" href="#custom-model-names">Custom Model Names</a></h3>
<pre><code class="language-rust">#[crudcrate(api_struct = "Item")]
pub struct Model { }

// Generates: Item, ItemCreate, ItemUpdate, ItemList</code></pre>
<h3 id="additional-derives"><a class="header" href="#additional-derives">Additional Derives</a></h3>
<p>The generated models use standard derives. For additional traits, implement them manually:</p>
<pre><code class="language-rust">// In your code
impl Default for UserCreate {
    fn default() -&gt; Self {
        Self {
            email: String::new(),
            password_hash: String::new(),
            display_name: None,
        }
    }
}</code></pre>
<h3 id="validation"><a class="header" href="#validation">Validation</a></h3>
<p>Add validation in <code>CRUDOperations</code>:</p>
<pre><code class="language-rust">impl CRUDOperations for UserOps {
    async fn before_create(&amp;self, data: &amp;mut UserCreate) -&gt; Result&lt;(), ApiError&gt; {
        if !data.email.contains('@') {
            return Err(ApiError::ValidationFailed(vec![
                ValidationError::new("email", "Invalid email format")
            ]));
        }
        Ok(())
    }
}</code></pre>
<h2 id="relationships-in-models"><a class="header" href="#relationships-in-models">Relationships in Models</a></h2>
<p>Join fields appear in response models:</p>
<pre><code class="language-rust">// Entity definition
#[sea_orm(ignore)]
#[crudcrate(non_db_attr, join(one, all))]
pub posts: Vec&lt;Post&gt;,

// Generated in User response model
pub struct User {
    pub id: i32,
    pub email: String,
    pub posts: Vec&lt;Post&gt;,  // Loaded automatically
}</code></pre>
<p>Control when relationships load:</p>
<ul>
<li><code>join(one)</code> - Load in <code>get_one</code> only</li>
<li><code>join(all)</code> - Load in <code>get_all</code> too (can be expensive)</li>
<li><code>join(one, all)</code> - Load in both</li>
</ul>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li>Understand the <a href="#the-crudresource-trait">CRUDResource Trait</a></li>
<li>Learn about <a href="#field-exclusion">Field Exclusion</a></li>
<li>Configure <a href="#relationships--joins">Relationships</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-crudresource-trait"><a class="header" href="#the-crudresource-trait">The CRUDResource Trait</a></h1>
<p><code>CRUDResource</code> is the core trait that powers all CRUD operations. CRUDCrate generates its implementation, but understanding it helps you customize behavior.</p>
<h2 id="trait-definition"><a class="header" href="#trait-definition">Trait Definition</a></h2>
<pre><code class="language-rust">#[async_trait]
pub trait CRUDResource: Sized + Send + Sync {
    /// The Sea-ORM entity type
    type EntityType: EntityTrait;

    /// Model for creating new records
    type CreateModel: DeserializeOwned + Send + Sync;

    /// Model for updating existing records
    type UpdateModel: DeserializeOwned + Send + Sync;

    /// Model for list responses (can differ from Self)
    type ListModel: Serialize + Send + Sync;

    /// The primary key type
    type PrimaryKey: Send + Sync;

    /// Get a single record by ID
    async fn get_one(
        db: &amp;DatabaseConnection,
        id: Self::PrimaryKey,
    ) -&gt; Result&lt;Self, ApiError&gt;;

    /// Get all records with filtering, sorting, and pagination
    async fn get_all(
        db: &amp;DatabaseConnection,
        condition: Condition,
        order: (Self::EntityType::Column, Order),
        offset: u64,
        limit: u64,
    ) -&gt; Result&lt;Vec&lt;Self::ListModel&gt;, ApiError&gt;;

    /// Create a new record
    async fn create(
        db: &amp;DatabaseConnection,
        data: Self::CreateModel,
    ) -&gt; Result&lt;Self, ApiError&gt;;

    /// Update an existing record
    async fn update(
        db: &amp;DatabaseConnection,
        id: Self::PrimaryKey,
        data: Self::UpdateModel,
    ) -&gt; Result&lt;Self, ApiError&gt;;

    /// Delete a record
    async fn delete(
        db: &amp;DatabaseConnection,
        id: Self::PrimaryKey,
    ) -&gt; Result&lt;(), ApiError&gt;;

    /// Delete multiple records
    async fn delete_many(
        db: &amp;DatabaseConnection,
        ids: Vec&lt;Self::PrimaryKey&gt;,
    ) -&gt; Result&lt;u64, ApiError&gt;;

    /// Get total count matching condition
    async fn total_count(
        db: &amp;DatabaseConnection,
        condition: &amp;Condition,
    ) -&gt; u64;
}</code></pre>
<h2 id="generated-implementation"><a class="header" href="#generated-implementation">Generated Implementation</a></h2>
<p>For this entity:</p>
<pre><code class="language-rust">#[derive(EntityToModels)]
#[sea_orm(table_name = "tasks")]
pub struct Model {
    #[crudcrate(primary_key)]
    pub id: i32,
    pub title: String,
}</code></pre>
<p>CRUDCrate generates:</p>
<pre><code class="language-rust">#[async_trait]
impl CRUDResource for Task {
    type EntityType = Entity;
    type CreateModel = TaskCreate;
    type UpdateModel = TaskUpdate;
    type ListModel = TaskList;
    type PrimaryKey = i32;

    async fn get_one(
        db: &amp;DatabaseConnection,
        id: i32,
    ) -&gt; Result&lt;Self, ApiError&gt; {
        let model = Entity::find_by_id(id)
            .one(db)
            .await
            .map_err(ApiError::from)?
            .ok_or(ApiError::NotFound)?;

        Ok(model.into())
    }

    async fn get_all(
        db: &amp;DatabaseConnection,
        condition: Condition,
        order: (Column, Order),
        offset: u64,
        limit: u64,
    ) -&gt; Result&lt;Vec&lt;TaskList&gt;, ApiError&gt; {
        let models = Entity::find()
            .filter(condition)
            .order_by(order.0, order.1)
            .offset(offset)
            .limit(limit)
            .all(db)
            .await
            .map_err(ApiError::from)?;

        Ok(models.into_iter().map(|m| m.into()).collect())
    }

    async fn create(
        db: &amp;DatabaseConnection,
        data: TaskCreate,
    ) -&gt; Result&lt;Self, ApiError&gt; {
        let active_model: ActiveModel = data.into();
        let model = active_model.insert(db).await.map_err(ApiError::from)?;
        Ok(model.into())
    }

    async fn update(
        db: &amp;DatabaseConnection,
        id: i32,
        data: TaskUpdate,
    ) -&gt; Result&lt;Self, ApiError&gt; {
        let existing = Entity::find_by_id(id)
            .one(db)
            .await
            .map_err(ApiError::from)?
            .ok_or(ApiError::NotFound)?;

        let mut active_model: ActiveModel = existing.into();
        data.merge_into(&amp;mut active_model);

        let model = active_model.update(db).await.map_err(ApiError::from)?;
        Ok(model.into())
    }

    async fn delete(
        db: &amp;DatabaseConnection,
        id: i32,
    ) -&gt; Result&lt;(), ApiError&gt; {
        let result = Entity::delete_by_id(id)
            .exec(db)
            .await
            .map_err(ApiError::from)?;

        if result.rows_affected == 0 {
            return Err(ApiError::NotFound);
        }

        Ok(())
    }

    async fn delete_many(
        db: &amp;DatabaseConnection,
        ids: Vec&lt;i32&gt;,
    ) -&gt; Result&lt;u64, ApiError&gt; {
        // Safety limit: max 100 items per request
        if ids.len() &gt; 100 {
            return Err(ApiError::BadRequest(
                "Cannot delete more than 100 items at once".into()
            ));
        }

        let result = Entity::delete_many()
            .filter(Column::Id.is_in(ids))
            .exec(db)
            .await
            .map_err(ApiError::from)?;

        Ok(result.rows_affected)
    }

    async fn total_count(
        db: &amp;DatabaseConnection,
        condition: &amp;Condition,
    ) -&gt; u64 {
        Entity::find()
            .filter(condition.clone())
            .count(db)
            .await
            .unwrap_or(0)
    }
}</code></pre>
<h2 id="using-crudresource-directly"><a class="header" href="#using-crudresource-directly">Using CRUDResource Directly</a></h2>
<p>You can call trait methods directly:</p>
<pre><code class="language-rust">use crudcrate::CRUDResource;

// Get one
let task = Task::get_one(&amp;db, 42).await?;

// Get all with filtering
let condition = Condition::all()
    .add(Column::Status.eq("active"));
let tasks = Task::get_all(&amp;db, condition, (Column::Id, Order::Asc), 0, 10).await?;

// Create
let new_task = Task::create(&amp;db, TaskCreate {
    title: "New task".into(),
}).await?;

// Update
let updated = Task::update(&amp;db, 42, TaskUpdate {
    title: Some("Updated title".into()),
}).await?;

// Delete
Task::delete(&amp;db, 42).await?;

// Count
let count = Task::total_count(&amp;db, &amp;Condition::all()).await;</code></pre>
<h2 id="relationship-loading"><a class="header" href="#relationship-loading">Relationship Loading</a></h2>
<p>When entities have relationships, <code>get_one</code> loads them:</p>
<pre><code class="language-rust">// Entity with relationship
#[sea_orm(ignore)]
#[crudcrate(non_db_attr, join(one))]
pub comments: Vec&lt;Comment&gt;,

// Generated get_one includes relationship loading
async fn get_one(db: &amp;DatabaseConnection, id: i32) -&gt; Result&lt;Self, ApiError&gt; {
    let model = Entity::find_by_id(id)
        .one(db)
        .await?
        .ok_or(ApiError::NotFound)?;

    // Load related comments
    let comments = model
        .find_related(comment::Entity)
        .all(db)
        .await?
        .into_iter()
        .map(|c| c.into())
        .collect();

    Ok(Task {
        id: model.id,
        title: model.title,
        comments,  // Loaded!
    })
}</code></pre>
<h2 id="custom-operations-with-crudoperations"><a class="header" href="#custom-operations-with-crudoperations">Custom Operations with CRUDOperations</a></h2>
<p>Extend behavior without reimplementing the trait:</p>
<pre><code class="language-rust">#[derive(EntityToModels)]
#[crudcrate(generate_router, operations = TaskOperations)]
pub struct Model { /* ... */ }

pub struct TaskOperations;

#[async_trait]
impl CRUDOperations for TaskOperations {
    type Resource = Task;

    /// Called before create
    async fn before_create(
        &amp;self,
        db: &amp;DatabaseConnection,
        data: &amp;mut TaskCreate,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Validate or transform
        data.title = data.title.trim().to_string();
        Ok(())
    }

    /// Called after create
    async fn after_create(
        &amp;self,
        db: &amp;DatabaseConnection,
        created: &amp;Task,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Send notification, update cache, etc.
        Ok(())
    }

    /// Called before delete
    async fn before_delete(
        &amp;self,
        db: &amp;DatabaseConnection,
        id: i32,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Check permissions, cascade deletes, etc.
        Ok(())
    }
}</code></pre>
<h2 id="handler-integration"><a class="header" href="#handler-integration">Handler Integration</a></h2>
<p>The generated router uses <code>CRUDResource</code> methods:</p>
<pre><code class="language-rust">// Generated handler (simplified)
async fn get_handler(
    Path(id): Path&lt;i32&gt;,
    Extension(db): Extension&lt;DatabaseConnection&gt;,
) -&gt; Result&lt;Json&lt;Task&gt;, ApiError&gt; {
    let item = Task::get_one(&amp;db, id).await?;
    Ok(Json(item))
}

async fn list_handler(
    Query(params): Query&lt;FilterOptions&gt;,
    Extension(db): Extension&lt;DatabaseConnection&gt;,
) -&gt; Result&lt;(HeaderMap, Json&lt;Vec&lt;TaskList&gt;&gt;), ApiError&gt; {
    let condition = apply_filters::&lt;Entity&gt;(&amp;params)?;
    let (offset, limit) = parse_pagination(&amp;params);
    let order = parse_sorting::&lt;Entity&gt;(&amp;params);

    let items = Task::get_all(&amp;db, condition, order, offset, limit).await?;
    let total = Task::total_count(&amp;db, &amp;condition).await;

    let headers = calculate_content_range("tasks", offset, items.len(), total);

    Ok((headers, Json(items)))
}</code></pre>
<h2 id="type-associations"><a class="header" href="#type-associations">Type Associations</a></h2>
<p>The trait’s associated types connect everything:</p>
<pre><code class="language-rust">impl CRUDResource for Task {
    // Links to Sea-ORM entity for database operations
    type EntityType = Entity;

    // Request model for POST /tasks
    type CreateModel = TaskCreate;

    // Request model for PUT /tasks/:id
    type UpdateModel = TaskUpdate;

    // Response model for GET /tasks
    type ListModel = TaskList;

    // Type of the primary key
    type PrimaryKey = i32;
}</code></pre>
<p>This enables:</p>
<ul>
<li>Type-safe column references (<code>Entity::Column</code>)</li>
<li>Correct serialization/deserialization</li>
<li>Compile-time verification of operations</li>
</ul>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>All methods return <code>Result&lt;T, ApiError&gt;</code>:</p>
<pre><code class="language-rust">async fn get_one(db: &amp;DatabaseConnection, id: i32) -&gt; Result&lt;Self, ApiError&gt; {
    Entity::find_by_id(id)
        .one(db)
        .await
        .map_err(ApiError::from)?  // Database error → 500
        .ok_or(ApiError::NotFound)  // Not found → 404
}</code></pre>
<p>Database errors are logged internally but return sanitized messages to clients.</p>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<ul>
<li>Learn about <a href="#attribute-system">Attributes</a> for configuration</li>
<li>Implement <a href="#custom-operations">Custom Operations</a></li>
<li>Configure <a href="#error-handling-3">Error Handling</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="attribute-system"><a class="header" href="#attribute-system">Attribute System</a></h1>
<p>CRUDCrate uses attributes to configure code generation. This guide covers all available attributes.</p>
<h2 id="attribute-syntax"><a class="header" href="#attribute-syntax">Attribute Syntax</a></h2>
<p>Attributes use the <code>#[crudcrate(...)]</code> syntax:</p>
<pre><code class="language-rust">// Struct-level
#[crudcrate(generate_router, api_struct = "Item")]
pub struct Model {
    // Field-level
    #[crudcrate(primary_key, filterable, sortable)]
    pub id: i32,
}</code></pre>
<h2 id="struct-level-attributes"><a class="header" href="#struct-level-attributes">Struct-Level Attributes</a></h2>
<p>Applied to the struct definition:</p>
<h3 id="generate_router"><a class="header" href="#generate_router"><code>generate_router</code></a></h3>
<p>Generates an Axum router function:</p>
<pre><code class="language-rust">#[crudcrate(generate_router)]
pub struct Model { }

// Generates:
pub fn model_router() -&gt; Router { }</code></pre>
<h3 id="api_struct"><a class="header" href="#api_struct"><code>api_struct</code></a></h3>
<p>Override the generated struct name:</p>
<pre><code class="language-rust">#[crudcrate(api_struct = "Product")]
pub struct Model { }

// Generates: Product, ProductCreate, ProductUpdate, ProductList
// Instead of: Model, ModelCreate, etc.</code></pre>
<h3 id="name_singular--name_plural"><a class="header" href="#name_singular--name_plural"><code>name_singular</code> / <code>name_plural</code></a></h3>
<p>Override resource names (for routing and Content-Range headers):</p>
<pre><code class="language-rust">#[crudcrate(name_singular = "person", name_plural = "people")]
pub struct Model { }

// Routes: /people, /people/:id
// Content-Range: people 0-9/100</code></pre>
<h3 id="operations"><a class="header" href="#operations"><code>operations</code></a></h3>
<p>Specify a custom CRUDOperations implementation:</p>
<pre><code class="language-rust">#[crudcrate(operations = MyOperations)]
pub struct Model { }

// MyOperations must implement CRUDOperations</code></pre>
<h3 id="description"><a class="header" href="#description"><code>description</code></a></h3>
<p>Add OpenAPI description:</p>
<pre><code class="language-rust">#[crudcrate(description = "User accounts for the application")]
pub struct Model { }</code></pre>
<h3 id="fulltext_language"><a class="header" href="#fulltext_language"><code>fulltext_language</code></a></h3>
<p>Set fulltext search language (PostgreSQL):</p>
<pre><code class="language-rust">#[crudcrate(fulltext_language = "spanish")]
pub struct Model { }

// Uses Spanish stemming for fulltext search</code></pre>
<h2 id="field-level-attributes"><a class="header" href="#field-level-attributes">Field-Level Attributes</a></h2>
<p>Applied to individual fields:</p>
<h3 id="primary_key"><a class="header" href="#primary_key"><code>primary_key</code></a></h3>
<p>Marks the primary key field:</p>
<pre><code class="language-rust">#[crudcrate(primary_key)]
pub id: i32,

// Required: exactly one field must have this</code></pre>
<h3 id="exclude"><a class="header" href="#exclude"><code>exclude(...)</code></a></h3>
<p>Exclude field from specific models:</p>
<pre><code class="language-rust">// Exclude from single model
#[crudcrate(exclude(create))]
pub id: i32,

// Exclude from multiple models
#[crudcrate(exclude(one, list))]
pub password: String,

// Available targets:
// - one: Response model (GET /items/:id)
// - create: Create model (POST /items)
// - update: Update model (PUT /items/:id)
// - list: List model (GET /items)</code></pre>
<h3 id="filterable"><a class="header" href="#filterable"><code>filterable</code></a></h3>
<p>Enable filtering on this field:</p>
<pre><code class="language-rust">#[crudcrate(filterable)]
pub status: String,

// Allows: GET /items?filter={"status":"active"}
// Allows: GET /items?status_eq=active
// Allows: GET /items?status_ne=inactive</code></pre>
<h3 id="sortable"><a class="header" href="#sortable"><code>sortable</code></a></h3>
<p>Enable sorting on this field:</p>
<pre><code class="language-rust">#[crudcrate(sortable)]
pub created_at: DateTimeUtc,

// Allows: GET /items?sort=["created_at","DESC"]
// Allows: GET /items?sort=created_at&amp;order=desc</code></pre>
<h3 id="fulltext"><a class="header" href="#fulltext"><code>fulltext</code></a></h3>
<p>Include in fulltext search:</p>
<pre><code class="language-rust">#[crudcrate(fulltext)]
pub title: String,

#[crudcrate(fulltext)]
pub description: String,

// Allows: GET /items?q=search terms
// Searches across all fulltext fields</code></pre>
<h3 id="on_create"><a class="header" href="#on_create"><code>on_create</code></a></h3>
<p>Default value when creating:</p>
<pre><code class="language-rust">#[crudcrate(on_create = Uuid::new_v4())]
pub id: Uuid,

#[crudcrate(on_create = chrono::Utc::now())]
pub created_at: DateTimeUtc,

#[crudcrate(on_create = "pending".to_string())]
pub status: String,

// Expression is evaluated at insert time</code></pre>
<h3 id="on_update"><a class="header" href="#on_update"><code>on_update</code></a></h3>
<p>Default value when updating:</p>
<pre><code class="language-rust">#[crudcrate(on_update = chrono::Utc::now())]
pub updated_at: DateTimeUtc,

// Expression is evaluated on every update</code></pre>
<h3 id="non_db_attr"><a class="header" href="#non_db_attr"><code>non_db_attr</code></a></h3>
<p>Marks non-database fields (for relationships):</p>
<pre><code class="language-rust">#[sea_orm(ignore)]  // Sea-ORM: ignore in queries
#[crudcrate(non_db_attr)]  // CRUDCrate: not a DB column
pub related_items: Vec&lt;Item&gt;,</code></pre>
<h3 id="join"><a class="header" href="#join"><code>join(...)</code></a></h3>
<p>Configure relationship loading:</p>
<pre><code class="language-rust">// Load in get_one only
#[crudcrate(non_db_attr, join(one))]
pub comments: Vec&lt;Comment&gt;,

// Load in both get_one and get_all
#[crudcrate(non_db_attr, join(one, all))]
pub author: Option&lt;User&gt;,

// Limit recursion depth
#[crudcrate(non_db_attr, join(one, all, depth = 2))]
pub nested: Vec&lt;Nested&gt;,

// Full syntax
join(
    one,          // Include in get_one response
    all,          // Include in get_all response
    depth = 3,    // Max recursion depth (default: unlimited up to 5)
)</code></pre>
<h2 id="lifecycle-hooks"><a class="header" href="#lifecycle-hooks">Lifecycle Hooks</a></h2>
<p>Hook into CRUD operations:</p>
<pre><code class="language-rust">#[crudcrate(
    // Pre-operation hooks (before DB operation)
    create::one::pre = validate_create,
    update::one::pre = validate_update,
    delete::one::pre = check_delete_permission,

    // Post-operation hooks (after DB operation)
    create::one::post = send_welcome_email,
    update::one::post = invalidate_cache,
    delete::one::post = cleanup_related,

    // Full body replacement
    create::one::body = custom_create_handler,
)]
pub struct Model { }

// Hook function signatures:
async fn validate_create(db: &amp;DatabaseConnection, data: &amp;mut ModelCreate) -&gt; Result&lt;(), ApiError&gt;;
async fn send_welcome_email(db: &amp;DatabaseConnection, created: &amp;Model) -&gt; Result&lt;(), ApiError&gt;;
async fn custom_create_handler(db: &amp;DatabaseConnection, data: ModelCreate) -&gt; Result&lt;Model, ApiError&gt;;</code></pre>
<h2 id="combining-attributes"><a class="header" href="#combining-attributes">Combining Attributes</a></h2>
<p>Multiple attributes on one field:</p>
<pre><code class="language-rust">#[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
pub id: Uuid,

#[crudcrate(filterable, sortable, fulltext)]
pub title: String,

#[crudcrate(non_db_attr, join(one, all, depth = 1))]
pub author: Option&lt;User&gt;,</code></pre>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre><code class="language-rust">use crudcrate::EntityToModels;
use sea_orm::entity::prelude::*;

#[derive(Clone, Debug, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(
    generate_router,
    api_struct = "Article",
    name_singular = "article",
    name_plural = "articles",
    operations = ArticleOperations,
    create::one::post = notify_subscribers,
)]
#[sea_orm(table_name = "articles")]
pub struct Model {
    // Primary key with auto-generation
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    // Searchable, filterable, sortable title
    #[crudcrate(filterable, sortable, fulltext)]
    pub title: String,

    // Searchable content, excluded from lists
    #[crudcrate(fulltext, exclude(list))]
    pub content: String,

    // Short summary for lists
    pub summary: Option&lt;String&gt;,

    // Filterable status enum
    #[crudcrate(filterable)]
    pub status: ArticleStatus,

    // Author relationship
    #[crudcrate(filterable)]
    pub author_id: Uuid,

    // Sortable publication date
    #[crudcrate(sortable, filterable)]
    pub published_at: Option&lt;DateTimeUtc&gt;,

    // Auto-managed timestamps
    #[crudcrate(sortable, exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTimeUtc,

    #[crudcrate(exclude(create, update), on_create = chrono::Utc::now(), on_update = chrono::Utc::now())]
    pub updated_at: DateTimeUtc,

    // Loaded relationships
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one))]
    pub author: Option&lt;User&gt;,

    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one))]
    pub comments: Vec&lt;Comment&gt;,
}</code></pre>
<h2 id="attribute-reference-table"><a class="header" href="#attribute-reference-table">Attribute Reference Table</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Level</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>generate_router</code></td><td>Struct</td><td>Generate Axum router</td></tr>
<tr><td><code>api_struct</code></td><td>Struct</td><td>Custom struct name</td></tr>
<tr><td><code>name_singular</code></td><td>Struct</td><td>Singular resource name</td></tr>
<tr><td><code>name_plural</code></td><td>Struct</td><td>Plural resource name</td></tr>
<tr><td><code>operations</code></td><td>Struct</td><td>Custom operations trait</td></tr>
<tr><td><code>description</code></td><td>Struct</td><td>OpenAPI description</td></tr>
<tr><td><code>fulltext_language</code></td><td>Struct</td><td>Fulltext search language</td></tr>
<tr><td><code>primary_key</code></td><td>Field</td><td>Mark as primary key</td></tr>
<tr><td><code>exclude(...)</code></td><td>Field</td><td>Exclude from models</td></tr>
<tr><td><code>filterable</code></td><td>Field</td><td>Enable filtering</td></tr>
<tr><td><code>sortable</code></td><td>Field</td><td>Enable sorting</td></tr>
<tr><td><code>fulltext</code></td><td>Field</td><td>Include in fulltext search</td></tr>
<tr><td><code>on_create</code></td><td>Field</td><td>Default value on create</td></tr>
<tr><td><code>on_update</code></td><td>Field</td><td>Default value on update</td></tr>
<tr><td><code>non_db_attr</code></td><td>Field</td><td>Non-database field</td></tr>
<tr><td><code>join(...)</code></td><td>Field</td><td>Relationship loading config</td></tr>
</tbody>
</table>
</div>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<ul>
<li>Learn about <a href="#filtering">Filtering</a></li>
<li>Configure <a href="#relationships--joins">Relationships</a></li>
<li>Implement <a href="#custom-operations">Custom Operations</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="filtering"><a class="header" href="#filtering">Filtering</a></h1>
<p>CRUDCrate provides powerful, type-safe filtering through JSON query parameters.</p>
<h2 id="enabling-filtering"><a class="header" href="#enabling-filtering">Enabling Filtering</a></h2>
<p>Mark fields as filterable:</p>
<pre><code class="language-rust">#[derive(EntityToModels)]
pub struct Model {
    #[crudcrate(filterable)]
    pub status: String,

    #[crudcrate(filterable)]
    pub priority: i32,

    #[crudcrate(filterable)]
    pub created_at: DateTimeUtc,

    // Not filterable
    pub description: String,
}</code></pre>
<h2 id="filter-syntax"><a class="header" href="#filter-syntax">Filter Syntax</a></h2>
<h3 id="json-filter-format-react-admin-compatible"><a class="header" href="#json-filter-format-react-admin-compatible">JSON Filter Format (React Admin Compatible)</a></h3>
<p>All filtering uses the JSON <code>filter</code> query parameter:</p>
<pre><code class="language-bash"># Exact match
GET /items?filter={"status":"active"}

# Multiple conditions (AND)
GET /items?filter={"status":"active","priority":5}

# Null check
GET /items?filter={"deleted_at":null}

# Array for IN queries
GET /items?filter={"status":["active","pending","review"]}
</code></pre>
<h3 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h3>
<p>Use field name suffixes within the JSON filter for comparisons:</p>
<pre><code class="language-bash"># Not equals
GET /items?filter={"status_neq":"inactive"}

# Greater than
GET /items?filter={"priority_gt":3}

# Greater than or equal
GET /items?filter={"priority_gte":3}

# Less than
GET /items?filter={"priority_lt":10}

# Less than or equal
GET /items?filter={"priority_lte":10}
</code></pre>
<h2 id="supported-operators"><a class="header" href="#supported-operators">Supported Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>SQL</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>(none)</td><td><code>=</code></td><td><code>{"status":"active"}</code></td></tr>
<tr><td><code>_neq</code></td><td><code>!=</code></td><td><code>{"status_neq":"deleted"}</code></td></tr>
<tr><td><code>_gt</code></td><td><code>&gt;</code></td><td><code>{"priority_gt":5}</code></td></tr>
<tr><td><code>_gte</code></td><td><code>&gt;=</code></td><td><code>{"priority_gte":5}</code></td></tr>
<tr><td><code>_lt</code></td><td><code>&lt;</code></td><td><code>{"priority_lt":10}</code></td></tr>
<tr><td><code>_lte</code></td><td><code>&lt;=</code></td><td><code>{"priority_lte":10}</code></td></tr>
<tr><td>(array)</td><td><code>IN</code></td><td><code>{"status":["a","b","c"]}</code></td></tr>
</tbody>
</table>
</div>
<h2 id="type-specific-filtering"><a class="header" href="#type-specific-filtering">Type-Specific Filtering</a></h2>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<pre><code class="language-bash"># Exact match (case-insensitive)
GET /items?filter={"name":"John"}

# Multiple values (IN)
GET /items?filter={"status":["active","pending"]}
</code></pre>
<h3 id="numbers"><a class="header" href="#numbers">Numbers</a></h3>
<pre><code class="language-bash"># Exact
GET /items?filter={"quantity":10}

# Range (combine multiple operators)
GET /items?filter={"quantity_gte":5,"quantity_lte":20}

# Comparison
GET /items?filter={"price_gt":100}
</code></pre>
<h3 id="booleans"><a class="header" href="#booleans">Booleans</a></h3>
<pre><code class="language-bash"># Exact match
GET /items?filter={"active":true}
GET /items?filter={"active":false}
</code></pre>
<h3 id="dates"><a class="header" href="#dates">Dates</a></h3>
<pre><code class="language-bash"># Exact date
GET /items?filter={"created_at":"2024-01-15"}

# Date range
GET /items?filter={"created_at_gte":"2024-01-01","created_at_lte":"2024-12-31"}

# ISO 8601 format
GET /items?filter={"created_at_gte":"2024-01-15T10:30:00Z"}
</code></pre>
<h3 id="enums-1"><a class="header" href="#enums-1">Enums</a></h3>
<pre><code class="language-rust">#[derive(EnumIter, DeriveActiveEnum)]
pub enum Status {
    #[sea_orm(string_value = "pending")]
    Pending,
    #[sea_orm(string_value = "active")]
    Active,
}

// In entity
#[crudcrate(filterable)]
pub status: Status,</code></pre>
<pre><code class="language-bash"># Filter by enum value (use the string_value)
GET /items?filter={"status":"active"}
GET /items?filter={"status":["pending","active"]}
</code></pre>
<h3 id="uuids"><a class="header" href="#uuids">UUIDs</a></h3>
<pre><code class="language-bash"># Exact match
GET /items?filter={"user_id":"550e8400-e29b-41d4-a716-446655440000"}

# Multiple UUIDs
GET /items?filter={"user_id":["uuid1","uuid2","uuid3"]}
</code></pre>
<h3 id="optional-fields-null-checks"><a class="header" href="#optional-fields-null-checks">Optional Fields (Null Checks)</a></h3>
<pre><code class="language-bash"># Field is null
GET /items?filter={"deleted_at":null}
</code></pre>
<blockquote>
<p><strong>Note</strong>: Checking for “not null” requires custom filtering logic via lifecycle hooks.</p>
</blockquote>
<h2 id="complex-filters"><a class="header" href="#complex-filters">Complex Filters</a></h2>
<h3 id="combining-conditions"><a class="header" href="#combining-conditions">Combining Conditions</a></h3>
<p>All conditions in the JSON filter are combined with AND:</p>
<pre><code class="language-bash"># status = "active" AND priority &gt;= 5
GET /items?filter={"status":"active","priority_gte":5}
</code></pre>
<h2 id="security"><a class="header" href="#security">Security</a></h2>
<h3 id="sql-injection-prevention"><a class="header" href="#sql-injection-prevention">SQL Injection Prevention</a></h3>
<p>All filters are parameterized. User input is never interpolated into SQL:</p>
<pre><code class="language-rust">// User provides: {"name": "'; DROP TABLE users; --"}

// CRUDCrate generates parameterized query:
// SELECT * FROM items WHERE name = $1
// With parameter: "'; DROP TABLE users; --"

// Safe! The value is treated as data, not SQL</code></pre>
<h3 id="field-validation"><a class="header" href="#field-validation">Field Validation</a></h3>
<p>Only fields marked <code>filterable</code> can be filtered:</p>
<pre><code class="language-rust">#[crudcrate(filterable)]
pub status: String,  // Allowed

pub secret: String,  // Not filterable - filter will be ignored</code></pre>
<p>For security, unknown or non-filterable fields are silently ignored rather than causing errors. This prevents information disclosure about your schema.</p>
<h2 id="programmatic-filtering"><a class="header" href="#programmatic-filtering">Programmatic Filtering</a></h2>
<p>Use filters directly in code:</p>
<pre><code class="language-rust">use crudcrate::filtering::{apply_filters, FilterOptions};
use sea_orm::Condition;

async fn custom_handler(
    Query(params): Query&lt;FilterOptions&gt;,
    Extension(db): Extension&lt;DatabaseConnection&gt;,
) -&gt; Result&lt;Json&lt;Vec&lt;Item&gt;&gt;, ApiError&gt; {
    // Build condition from query params
    let condition = apply_filters::&lt;Entity&gt;(&amp;params)?;

    // Add additional conditions
    let condition = condition.add(Column::Deleted.eq(false));

    // Use with Sea-ORM
    let items = Entity::find()
        .filter(condition)
        .all(&amp;db)
        .await?;

    Ok(Json(items.into_iter().map(Into::into).collect()))
}</code></pre>
<h3 id="building-conditions-manually"><a class="header" href="#building-conditions-manually">Building Conditions Manually</a></h3>
<pre><code class="language-rust">use sea_orm::Condition;

let condition = Condition::all()
    .add(Column::Status.eq("active"))
    .add(Column::Priority.gte(5))
    .add(Column::DeletedAt.is_null());

let items = Entity::find()
    .filter(condition)
    .all(&amp;db)
    .await?;</code></pre>
<h2 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h2>
<h3 id="index-your-filtered-fields"><a class="header" href="#index-your-filtered-fields">Index Your Filtered Fields</a></h3>
<pre><code class="language-sql">-- PostgreSQL
CREATE INDEX idx_items_status ON items(status);
CREATE INDEX idx_items_created_at ON items(created_at);

-- Composite index for common filter combinations
CREATE INDEX idx_items_status_priority ON items(status, priority);
</code></pre>
<h3 id="limit-filter-complexity"><a class="header" href="#limit-filter-complexity">Limit Filter Complexity</a></h3>
<p>Complex filters can impact performance. Consider:</p>
<ol>
<li><strong>Pagination</strong>: Always paginate filtered results</li>
<li><strong>Indexes</strong>: Index frequently filtered columns</li>
<li><strong>Caching</strong>: Cache common filter results</li>
<li><strong>Limits</strong>: Set maximum result limits</li>
</ol>
<h2 id="filtering-on-related-entities-join-filtering"><a class="header" href="#filtering-on-related-entities-join-filtering">Filtering on Related Entities (Join Filtering)</a></h2>
<p>CRUDCrate supports filtering on columns from related entities using dot-notation syntax. This lets you filter parent entities based on properties of their children.</p>
<h3 id="enabling-join-filtering"><a class="header" href="#enabling-join-filtering">Enabling Join Filtering</a></h3>
<p>Use the <code>filterable(...)</code> parameter inside <code>join(...)</code> to specify which columns from a related entity can be used for filtering:</p>
<pre><code class="language-rust">#[derive(EntityToModels)]
pub struct Model {
    #[sea_orm(primary_key)]
    #[crudcrate(primary_key)]
    pub id: Uuid,

    #[crudcrate(filterable, sortable)]
    pub name: String,

    // Vehicles relationship with filterable columns
    #[sea_orm(ignore)]
    #[crudcrate(
        non_db_attr,
        join(one, all, depth = 1, filterable("make", "year", "color"))
    )]
    pub vehicles: Vec&lt;Vehicle&gt;,
}</code></pre>
<h3 id="dot-notation-syntax"><a class="header" href="#dot-notation-syntax">Dot-Notation Syntax</a></h3>
<p>Filter using <code>relation.column</code> format:</p>
<pre><code class="language-bash"># Filter customers by vehicle make
GET /customers?filter={"vehicles.make":"BMW"}

# Filter with comparison operators
GET /customers?filter={"vehicles.year_gte":2020}

# Multiple join filters
GET /customers?filter={"vehicles.make":"Toyota","vehicles.year_gte":2018}

# Combine with main entity filters
GET /customers?filter={"name":"John","vehicles.color":"Black"}
</code></pre>
<h3 id="supported-operators-1"><a class="header" href="#supported-operators-1">Supported Operators</a></h3>
<p>All standard operators work with dot-notation:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>(none)</td><td><code>{"vehicles.make":"BMW"}</code></td></tr>
<tr><td><code>_neq</code></td><td><code>{"vehicles.color_neq":"Red"}</code></td></tr>
<tr><td><code>_gt</code></td><td><code>{"vehicles.year_gt":2019}</code></td></tr>
<tr><td><code>_gte</code></td><td><code>{"vehicles.year_gte":2020}</code></td></tr>
<tr><td><code>_lt</code></td><td><code>{"vehicles.mileage_lt":50000}</code></td></tr>
<tr><td><code>_lte</code></td><td><code>{"vehicles.mileage_lte":100000}</code></td></tr>
</tbody>
</table>
</div>
<h3 id="security-whitelist-validation"><a class="header" href="#security-whitelist-validation">Security (Whitelist Validation)</a></h3>
<p>Only columns explicitly listed in <code>filterable(...)</code> can be filtered:</p>
<pre><code class="language-rust">// Only make, year, and color can be filtered
#[crudcrate(join(one, all, filterable("make", "year", "color")))]
pub vehicles: Vec&lt;Vehicle&gt;,</code></pre>
<pre><code class="language-bash"># ✅ Allowed - year is in filterable
GET /customers?filter={"vehicles.year":2020}

# ❌ Ignored - model is NOT in filterable
GET /customers?filter={"vehicles.model":"Civic"}

# ❌ Ignored - invalid join field
GET /customers?filter={"fake.column":"value"}
</code></pre>
<p>This prevents:</p>
<ul>
<li>SQL injection via dot-notation</li>
<li>Access to sensitive columns not intended for filtering</li>
<li>Schema discovery through filter probing</li>
</ul>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p><strong>Single-level joins only</strong>: Join filtering supports direct relationships only. Nested paths like <code>vehicles.parts.name</code> are not supported—only single-level paths like <code>vehicles.make</code>.</p>
<pre><code class="language-bash"># ✅ Supported - single level
GET /customers?filter={"vehicles.make":"BMW"}

# ❌ Not supported - nested path
GET /customers?filter={"vehicles.parts.name":"Engine"}
</code></pre>
<h3 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h3>
<p>Join filtering is validated and parsed automatically. The parsed filters are available in the handler for custom implementation via lifecycle hooks. For basic use cases, filters on the main entity work immediately.</p>
<blockquote>
<p><strong>Note</strong>: Full automatic query execution for join filters requires a custom <code>read::many::body</code> hook. The built-in handler validates and parses join filters but uses only the main entity condition.</p>
</blockquote>
<h2 id="like-filterable-fields-partial-matching"><a class="header" href="#like-filterable-fields-partial-matching">LIKE-Filterable Fields (Partial Matching)</a></h2>
<p>For fields that need partial/substring matching instead of exact equality, implement <code>like_filterable_columns()</code> in your <code>CRUDResource</code> trait:</p>
<pre><code class="language-rust">impl CRUDResource for YourEntity {
    // ... other methods ...

    fn like_filterable_columns() -&gt; Vec&lt;&amp;'static str&gt; {
        vec!["title", "description", "name"]
    }
}</code></pre>
<p>When a field is in this list, filters will use case-insensitive <code>LIKE '%value%'</code> matching:</p>
<pre><code class="language-bash"># With title in like_filterable_columns():
GET /items?filter={"title":"urgent"}
# Matches: "This is urgent", "URGENT: Please review", "Not so urgent task"
</code></pre>
<p>This is useful for fields where users expect partial matching behavior.</p>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>CRUDCrate handles invalid filters gracefully:</p>
<ul>
<li><strong>Invalid JSON</strong>: Returns all results (filter is ignored)</li>
<li><strong>Unknown fields</strong>: Silently ignored for security</li>
<li><strong>Invalid values</strong>: Field filter is skipped</li>
<li><strong>Malformed operators</strong>: Falls back to equality check</li>
</ul>
<p>This defensive approach prevents information disclosure about your schema while maintaining API stability.</p>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<ul>
<li>Learn about <a href="#sorting">Sorting</a></li>
<li>Configure <a href="#pagination-1">Pagination</a></li>
<li>Enable <a href="#fulltext-search">Fulltext Search</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sorting"><a class="header" href="#sorting">Sorting</a></h1>
<p>CRUDCrate supports flexible sorting with multiple format options.</p>
<h2 id="enabling-sorting"><a class="header" href="#enabling-sorting">Enabling Sorting</a></h2>
<p>Mark fields as sortable:</p>
<pre><code class="language-rust">#[derive(EntityToModels)]
pub struct Model {
    #[crudcrate(sortable)]
    pub name: String,

    #[crudcrate(sortable)]
    pub created_at: DateTimeUtc,

    #[crudcrate(sortable)]
    pub priority: i32,

    // Not sortable
    pub description: String,
}</code></pre>
<h2 id="sort-syntax"><a class="header" href="#sort-syntax">Sort Syntax</a></h2>
<h3 id="json-array-format-react-admin"><a class="header" href="#json-array-format-react-admin">JSON Array Format (React Admin)</a></h3>
<pre><code class="language-bash"># Sort by single field with direction
GET /items?sort=["created_at","DESC"]

# Default order is ASC when direction omitted
GET /items?sort=["name"]
</code></pre>
<h3 id="rest-query-parameters"><a class="header" href="#rest-query-parameters">REST Query Parameters</a></h3>
<p>Two REST-style formats are supported:</p>
<pre><code class="language-bash"># Using sort_by + order (preferred)
GET /items?sort_by=created_at&amp;order=DESC

# Using sort + order (alternative)
GET /items?sort=created_at&amp;order=DESC

# Default order is ASC
GET /items?sort_by=name
</code></pre>
<blockquote>
<p><strong>Note</strong>: The <code>sort_by</code> parameter takes priority over <code>sort</code> if both are provided.</p>
</blockquote>
<h2 id="sort-directions"><a class="header" href="#sort-directions">Sort Directions</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Direction</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>ASC</code></td><td>Ascending (A-Z, 0-9, oldest first)</td></tr>
<tr><td><code>DESC</code></td><td>Descending (Z-A, 9-0, newest first)</td></tr>
</tbody>
</table>
</div>
<p>Case-insensitive: <code>ASC</code>, <code>asc</code>, <code>Asc</code> all work.</p>
<h2 id="examples-by-type"><a class="header" href="#examples-by-type">Examples by Type</a></h2>
<h3 id="strings-1"><a class="header" href="#strings-1">Strings</a></h3>
<pre><code class="language-bash"># A to Z
GET /items?sort=["name","ASC"]

# Z to A
GET /items?sort=["name","DESC"]
</code></pre>
<h3 id="numbers-1"><a class="header" href="#numbers-1">Numbers</a></h3>
<pre><code class="language-bash"># Lowest to highest
GET /items?sort=["priority","ASC"]

# Highest to lowest
GET /items?sort=["priority","DESC"]
</code></pre>
<h3 id="dates-1"><a class="header" href="#dates-1">Dates</a></h3>
<pre><code class="language-bash"># Oldest first
GET /items?sort=["created_at","ASC"]

# Newest first (common for feeds)
GET /items?sort=["created_at","DESC"]
</code></pre>
<h3 id="booleans-1"><a class="header" href="#booleans-1">Booleans</a></h3>
<pre><code class="language-bash"># false first (0), then true (1)
GET /items?sort=["is_active","ASC"]

# true first (1), then false (0)
GET /items?sort=["is_active","DESC"]
</code></pre>
<h2 id="default-sort-order"><a class="header" href="#default-sort-order">Default Sort Order</a></h2>
<p>When no sort is specified, CRUDCrate uses the primary key:</p>
<pre><code class="language-rust">// Default: ORDER BY id ASC
GET /items</code></pre>
<p>Configure a different default in your handler or operations.</p>
<h2 id="multiple-column-sorting"><a class="header" href="#multiple-column-sorting">Multiple Column Sorting</a></h2>
<p>For multi-column sorting, implement a custom handler:</p>
<pre><code class="language-rust">use sea_orm::{Order, QueryOrder};

async fn list_items(
    Query(params): Query&lt;FilterOptions&gt;,
    Extension(db): Extension&lt;DatabaseConnection&gt;,
) -&gt; Result&lt;Json&lt;Vec&lt;ItemList&gt;&gt;, ApiError&gt; {
    let query = Entity::find()
        .order_by(Column::Priority, Order::Desc)  // Primary sort
        .order_by(Column::CreatedAt, Order::Desc); // Secondary sort

    let items = query.all(&amp;db).await?;
    Ok(Json(items.into_iter().map(Into::into).collect()))
}</code></pre>
<h2 id="null-handling"><a class="header" href="#null-handling">Null Handling</a></h2>
<p>Null values sort based on database:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Database</th><th>NULL Position</th></tr>
</thead>
<tbody>
<tr><td>PostgreSQL</td><td>NULLS LAST (default)</td></tr>
<tr><td>MySQL</td><td>NULLS FIRST (in ASC)</td></tr>
<tr><td>SQLite</td><td>NULLS FIRST</td></tr>
</tbody>
</table>
</div>
<p>For consistent behavior, consider using <code>COALESCE</code> in custom queries.</p>
<h2 id="programmatic-sorting"><a class="header" href="#programmatic-sorting">Programmatic Sorting</a></h2>
<p>Use sorting in code:</p>
<pre><code class="language-rust">use crudcrate::filtering::{parse_sorting, FilterOptions};
use sea_orm::{Order, QueryOrder};

async fn custom_list(
    Query(params): Query&lt;FilterOptions&gt;,
    Extension(db): Extension&lt;DatabaseConnection&gt;,
) -&gt; Result&lt;Json&lt;Vec&lt;Item&gt;&gt;, ApiError&gt; {
    let (column, order) = parse_sorting::&lt;Entity&gt;(&amp;params);

    let items = Entity::find()
        .order_by(column, order)
        .all(&amp;db)
        .await?;

    Ok(Json(items.into_iter().map(Into::into).collect()))
}</code></pre>
<h3 id="manual-sorting"><a class="header" href="#manual-sorting">Manual Sorting</a></h3>
<pre><code class="language-rust">use sea_orm::{Order, QueryOrder};

let items = Entity::find()
    .order_by(Column::Priority, Order::Desc)
    .order_by(Column::Name, Order::Asc)
    .all(&amp;db)
    .await?;</code></pre>
<h2 id="security-1"><a class="header" href="#security-1">Security</a></h2>
<h3 id="field-validation-1"><a class="header" href="#field-validation-1">Field Validation</a></h3>
<p>Only <code>sortable</code> fields can be used:</p>
<pre><code class="language-rust">#[crudcrate(sortable)]
pub name: String,  // Allowed

pub secret: String,  // Not sortable - ignored</code></pre>
<p>Invalid sort fields are silently ignored (falls back to default).</p>
<h3 id="no-sql-injection"><a class="header" href="#no-sql-injection">No SQL Injection</a></h3>
<p>Sort fields are validated against entity columns:</p>
<pre><code class="language-bash"># Attempted injection
GET /items?sort=["name; DROP TABLE items;--","ASC"]

# Result: field not found, uses default sort
# No SQL executed with injected content
</code></pre>
<h2 id="performance-tips-1"><a class="header" href="#performance-tips-1">Performance Tips</a></h2>
<h3 id="index-sorted-fields"><a class="header" href="#index-sorted-fields">Index Sorted Fields</a></h3>
<pre><code class="language-sql">-- Index for sorted field
CREATE INDEX idx_items_created_at ON items(created_at);

-- Composite index for filter + sort
CREATE INDEX idx_items_status_created
    ON items(status, created_at DESC);
</code></pre>
<h3 id="consider-sort--filter-combinations"><a class="header" href="#consider-sort--filter-combinations">Consider Sort + Filter Combinations</a></h3>
<p>The most efficient queries have indexes covering both filter and sort:</p>
<pre><code class="language-bash"># Common query pattern
GET /items?filter={"status":"active"}&amp;sort=["created_at","DESC"]
</code></pre>
<pre><code class="language-sql">-- Optimal index
CREATE INDEX idx_items_status_created
    ON items(status, created_at DESC);
</code></pre>
<h2 id="sorting-by-related-entity-columns-join-sorting"><a class="header" href="#sorting-by-related-entity-columns-join-sorting">Sorting by Related Entity Columns (Join Sorting)</a></h2>
<p>CRUDCrate supports sorting by columns from related entities using dot-notation syntax.</p>
<h3 id="enabling-join-sorting"><a class="header" href="#enabling-join-sorting">Enabling Join Sorting</a></h3>
<p>Use the <code>sortable(...)</code> parameter inside <code>join(...)</code> to specify which columns from a related entity can be used for sorting:</p>
<pre><code class="language-rust">#[derive(EntityToModels)]
pub struct Model {
    #[sea_orm(primary_key)]
    #[crudcrate(primary_key)]
    pub id: Uuid,

    #[crudcrate(filterable, sortable)]
    pub name: String,

    // Vehicles relationship with sortable columns
    #[sea_orm(ignore)]
    #[crudcrate(
        non_db_attr,
        join(one, all, depth = 1, sortable("year", "mileage"))
    )]
    pub vehicles: Vec&lt;Vehicle&gt;,
}</code></pre>
<h3 id="dot-notation-syntax-1"><a class="header" href="#dot-notation-syntax-1">Dot-Notation Syntax</a></h3>
<p>Sort using <code>relation.column</code> format:</p>
<pre><code class="language-bash"># Sort customers by their vehicle's year (newest first)
GET /customers?sort=["vehicles.year","DESC"]

# Sort by vehicle mileage (lowest first)
GET /customers?sort=["vehicles.mileage","ASC"]

# REST format also supported
GET /customers?sort_by=vehicles.year&amp;order=DESC
</code></pre>
<h3 id="combining-with-filtering"><a class="header" href="#combining-with-filtering">Combining with Filtering</a></h3>
<pre><code class="language-bash"># Filter by vehicle make, sort by vehicle year
GET /customers?filter={"vehicles.make":"BMW"}&amp;sort=["vehicles.year","DESC"]

# Filter by customer name, sort by vehicle mileage
GET /customers?filter={"name":"John"}&amp;sort=["vehicles.mileage","ASC"]
</code></pre>
<h3 id="security-whitelist-validation-1"><a class="header" href="#security-whitelist-validation-1">Security (Whitelist Validation)</a></h3>
<p>Only columns explicitly listed in <code>sortable(...)</code> can be sorted:</p>
<pre><code class="language-rust">// Only year and mileage can be sorted
#[crudcrate(join(one, all, sortable("year", "mileage")))]
pub vehicles: Vec&lt;Vehicle&gt;,</code></pre>
<pre><code class="language-bash"># ✅ Allowed - year is in sortable
GET /customers?sort=["vehicles.year","DESC"]

# ❌ Falls back to default - make is NOT in sortable
GET /customers?sort=["vehicles.make","ASC"]
</code></pre>
<p>Invalid sort fields silently fall back to the default sort column.</p>
<h3 id="combining-filterable-and-sortable"><a class="header" href="#combining-filterable-and-sortable">Combining Filterable and Sortable</a></h3>
<p>You can use both <code>filterable(...)</code> and <code>sortable(...)</code> together inside <code>join(...)</code>:</p>
<pre><code class="language-rust">#[sea_orm(ignore)]
#[crudcrate(
    non_db_attr,
    join(one, all, depth = 1, filterable("make", "year", "color"), sortable("year", "mileage"))
)]
pub vehicles: Vec&lt;Vehicle&gt;,</code></pre>
<h3 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h3>
<p><strong>Single-level joins only</strong>: Join sorting supports direct relationships only. Nested paths like <code>vehicles.parts.price</code> are not supported—only single-level paths like <code>vehicles.year</code>.</p>
<pre><code class="language-bash"># ✅ Supported - single level
GET /customers?sort=["vehicles.year","DESC"]

# ❌ Not supported - nested path
GET /customers?sort=["vehicles.parts.price","ASC"]
</code></pre>
<h3 id="implementation-notes-1"><a class="header" href="#implementation-notes-1">Implementation Notes</a></h3>
<p>Join sorting is validated and parsed automatically. Like join filtering, full automatic query execution for join sorts requires a custom <code>read::many::body</code> hook. The built-in handler validates and parses join sorts but falls back to the default sort column.</p>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="newest-first-default-for-lists"><a class="header" href="#newest-first-default-for-lists">Newest First (Default for Lists)</a></h3>
<pre><code class="language-rust">#[crudcrate(sortable, exclude(create, update))]
pub created_at: DateTimeUtc,</code></pre>
<pre><code class="language-bash">GET /items?sort=["created_at","DESC"]
</code></pre>
<h3 id="priority-queue"><a class="header" href="#priority-queue">Priority Queue</a></h3>
<pre><code class="language-rust">#[crudcrate(sortable, filterable)]
pub priority: i32,</code></pre>
<pre><code class="language-bash"># High priority first, then by date
GET /items?sort=["priority","DESC"]
</code></pre>
<h3 id="alphabetical-lists"><a class="header" href="#alphabetical-lists">Alphabetical Lists</a></h3>
<pre><code class="language-rust">#[crudcrate(sortable, fulltext)]
pub name: String,</code></pre>
<pre><code class="language-bash">GET /items?sort=["name","ASC"]
</code></pre>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>Invalid sort parameters don’t cause errors - they fall back to defaults:</p>
<pre><code class="language-bash"># Invalid field - falls back to default
GET /items?sort=["nonexistent","ASC"]

# Invalid format - falls back to default
GET /items?sort=not-an-array
</code></pre>
<p>This design prevents client errors from breaking functionality.</p>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<ul>
<li>Configure <a href="#pagination-1">Pagination</a></li>
<li>Enable <a href="#fulltext-search">Fulltext Search</a></li>
<li>Learn about <a href="#filtering">Filtering</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pagination-1"><a class="header" href="#pagination-1">Pagination</a></h1>
<p>CRUDCrate provides secure pagination with multiple format support.</p>
<h2 id="pagination-formats"><a class="header" href="#pagination-formats">Pagination Formats</a></h2>
<h3 id="react-admin-format-range"><a class="header" href="#react-admin-format-range">React Admin Format (Range)</a></h3>
<pre><code class="language-bash"># First 10 items (0-9)
GET /items?range=[0,9]

# Items 10-19
GET /items?range=[10,19]

# Items 50-74 (25 items)
GET /items?range=[50,74]
</code></pre>
<h3 id="standard-page-format"><a class="header" href="#standard-page-format">Standard Page Format</a></h3>
<pre><code class="language-bash"># Page 1 with 20 items per page
GET /items?page=1&amp;per_page=20

# Page 3 with 10 items per page
GET /items?page=3&amp;per_page=10
</code></pre>
<h2 id="response-headers"><a class="header" href="#response-headers">Response Headers</a></h2>
<p>CRUDCrate adds RFC 7233 compliant headers:</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Content-Range: items 0-9/42
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Header</th><th>Format</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Content-Range</code></td><td><code>{resource} {start}-{end}/{total}</code></td><td>Current range and total count</td></tr>
</tbody>
</table>
</div>
<h3 id="parsing-content-range"><a class="header" href="#parsing-content-range">Parsing Content-Range</a></h3>
<pre><code class="language-javascript">// JavaScript example
const contentRange = response.headers.get('Content-Range');
const match = contentRange.match(/(\w+) (\d+)-(\d+)\/(\d+)/);
const [_, resource, start, end, total] = match;

console.log(`Showing ${start}-${end} of ${total} ${resource}`);
// "Showing 0-9 of 42 items"
</code></pre>
<h2 id="security-limits"><a class="header" href="#security-limits">Security Limits</a></h2>
<p>CRUDCrate enforces limits to prevent abuse:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Limit</th><th>Value</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>Max page size</td><td>1,000</td><td>Prevent memory exhaustion</td></tr>
<tr><td>Max offset</td><td>1,000,000</td><td>Prevent excessive DB load</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-bash"># Requesting too many items
GET /items?per_page=10000

# Response: limited to 1000 items
Content-Range: items 0-999/5000
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="basic-pagination"><a class="header" href="#basic-pagination">Basic Pagination</a></h3>
<pre><code class="language-bash"># First page
GET /items?range=[0,19]
# Content-Range: items 0-19/150

# Second page
GET /items?range=[20,39]
# Content-Range: items 20-39/150

# Last page (partial)
GET /items?range=[140,159]
# Content-Range: items 140-149/150
</code></pre>
<h3 id="with-filtering"><a class="header" href="#with-filtering">With Filtering</a></h3>
<pre><code class="language-bash"># Filter + paginate
GET /items?filter={"status":"active"}&amp;range=[0,9]
# Content-Range: items 0-9/42  (42 active items total)
</code></pre>
<h3 id="with-sorting"><a class="header" href="#with-sorting">With Sorting</a></h3>
<pre><code class="language-bash"># Sort + paginate
GET /items?sort=["created_at","DESC"]&amp;range=[0,9]
# Returns newest 10 items
</code></pre>
<h3 id="combined"><a class="header" href="#combined">Combined</a></h3>
<pre><code class="language-bash"># Filter + sort + paginate
GET /items?filter={"status":"active"}&amp;sort=["priority","DESC"]&amp;range=[0,9]
# Returns top 10 highest priority active items
</code></pre>
<h2 id="programmatic-pagination"><a class="header" href="#programmatic-pagination">Programmatic Pagination</a></h2>
<h3 id="using-filteroptions"><a class="header" href="#using-filteroptions">Using FilterOptions</a></h3>
<pre><code class="language-rust">use crudcrate::filtering::{parse_pagination, FilterOptions};

async fn list_handler(
    Query(params): Query&lt;FilterOptions&gt;,
    Extension(db): Extension&lt;DatabaseConnection&gt;,
) -&gt; Result&lt;(HeaderMap, Json&lt;Vec&lt;ItemList&gt;&gt;), ApiError&gt; {
    // Parse pagination from query params
    let (offset, limit) = parse_pagination(&amp;params);

    let items = Entity::find()
        .offset(offset)
        .limit(limit)
        .all(&amp;db)
        .await?;

    // Calculate Content-Range
    let total = Entity::find().count(&amp;db).await?;
    let end = (offset + items.len() as u64).saturating_sub(1);

    let mut headers = HeaderMap::new();
    headers.insert(
        "Content-Range",
        format!("items {}-{}/{}", offset, end, total).parse().unwrap()
    );

    Ok((headers, Json(items.into_iter().map(Into::into).collect())))
}</code></pre>
<h3 id="manual-pagination"><a class="header" href="#manual-pagination">Manual Pagination</a></h3>
<pre><code class="language-rust">use sea_orm::QuerySelect;

// Direct offset/limit
let items = Entity::find()
    .offset(20)
    .limit(10)
    .all(&amp;db)
    .await?;</code></pre>
<h3 id="using-paginator"><a class="header" href="#using-paginator">Using Paginator</a></h3>
<pre><code class="language-rust">use sea_orm::PaginatorTrait;

// Sea-ORM's built-in paginator
let paginator = Entity::find()
    .filter(condition)
    .paginate(&amp;db, 20);  // 20 items per page

// Get specific page
let items = paginator.fetch_page(2).await?;  // Page 2 (0-indexed)

// Get total count
let total = paginator.num_items().await?;
let pages = paginator.num_pages().await?;</code></pre>
<h2 id="offset-vs-cursor-pagination"><a class="header" href="#offset-vs-cursor-pagination">Offset vs Cursor Pagination</a></h2>
<p>CRUDCrate uses offset pagination by default. For large datasets, consider cursor pagination:</p>
<h3 id="offset-pagination-default"><a class="header" href="#offset-pagination-default">Offset Pagination (Default)</a></h3>
<ul>
<li>✅ Simple to implement</li>
<li>✅ Random page access</li>
<li>❌ Inconsistent with concurrent writes</li>
<li>❌ Slow for large offsets</li>
</ul>
<h3 id="cursor-pagination-custom-implementation"><a class="header" href="#cursor-pagination-custom-implementation">Cursor Pagination (Custom Implementation)</a></h3>
<ul>
<li>✅ Consistent with concurrent writes</li>
<li>✅ Fast for any position</li>
<li>❌ No random page access</li>
<li>❌ Requires ordered, unique field</li>
</ul>
<p>Example cursor pagination:</p>
<pre><code class="language-rust">async fn list_with_cursor(
    Query(params): Query&lt;CursorParams&gt;,
    Extension(db): Extension&lt;DatabaseConnection&gt;,
) -&gt; Result&lt;Json&lt;CursorResponse&lt;Item&gt;&gt;, ApiError&gt; {
    let limit = params.limit.unwrap_or(20).min(100);

    let mut query = Entity::find()
        .order_by(Column::CreatedAt, Order::Desc);

    // If cursor provided, filter to items after cursor
    if let Some(cursor) = &amp;params.cursor {
        let cursor_time = parse_cursor(cursor)?;
        query = query.filter(Column::CreatedAt.lt(cursor_time));
    }

    let items: Vec&lt;Model&gt; = query
        .limit(limit + 1)  // Fetch one extra to check for more
        .all(&amp;db)
        .await?;

    let has_more = items.len() &gt; limit as usize;
    let items: Vec&lt;Item&gt; = items.into_iter()
        .take(limit as usize)
        .map(Into::into)
        .collect();

    let next_cursor = if has_more {
        items.last().map(|i| encode_cursor(&amp;i.created_at))
    } else {
        None
    };

    Ok(Json(CursorResponse {
        items,
        next_cursor,
    }))
}</code></pre>
<h2 id="performance-tips-2"><a class="header" href="#performance-tips-2">Performance Tips</a></h2>
<h3 id="for-large-tables"><a class="header" href="#for-large-tables">For Large Tables</a></h3>
<pre><code class="language-sql">-- Ensure indexes on sorted columns
CREATE INDEX idx_items_created_at ON items(created_at DESC);

-- For filtered + sorted pagination
CREATE INDEX idx_items_status_created
    ON items(status, created_at DESC);
</code></pre>
<h3 id="total-count-optimization"><a class="header" href="#total-count-optimization">Total Count Optimization</a></h3>
<p>Counting can be slow on large tables:</p>
<pre><code class="language-rust">// Option 1: Cached counts
let total = get_cached_count_or_query(&amp;db).await?;

// Option 2: Approximate counts (PostgreSQL)
// SELECT reltuples FROM pg_class WHERE relname = 'items';

// Option 3: Skip count for infinite scroll
let items = Entity::find()
    .limit(limit + 1)  // Fetch extra to detect more
    .all(&amp;db)
    .await?;
let has_more = items.len() &gt; limit;</code></pre>
<h2 id="empty-results"><a class="header" href="#empty-results">Empty Results</a></h2>
<p>When no items match:</p>
<pre><code class="language-bash">GET /items?filter={"status":"nonexistent"}&amp;range=[0,9]

# Response
HTTP/1.1 200 OK
Content-Range: items 0-0/0
[]
</code></pre>
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<ul>
<li>Learn about <a href="#fulltext-search">Fulltext Search</a></li>
<li>Configure <a href="#filtering">Filtering</a></li>
<li>Set up <a href="#sorting">Sorting</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fulltext-search"><a class="header" href="#fulltext-search">Fulltext Search</a></h1>
<p>CRUDCrate provides fulltext search across multiple fields with database-specific optimizations.</p>
<h2 id="enabling-fulltext-search"><a class="header" href="#enabling-fulltext-search">Enabling Fulltext Search</a></h2>
<p>Mark fields to include in search:</p>
<pre><code class="language-rust">#[derive(EntityToModels)]
pub struct Model {
    #[crudcrate(fulltext)]
    pub title: String,

    #[crudcrate(fulltext)]
    pub description: String,

    #[crudcrate(fulltext)]
    pub tags: String,

    // Not searchable
    pub internal_code: String,
}</code></pre>
<h2 id="search-syntax"><a class="header" href="#search-syntax">Search Syntax</a></h2>
<p>Use the <code>q</code> parameter:</p>
<pre><code class="language-bash"># Simple search
GET /items?q=rust programming

# Search with other parameters
GET /items?q=async&amp;filter={"status":"published"}&amp;sort=["created_at","DESC"]
</code></pre>
<h2 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h2>
<h3 id="postgresql-trigram-similarity"><a class="header" href="#postgresql-trigram-similarity">PostgreSQL (Trigram Similarity)</a></h3>
<p>Uses <code>ILIKE</code> combined with <code>pg_trgm</code> similarity for fuzzy matching:</p>
<pre><code class="language-sql">-- Generated query (simplified)
SELECT * FROM items
WHERE (
    UPPER(COALESCE(title::text, '') || ' ' || COALESCE(description::text, ''))
    LIKE UPPER('%rust programming%') ESCAPE '\'
    OR SIMILARITY(COALESCE(title::text, '') || ' ' || COALESCE(description::text, ''), 'rust programming') &gt; 0.1
)
</code></pre>
<p>This approach provides:</p>
<ul>
<li><strong>Substring matching</strong>: Finds “rust” inside “rusty” or “trusty”</li>
<li><strong>Fuzzy matching</strong>: Handles typos via trigram similarity</li>
<li><strong>Case insensitivity</strong>: Automatically case-insensitive</li>
</ul>
<p><strong>Setup for best performance:</strong></p>
<pre><code class="language-sql">-- Enable pg_trgm extension (required)
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Create trigram index for faster similarity searches
CREATE INDEX idx_items_title_trgm ON items USING gin (title gin_trgm_ops);
CREATE INDEX idx_items_description_trgm ON items USING gin (description gin_trgm_ops);
</code></pre>
<h3 id="mysql--sqlite-like-fallback"><a class="header" href="#mysql--sqlite-like-fallback">MySQL &amp; SQLite (LIKE Fallback)</a></h3>
<p>Uses case-insensitive LIKE queries:</p>
<pre><code class="language-sql">-- Generated query
SELECT * FROM items
WHERE UPPER(CAST(title AS TEXT) || ' ' || CAST(description AS TEXT))
    LIKE UPPER('%rust programming%') ESCAPE '\'
</code></pre>
<p>The query is treated as a single phrase, matching records where the concatenated fields contain the search string.</p>
<h2 id="search-behavior"><a class="header" href="#search-behavior">Search Behavior</a></h2>
<h3 id="single-phrase-search"><a class="header" href="#single-phrase-search">Single Phrase Search</a></h3>
<p>The entire query is treated as a single search term:</p>
<pre><code class="language-bash">GET /items?q=rust programming

# Matches items containing the phrase "rust programming"
# Does NOT split into separate "rust" AND "programming" terms
</code></pre>
<h3 id="case-insensitivity"><a class="header" href="#case-insensitivity">Case Insensitivity</a></h3>
<p>All searches are case-insensitive:</p>
<pre><code class="language-bash">GET /items?q=RUST
GET /items?q=rust
GET /items?q=Rust

# All return the same results
</code></pre>
<h3 id="partial-matching-substring"><a class="header" href="#partial-matching-substring">Partial Matching (Substring)</a></h3>
<p>All databases support substring matching via LIKE:</p>
<pre><code class="language-bash">GET /items?q=rust

# Matches: "rust", "rusty", "trustworthy", "Rust Programming"
</code></pre>
<p>PostgreSQL additionally uses trigram similarity for fuzzy matching, which helps with:</p>
<ul>
<li>Typos (e.g., “progamming” may still find “programming”)</li>
<li>Similar words</li>
</ul>
<h2 id="combining-with-filters"><a class="header" href="#combining-with-filters">Combining with Filters</a></h2>
<p>Search works with other query parameters:</p>
<pre><code class="language-bash"># Search within active items
GET /items?q=tutorial&amp;filter={"status":"active"}

# Search + sort + paginate
GET /items?q=rust&amp;sort=["created_at","DESC"]&amp;range=[0,9]
</code></pre>
<h2 id="performance-tips-3"><a class="header" href="#performance-tips-3">Performance Tips</a></h2>
<h3 id="index-strategy"><a class="header" href="#index-strategy">Index Strategy</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Database</th><th>Recommended Index</th></tr>
</thead>
<tbody>
<tr><td>PostgreSQL</td><td>GIN with pg_trgm (see setup above)</td></tr>
<tr><td>MySQL</td><td>Standard B-tree on searched columns</td></tr>
<tr><td>SQLite</td><td>Standard indexes on searched columns</td></tr>
</tbody>
</table>
</div>
<h3 id="query-optimization"><a class="header" href="#query-optimization">Query Optimization</a></h3>
<ol>
<li><strong>Limit results</strong>: Always paginate search results</li>
<li><strong>Use filters</strong>: Narrow results before fulltext search</li>
<li><strong>Cache common searches</strong>: For popular queries</li>
</ol>
<h3 id="example-optimized-search"><a class="header" href="#example-optimized-search">Example: Optimized Search</a></h3>
<pre><code class="language-bash"># ❌ Slow: fulltext search on all items
GET /items?q=rust

# ✅ Fast: filter first, then search
GET /items?q=rust&amp;filter={"category":"programming"}&amp;range=[0,19]
</code></pre>
<h2 id="highlighting-results"><a class="header" href="#highlighting-results">Highlighting Results</a></h2>
<p>For search result highlighting, implement post-processing:</p>
<pre><code class="language-rust">fn highlight_matches(text: &amp;str, query: &amp;str) -&gt; String {
    let terms: Vec&lt;&amp;str&gt; = query.split_whitespace().collect();
    let mut result = text.to_string();

    for term in terms {
        let pattern = regex::Regex::new(&amp;format!("(?i)({})", regex::escape(term))).unwrap();
        result = pattern.replace_all(&amp;result, "&lt;mark&gt;$1&lt;/mark&gt;").to_string();
    }

    result
}</code></pre>
<h2 id="empty-search"><a class="header" href="#empty-search">Empty Search</a></h2>
<p>Empty or whitespace-only queries return all items:</p>
<pre><code class="language-bash">GET /items?q=
GET /items?q=

# Both return unfiltered results (with pagination)
</code></pre>
<h2 id="special-characters"><a class="header" href="#special-characters">Special Characters</a></h2>
<p>Search queries are sanitized:</p>
<pre><code class="language-bash"># Special characters are escaped
GET /items?q=c++
GET /items?q=node.js
GET /items?q=user@email

# All work safely
</code></pre>
<h2 id="next-steps-11"><a class="header" href="#next-steps-11">Next Steps</a></h2>
<ul>
<li>Configure <a href="#relationships--joins">Relationships</a></li>
<li>Learn about <a href="#filtering">Filtering</a></li>
<li>Set up <a href="#error-handling-3">Error Handling</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="relationships--joins"><a class="header" href="#relationships--joins">Relationships &amp; Joins</a></h1>
<p>CRUDCrate automatically loads related entities based on your configuration.</p>
<h2 id="defining-relationships"><a class="header" href="#defining-relationships">Defining Relationships</a></h2>
<h3 id="step-1-sea-orm-relation-definition"><a class="header" href="#step-1-sea-orm-relation-definition">Step 1: Sea-ORM Relation Definition</a></h3>
<pre><code class="language-rust">// In your entity file
#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    // Has Many: Post has many Comments
    #[sea_orm(has_many = "super::comment::Entity")]
    Comments,

    // Belongs To: Post belongs to User (author)
    #[sea_orm(
        belongs_to = "super::user::Entity",
        from = "Column::AuthorId",
        to = "super::user::Column::Id"
    )]
    Author,
}

// Implement Related trait for each relationship
impl Related&lt;super::comment::Entity&gt; for Entity {
    fn to() -&gt; RelationDef {
        Relation::Comments.def()
    }
}

impl Related&lt;super::user::Entity&gt; for Entity {
    fn to() -&gt; RelationDef {
        Relation::Author.def()
    }
}</code></pre>
<h3 id="step-2-add-join-fields-to-model"><a class="header" href="#step-2-add-join-fields-to-model">Step 2: Add Join Fields to Model</a></h3>
<pre><code class="language-rust">#[derive(EntityToModels)]
pub struct Model {
    #[sea_orm(primary_key)]
    #[crudcrate(primary_key)]
    pub id: i32,

    pub title: String,

    #[crudcrate(filterable)]
    pub author_id: i32,

    // Many relationship (Vec)
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one, all))]
    pub comments: Vec&lt;super::comment::Comment&gt;,

    // One relationship (Option)
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one))]
    pub author: Option&lt;super::user::User&gt;,
}</code></pre>
<h2 id="join-configuration"><a class="header" href="#join-configuration">Join Configuration</a></h2>
<h3 id="joinone"><a class="header" href="#joinone"><code>join(one)</code></a></h3>
<p>Load relationship only in <code>get_one</code> (single item) responses:</p>
<pre><code class="language-rust">#[crudcrate(non_db_attr, join(one))]
pub comments: Vec&lt;Comment&gt;,</code></pre>
<pre><code class="language-bash"># GET /posts/1 - Comments loaded
{
  "id": 1,
  "title": "Hello World",
  "comments": [
    {"id": 1, "content": "Great post!"},
    {"id": 2, "content": "Thanks!"}
  ]
}

# GET /posts - Comments NOT loaded
[
  {"id": 1, "title": "Hello World"},
  {"id": 2, "title": "Another Post"}
]
</code></pre>
<h3 id="joinall"><a class="header" href="#joinall"><code>join(all)</code></a></h3>
<p>Load relationship in both <code>get_one</code> and <code>get_all</code> responses:</p>
<pre><code class="language-rust">#[crudcrate(non_db_attr, join(one, all))]
pub author: Option&lt;User&gt;,</code></pre>
<pre><code class="language-bash"># GET /posts - Authors loaded in list
[
  {
    "id": 1,
    "title": "Hello World",
    "author": {"id": 5, "name": "Alice"}
  }
]
</code></pre>
<p><strong>Caution</strong>: Loading relationships in lists can be expensive. Use selectively.</p>
<h3 id="depth-parameter"><a class="header" href="#depth-parameter"><code>depth</code> Parameter</a></h3>
<p>Limit recursive loading depth:</p>
<pre><code class="language-rust">// Load Author, but don't load Author's Posts (which would load Posts' Authors, etc.)
#[crudcrate(non_db_attr, join(one, depth = 1))]
pub author: Option&lt;User&gt;,

// Allow 2 levels: Post → Comments → Author
#[crudcrate(non_db_attr, join(one, depth = 2))]
pub comments: Vec&lt;Comment&gt;,</code></pre>
<p><strong>Default</strong>: When not specified, recursion is limited to 5 levels for safety.</p>
<h3 id="join_filterable-and-join_sortable"><a class="header" href="#join_filterable-and-join_sortable"><code>join_filterable</code> and <code>join_sortable</code></a></h3>
<p>Enable filtering and sorting on columns from related entities:</p>
<pre><code class="language-rust">#[sea_orm(ignore)]
#[crudcrate(
    non_db_attr,
    join(one, all, depth = 1),
    join_filterable("make", "year", "color"),
    join_sortable("year", "mileage")
)]
pub vehicles: Vec&lt;Vehicle&gt;,</code></pre>
<p>This enables dot-notation queries:</p>
<pre><code class="language-bash"># Filter by related entity columns
GET /customers?filter={"vehicles.make":"BMW","vehicles.year_gte":2020}

# Sort by related entity columns
GET /customers?sort=["vehicles.year","DESC"]
</code></pre>
<p>Only whitelisted columns can be filtered/sorted - invalid columns are silently ignored for security.</p>
<p>See <a href="#filtering-on-related-entities-join-filtering">Filtering</a> and <a href="#sorting-by-related-entity-columns-join-sorting">Sorting</a> for detailed documentation.</p>
<h2 id="relationship-types"><a class="header" href="#relationship-types">Relationship Types</a></h2>
<h3 id="has-many-one-to-many"><a class="header" href="#has-many-one-to-many">Has Many (One-to-Many)</a></h3>
<pre><code class="language-rust">// Post has many Comments
#[sea_orm(ignore)]
#[crudcrate(non_db_attr, join(one))]
pub comments: Vec&lt;Comment&gt;,</code></pre>
<pre><code class="language-json">{
  "id": 1,
  "comments": [
    {"id": 1, "content": "First"},
    {"id": 2, "content": "Second"}
  ]
}
</code></pre>
<h3 id="belongs-to-many-to-one"><a class="header" href="#belongs-to-many-to-one">Belongs To (Many-to-One)</a></h3>
<pre><code class="language-rust">// Comment belongs to User
#[sea_orm(ignore)]
#[crudcrate(non_db_attr, join(one, all))]
pub user: Option&lt;User&gt;,</code></pre>
<pre><code class="language-json">{
  "id": 1,
  "content": "Great post!",
  "user": {"id": 5, "name": "Alice"}
}
</code></pre>
<h3 id="has-one-one-to-one"><a class="header" href="#has-one-one-to-one">Has One (One-to-One)</a></h3>
<pre><code class="language-rust">// User has one Profile
#[sea_orm(ignore)]
#[crudcrate(non_db_attr, join(one))]
pub profile: Option&lt;Profile&gt;,</code></pre>
<pre><code class="language-json">{
  "id": 5,
  "name": "Alice",
  "profile": {"bio": "Developer", "avatar": "..."}
}
</code></pre>
<h2 id="recursive-relationships"><a class="header" href="#recursive-relationships">Recursive Relationships</a></h2>
<p>For self-referencing entities:</p>
<pre><code class="language-rust">// Category can have child categories
#[derive(EntityToModels)]
#[sea_orm(table_name = "categories")]
pub struct Model {
    #[sea_orm(primary_key)]
    #[crudcrate(primary_key)]
    pub id: i32,

    pub name: String,

    pub parent_id: Option&lt;i32&gt;,

    // Children categories (with depth limit!)
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one, depth = 3))]
    pub children: Vec&lt;Category&gt;,
}</code></pre>
<pre><code class="language-json">{
  "id": 1,
  "name": "Electronics",
  "children": [
    {
      "id": 2,
      "name": "Phones",
      "children": [
        {"id": 5, "name": "Smartphones", "children": []},
        {"id": 6, "name": "Feature Phones", "children": []}
      ]
    }
  ]
}
</code></pre>
<p><strong>Important</strong>: Always use <code>depth</code> limit for self-referencing relationships!</p>
<h2 id="complete-example-2"><a class="header" href="#complete-example-2">Complete Example</a></h2>
<pre><code class="language-rust">// user.rs
#[derive(Clone, Debug, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(generate_router)]
#[sea_orm(table_name = "users")]
pub struct Model {
    #[sea_orm(primary_key)]
    #[crudcrate(primary_key, exclude(create, update))]
    pub id: i32,

    #[crudcrate(filterable, sortable)]
    pub name: String,

    pub email: String,

    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one))]
    pub posts: Vec&lt;super::post::Post&gt;,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::post::Entity")]
    Posts,
}

impl Related&lt;super::post::Entity&gt; for Entity {
    fn to() -&gt; RelationDef {
        Relation::Posts.def()
    }
}</code></pre>
<pre><code class="language-rust">// post.rs
#[derive(Clone, Debug, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(generate_router)]
#[sea_orm(table_name = "posts")]
pub struct Model {
    #[sea_orm(primary_key)]
    #[crudcrate(primary_key, exclude(create, update))]
    pub id: i32,

    #[crudcrate(filterable, sortable, fulltext)]
    pub title: String,

    pub content: String,

    #[crudcrate(filterable)]
    pub author_id: i32,

    // Load author in detail and list views
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one, all, depth = 1))]
    pub author: Option&lt;super::user::User&gt;,

    // Load comments only in detail view
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one, depth = 2))]
    pub comments: Vec&lt;super::comment::Comment&gt;,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::user::Entity",
        from = "Column::AuthorId",
        to = "super::user::Column::Id"
    )]
    Author,

    #[sea_orm(has_many = "super::comment::Entity")]
    Comments,
}

impl Related&lt;super::user::Entity&gt; for Entity {
    fn to() -&gt; RelationDef {
        Relation::Author.def()
    }
}

impl Related&lt;super::comment::Entity&gt; for Entity {
    fn to() -&gt; RelationDef {
        Relation::Comments.def()
    }
}</code></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="n1-query-problem"><a class="header" href="#n1-query-problem">N+1 Query Problem</a></h3>
<p>CRUDCrate loads relationships using additional queries:</p>
<pre><code class="language-sql">-- Main query
SELECT * FROM posts WHERE id = 1;

-- Relationship queries (N+1)
SELECT * FROM comments WHERE post_id = 1;
SELECT * FROM users WHERE id = 5;
</code></pre>
<p>For lists with <code>join(all)</code>, this becomes:</p>
<pre><code class="language-sql">-- For each post
SELECT * FROM users WHERE id = ?;
</code></pre>
<h3 id="optimization-strategies"><a class="header" href="#optimization-strategies">Optimization Strategies</a></h3>
<ol>
<li><strong>Use <code>join(one)</code> by default</strong>: Only load in detail views</li>
<li><strong>Limit depth</strong>: Prevent deep recursive loading</li>
<li><strong>Add indexes</strong>: On foreign key columns</li>
<li><strong>Consider eager loading</strong> for critical paths</li>
</ol>
<pre><code class="language-sql">-- Index foreign keys
CREATE INDEX idx_posts_author_id ON posts(author_id);
CREATE INDEX idx_comments_post_id ON comments(post_id);
</code></pre>
<h3 id="when-to-use-joinall"><a class="header" href="#when-to-use-joinall">When to Use <code>join(all)</code></a></h3>
<p>✅ Use for:</p>
<ul>
<li>Small reference data (categories, tags)</li>
<li>Essential context (author names in list)</li>
<li>Data needed for display</li>
</ul>
<p>❌ Avoid for:</p>
<ul>
<li>Large collections (comments, history)</li>
<li>Deep hierarchies</li>
<li>Optional/rare data</li>
</ul>
<h2 id="circular-reference-prevention"><a class="header" href="#circular-reference-prevention">Circular Reference Prevention</a></h2>
<p>CRUDCrate detects and warns about potential infinite loops:</p>
<pre><code>Warning: Potential circular reference detected in Post.author -&gt; User.posts -&gt; Post
Consider using depth limit: join(one, depth = 1)
</code></pre>
<p>Always use <code>depth</code> limits when entities reference each other.</p>
<h2 id="next-steps-12"><a class="header" href="#next-steps-12">Next Steps</a></h2>
<ul>
<li>Learn about <a href="#field-exclusion">Field Exclusion</a></li>
<li>Configure <a href="#default-values">Default Values</a></li>
<li>Set up <a href="#error-handling-3">Error Handling</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="field-exclusion"><a class="header" href="#field-exclusion">Field Exclusion</a></h1>
<p>Control which fields appear in which models using the <code>exclude</code> attribute.</p>
<h2 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h2>
<pre><code class="language-rust">#[crudcrate(exclude(target1, target2, ...))]
pub field_name: FieldType,</code></pre>
<h2 id="exclusion-targets"><a class="header" href="#exclusion-targets">Exclusion Targets</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target</th><th>Model</th><th>HTTP Method</th></tr>
</thead>
<tbody>
<tr><td><code>one</code></td><td>Response</td><td>GET <code>/items/:id</code></td></tr>
<tr><td><code>create</code></td><td>Create</td><td>POST <code>/items</code></td></tr>
<tr><td><code>update</code></td><td>Update</td><td>PUT <code>/items/:id</code></td></tr>
<tr><td><code>list</code></td><td>List</td><td>GET <code>/items</code></td></tr>
</tbody>
</table>
</div>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="auto-generated-ids"><a class="header" href="#auto-generated-ids">Auto-Generated IDs</a></h3>
<pre><code class="language-rust">// Don't let clients set the ID
#[crudcrate(primary_key, exclude(create, update))]
pub id: Uuid,</code></pre>
<p><strong>Result:</strong></p>
<ul>
<li>✅ Appears in responses</li>
<li>❌ Not in create request model</li>
<li>❌ Not in update request model</li>
</ul>
<h3 id="timestamps"><a class="header" href="#timestamps">Timestamps</a></h3>
<pre><code class="language-rust">// Managed by the system
#[crudcrate(exclude(create, update), on_create = chrono::Utc::now())]
pub created_at: DateTimeUtc,

#[crudcrate(exclude(create, update), on_create = chrono::Utc::now(), on_update = chrono::Utc::now())]
pub updated_at: DateTimeUtc,</code></pre>
<h3 id="sensitive-data"><a class="header" href="#sensitive-data">Sensitive Data</a></h3>
<pre><code class="language-rust">// Never expose password
#[crudcrate(exclude(one, list))]
pub password_hash: String,

// Never expose in responses
#[crudcrate(exclude(one, list))]
pub api_secret: String,</code></pre>
<p><strong>Result:</strong></p>
<ul>
<li>❌ Not in any response</li>
<li>✅ Can be set on create</li>
<li>✅ Can be updated</li>
</ul>
<h3 id="expensive-fields"><a class="header" href="#expensive-fields">Expensive Fields</a></h3>
<pre><code class="language-rust">// Large content not needed in lists
#[crudcrate(exclude(list))]
pub full_content: String,

// Computed field expensive to load
#[crudcrate(exclude(list))]
pub statistics: Json,</code></pre>
<p><strong>Result:</strong></p>
<ul>
<li>✅ In single item response</li>
<li>❌ Not in list response</li>
<li>✅ Can be set/updated</li>
</ul>
<h3 id="internal-fields"><a class="header" href="#internal-fields">Internal Fields</a></h3>
<pre><code class="language-rust">// Internal tracking, never expose
#[crudcrate(exclude(one, create, update, list))]
pub internal_score: f64,</code></pre>
<p><strong>Result:</strong></p>
<ul>
<li>❌ Not in any model</li>
<li>Field only used internally in database</li>
</ul>
<h3 id="read-only-computed-fields"><a class="header" href="#read-only-computed-fields">Read-Only Computed Fields</a></h3>
<pre><code class="language-rust">// Computed by database trigger
#[crudcrate(exclude(create, update))]
pub view_count: i32,

// Calculated field
#[crudcrate(exclude(create, update))]
pub full_name: String,</code></pre>
<h2 id="generated-models-comparison"><a class="header" href="#generated-models-comparison">Generated Models Comparison</a></h2>
<p>Given this entity:</p>
<pre><code class="language-rust">pub struct Model {
    #[crudcrate(primary_key, exclude(create, update))]
    pub id: i32,

    #[crudcrate(filterable)]
    pub email: String,

    #[crudcrate(exclude(one, list))]
    pub password_hash: String,

    pub display_name: Option&lt;String&gt;,

    #[crudcrate(exclude(list))]
    pub bio: Option&lt;String&gt;,

    #[crudcrate(exclude(create, update))]
    pub created_at: DateTimeUtc,
}</code></pre>
<h3 id="response-model-one"><a class="header" href="#response-model-one">Response Model (one)</a></h3>
<pre><code class="language-rust">pub struct User {
    pub id: i32,
    pub email: String,
    // password_hash: excluded
    pub display_name: Option&lt;String&gt;,
    pub bio: Option&lt;String&gt;,
    pub created_at: DateTimeUtc,
}</code></pre>
<h3 id="create-model-create"><a class="header" href="#create-model-create">Create Model (create)</a></h3>
<pre><code class="language-rust">pub struct UserCreate {
    // id: excluded
    pub email: String,
    pub password_hash: String,
    pub display_name: Option&lt;String&gt;,
    pub bio: Option&lt;String&gt;,
    // created_at: excluded
}</code></pre>
<h3 id="update-model-update"><a class="header" href="#update-model-update">Update Model (update)</a></h3>
<pre><code class="language-rust">pub struct UserUpdate {
    // id: excluded
    pub email: Option&lt;String&gt;,
    pub password_hash: Option&lt;String&gt;,
    pub display_name: Option&lt;Option&lt;String&gt;&gt;,
    pub bio: Option&lt;Option&lt;String&gt;&gt;,
    // created_at: excluded
}</code></pre>
<h3 id="list-model-list"><a class="header" href="#list-model-list">List Model (list)</a></h3>
<pre><code class="language-rust">pub struct UserList {
    pub id: i32,
    pub email: String,
    // password_hash: excluded
    pub display_name: Option&lt;String&gt;,
    // bio: excluded
    pub created_at: DateTimeUtc,
}</code></pre>
<h2 id="visual-reference"><a class="header" href="#visual-reference">Visual Reference</a></h2>
<pre><code>Field            │ Response │ Create │ Update │ List
─────────────────┼──────────┼────────┼────────┼──────
id               │    ✅    │   ❌   │   ❌   │  ✅
email            │    ✅    │   ✅   │   ✅   │  ✅
password_hash    │    ❌    │   ✅   │   ✅   │  ❌
display_name     │    ✅    │   ✅   │   ✅   │  ✅
bio              │    ✅    │   ✅   │   ✅   │  ❌
created_at       │    ✅    │   ❌   │   ❌   │  ✅
</code></pre>
<h2 id="combining-with-other-attributes"><a class="header" href="#combining-with-other-attributes">Combining with Other Attributes</a></h2>
<pre><code class="language-rust">// Primary key with auto-generation
#[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
pub id: Uuid,

// Filterable but not in create/update
#[crudcrate(filterable, exclude(create, update), on_create = chrono::Utc::now())]
pub created_at: DateTimeUtc,

// Sortable in lists but not in create
#[crudcrate(sortable, exclude(create))]
pub view_count: i32,</code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="1-always-exclude-auto-generated-fields"><a class="header" href="#1-always-exclude-auto-generated-fields">1. Always Exclude Auto-Generated Fields</a></h3>
<pre><code class="language-rust">#[crudcrate(primary_key, exclude(create, update))]
pub id: Uuid,

#[crudcrate(exclude(create, update))]
pub created_at: DateTimeUtc,</code></pre>
<h3 id="2-never-expose-secrets"><a class="header" href="#2-never-expose-secrets">2. Never Expose Secrets</a></h3>
<pre><code class="language-rust">#[crudcrate(exclude(one, list))]
pub password_hash: String,

#[crudcrate(exclude(one, list))]
pub api_key: String,

#[crudcrate(exclude(one, list))]
pub refresh_token: Option&lt;String&gt;,</code></pre>
<h3 id="3-optimize-list-responses"><a class="header" href="#3-optimize-list-responses">3. Optimize List Responses</a></h3>
<pre><code class="language-rust">// Large text fields
#[crudcrate(exclude(list))]
pub content: String,

// Expensive computed fields
#[crudcrate(exclude(list))]
pub statistics: Json,

// Relationships (use join instead)
#[sea_orm(ignore)]
#[crudcrate(non_db_attr, join(one))]  // Not in list
pub comments: Vec&lt;Comment&gt;,</code></pre>
<h3 id="4-document-your-exclusions"><a class="header" href="#4-document-your-exclusions">4. Document Your Exclusions</a></h3>
<pre><code class="language-rust">/// User password hash - never exposed in API responses
#[crudcrate(exclude(one, list))]
pub password_hash: String,

/// Created timestamp - managed by system
#[crudcrate(exclude(create, update), on_create = chrono::Utc::now())]
pub created_at: DateTimeUtc,</code></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="field-not-appearing"><a class="header" href="#field-not-appearing">Field Not Appearing</a></h3>
<p>Check that:</p>
<ol>
<li>Field is not excluded from that model</li>
<li>Field has correct visibility (<code>pub</code>)</li>
<li>Entity compiles without errors</li>
</ol>
<h3 id="client-sending-excluded-fields"><a class="header" href="#client-sending-excluded-fields">Client Sending Excluded Fields</a></h3>
<p>Excluded fields in requests are silently ignored:</p>
<pre><code class="language-bash"># Trying to set id on create
POST /users
{"id": 999, "email": "test@example.com"}

# Result: id is ignored, auto-generated
{"id": 1, "email": "test@example.com"}
</code></pre>
<h3 id="partial-updates-not-working"><a class="header" href="#partial-updates-not-working">Partial Updates Not Working</a></h3>
<p>For optional fields, remember the double-Option pattern:</p>
<pre><code class="language-rust">pub struct UserUpdate {
    pub bio: Option&lt;Option&lt;String&gt;&gt;,
    // None = don't change
    // Some(None) = set to null
    // Some(Some(value)) = set to value
}</code></pre>
<h2 id="next-steps-13"><a class="header" href="#next-steps-13">Next Steps</a></h2>
<ul>
<li>Configure <a href="#default-values">Default Values</a></li>
<li>Set up <a href="#error-handling-3">Error Handling</a></li>
<li>Learn about <a href="#relationships--joins">Relationships</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="default-values"><a class="header" href="#default-values">Default Values</a></h1>
<p>Automatically set field values on create and update operations.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<pre><code class="language-rust">// Set on create only
#[crudcrate(on_create = expression)]
pub field: Type,

// Set on update only
#[crudcrate(on_update = expression)]
pub field: Type,

// Set on both
#[crudcrate(on_create = expr1, on_update = expr2)]
pub field: Type,</code></pre>
<h2 id="common-patterns-2"><a class="header" href="#common-patterns-2">Common Patterns</a></h2>
<h3 id="uuid-primary-keys"><a class="header" href="#uuid-primary-keys">UUID Primary Keys</a></h3>
<pre><code class="language-rust">#[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
pub id: Uuid,</code></pre>
<h3 id="timestamps-1"><a class="header" href="#timestamps-1">Timestamps</a></h3>
<pre><code class="language-rust">// Created timestamp - set once
#[crudcrate(exclude(create, update), on_create = chrono::Utc::now())]
pub created_at: DateTimeUtc,

// Updated timestamp - set on every change
#[crudcrate(exclude(create, update), on_create = chrono::Utc::now(), on_update = chrono::Utc::now())]
pub updated_at: DateTimeUtc,</code></pre>
<h3 id="default-status"><a class="header" href="#default-status">Default Status</a></h3>
<pre><code class="language-rust">#[crudcrate(on_create = Status::Pending)]
pub status: Status,

#[crudcrate(on_create = "draft".to_string())]
pub status: String,</code></pre>
<h3 id="counters"><a class="header" href="#counters">Counters</a></h3>
<pre><code class="language-rust">#[crudcrate(exclude(create, update), on_create = 0)]
pub view_count: i32,

#[crudcrate(exclude(create, update), on_create = 0.0)]
pub rating: f64,</code></pre>
<h3 id="boolean-flags"><a class="header" href="#boolean-flags">Boolean Flags</a></h3>
<pre><code class="language-rust">#[crudcrate(on_create = false)]
pub is_verified: bool,

#[crudcrate(on_create = true)]
pub is_active: bool,</code></pre>
<h2 id="expression-types"><a class="header" href="#expression-types">Expression Types</a></h2>
<h3 id="literals"><a class="header" href="#literals">Literals</a></h3>
<pre><code class="language-rust">#[crudcrate(on_create = 0)]
pub count: i32,

#[crudcrate(on_create = "default")]
pub category: String,

#[crudcrate(on_create = true)]
pub active: bool,</code></pre>
<h3 id="function-calls"><a class="header" href="#function-calls">Function Calls</a></h3>
<pre><code class="language-rust">#[crudcrate(on_create = Uuid::new_v4())]
pub id: Uuid,

#[crudcrate(on_create = chrono::Utc::now())]
pub created_at: DateTimeUtc,</code></pre>
<h3 id="method-chains"><a class="header" href="#method-chains">Method Chains</a></h3>
<pre><code class="language-rust">#[crudcrate(on_create = "pending".to_string())]
pub status: String,

#[crudcrate(on_create = Vec::new())]
pub tags: Vec&lt;String&gt;,</code></pre>
<h3 id="enum-variants"><a class="header" href="#enum-variants">Enum Variants</a></h3>
<pre><code class="language-rust">#[crudcrate(on_create = Status::Pending)]
pub status: Status,

#[crudcrate(on_create = Priority::Normal)]
pub priority: Priority,</code></pre>
<h3 id="constants"><a class="header" href="#constants">Constants</a></h3>
<pre><code class="language-rust">const DEFAULT_LIMIT: i32 = 100;

#[crudcrate(on_create = DEFAULT_LIMIT)]
pub rate_limit: i32,</code></pre>
<h2 id="complete-example-3"><a class="header" href="#complete-example-3">Complete Example</a></h2>
<pre><code class="language-rust">use chrono::{DateTime, Utc};
use crudcrate::EntityToModels;
use sea_orm::entity::prelude::*;
use uuid::Uuid;

#[derive(Clone, Debug, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(StringLen::N(20))")]
pub enum ArticleStatus {
    #[sea_orm(string_value = "draft")]
    Draft,
    #[sea_orm(string_value = "review")]
    Review,
    #[sea_orm(string_value = "published")]
    Published,
    #[sea_orm(string_value = "archived")]
    Archived,
}

#[derive(Clone, Debug, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(generate_router)]
#[sea_orm(table_name = "articles")]
pub struct Model {
    // Auto-generated UUID
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    #[crudcrate(filterable, sortable, fulltext)]
    pub title: String,

    pub content: String,

    // Default to Draft status
    #[crudcrate(filterable, on_create = ArticleStatus::Draft)]
    pub status: ArticleStatus,

    // Start with zero views
    #[crudcrate(sortable, exclude(create, update), on_create = 0)]
    pub view_count: i32,

    // Track creation time
    #[crudcrate(sortable, exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTime&lt;Utc&gt;,

    // Track all modifications
    #[crudcrate(
        exclude(create, update),
        on_create = chrono::Utc::now(),
        on_update = chrono::Utc::now()
    )]
    pub updated_at: DateTime&lt;Utc&gt;,

    // Publish date (null until published)
    #[crudcrate(sortable)]
    pub published_at: Option&lt;DateTime&lt;Utc&gt;&gt;,
}</code></pre>
<h2 id="how-it-works-2"><a class="header" href="#how-it-works-2">How It Works</a></h2>
<h3 id="on_create-1"><a class="header" href="#on_create-1">on_create</a></h3>
<p>When creating a new record:</p>
<pre><code class="language-rust">// User provides
let create_data = ArticleCreate {
    title: "My Article".into(),
    content: "Content here...".into(),
    // status, view_count, created_at, updated_at: not provided
};

// CRUDCrate generates ActiveModel with defaults
let active_model = ActiveModel {
    id: Set(Uuid::new_v4()),           // on_create
    title: Set(create_data.title),
    content: Set(create_data.content),
    status: Set(ArticleStatus::Draft), // on_create
    view_count: Set(0),                // on_create
    created_at: Set(chrono::Utc::now()), // on_create
    updated_at: Set(chrono::Utc::now()), // on_create
    published_at: NotSet,
};</code></pre>
<h3 id="on_update-1"><a class="header" href="#on_update-1">on_update</a></h3>
<p>When updating an existing record:</p>
<pre><code class="language-rust">// User provides partial update
let update_data = ArticleUpdate {
    title: Some("Updated Title".into()),
    content: None,  // Don't change
    // ...
};

// CRUDCrate applies updates + on_update defaults
active_model.title = Set("Updated Title".into());
active_model.updated_at = Set(chrono::Utc::now());  // on_update
// Other fields: unchanged</code></pre>
<h2 id="combining-with-exclude"><a class="header" href="#combining-with-exclude">Combining with exclude</a></h2>
<p>Common pattern: exclude from client input, provide default</p>
<pre><code class="language-rust">// Client can't set, but has default
#[crudcrate(exclude(create, update), on_create = Uuid::new_v4())]
pub id: Uuid,

// Client can't set these timestamps
#[crudcrate(exclude(create, update), on_create = chrono::Utc::now())]
pub created_at: DateTimeUtc,</code></pre>
<h2 id="client-override"><a class="header" href="#client-override">Client Override</a></h2>
<p>If a field is NOT excluded, client can override the default:</p>
<pre><code class="language-rust">// Default status, but client CAN override
#[crudcrate(on_create = ArticleStatus::Draft)]
pub status: ArticleStatus,</code></pre>
<pre><code class="language-bash"># Uses default (Draft)
POST /articles
{"title": "My Article", "content": "..."}

# Client overrides default
POST /articles
{"title": "My Article", "content": "...", "status": "published"}
</code></pre>
<p>To prevent client override, combine with <code>exclude</code>:</p>
<pre><code class="language-rust">// Always Draft on create, client cannot override
#[crudcrate(exclude(create), on_create = ArticleStatus::Draft)]
pub status: ArticleStatus,</code></pre>
<h2 id="complex-defaults-with-operations"><a class="header" href="#complex-defaults-with-operations">Complex Defaults with Operations</a></h2>
<p>For complex default logic, use <code>CRUDOperations</code>:</p>
<pre><code class="language-rust">pub struct ArticleOperations;

impl CRUDOperations for ArticleOperations {
    type Resource = Article;

    async fn before_create(
        &amp;self,
        db: &amp;DatabaseConnection,
        data: &amp;mut ArticleCreate,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Complex default logic
        if data.slug.is_none() {
            data.slug = Some(slugify(&amp;data.title));
        }

        // Validate uniqueness
        if slug_exists(db, &amp;data.slug.as_ref().unwrap()).await? {
            data.slug = Some(format!("{}-{}", data.slug.unwrap(), Uuid::new_v4()));
        }

        Ok(())
    }
}</code></pre>
<h2 id="database-defaults-vs-crudcrate-defaults"><a class="header" href="#database-defaults-vs-crudcrate-defaults">Database Defaults vs CRUDCrate Defaults</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Database Default</th><th>CRUDCrate Default</th></tr>
</thead>
<tbody>
<tr><td>Where</td><td>SQL schema</td><td>Rust code</td></tr>
<tr><td>When</td><td>DB insert time</td><td>Before insert</td></tr>
<tr><td>Visibility</td><td>Not in API model</td><td>Part of workflow</td></tr>
<tr><td>Complexity</td><td>Limited SQL</td><td>Full Rust</td></tr>
</tbody>
</table>
</div>
<p>Use database defaults for:</p>
<ul>
<li>Simple values</li>
<li>Database-specific functions</li>
<li>Constraints</li>
</ul>
<p>Use CRUDCrate defaults for:</p>
<ul>
<li>Rust-generated values (UUIDs)</li>
<li>Complex logic</li>
<li>Values visible in API flow</li>
</ul>
<h2 id="next-steps-14"><a class="header" href="#next-steps-14">Next Steps</a></h2>
<ul>
<li>Set up <a href="#error-handling-3">Error Handling</a></li>
<li>Learn about <a href="#relationships--joins">Relationships</a></li>
<li>Implement <a href="#custom-operations">Custom Operations</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h1>
<p>CRUDCrate provides comprehensive error handling with security-conscious responses.</p>
<h2 id="apierror-types"><a class="header" href="#apierror-types">ApiError Types</a></h2>
<pre><code class="language-rust">pub enum ApiError {
    /// Resource not found (404)
    NotFound,

    /// Invalid request data (400)
    BadRequest(String),

    /// Authentication required (401)
    Unauthorized,

    /// Permission denied (403)
    Forbidden,

    /// Resource conflict (409)
    Conflict(String),

    /// Validation failed (422)
    ValidationFailed(Vec&lt;ValidationError&gt;),

    /// Database error (500) - details logged, not exposed
    Database(String),

    /// Generic internal error (500)
    Internal(String),
}</code></pre>
<h2 id="http-status-codes"><a class="header" href="#http-status-codes">HTTP Status Codes</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Error</th><th>Status</th><th>When</th></tr>
</thead>
<tbody>
<tr><td><code>NotFound</code></td><td>404</td><td>Resource doesn’t exist</td></tr>
<tr><td><code>BadRequest</code></td><td>400</td><td>Invalid input format</td></tr>
<tr><td><code>Unauthorized</code></td><td>401</td><td>Missing/invalid auth</td></tr>
<tr><td><code>Forbidden</code></td><td>403</td><td>Insufficient permissions</td></tr>
<tr><td><code>Conflict</code></td><td>409</td><td>Duplicate key, constraint violation</td></tr>
<tr><td><code>ValidationFailed</code></td><td>422</td><td>Business rule validation failed</td></tr>
<tr><td><code>Database</code></td><td>500</td><td>Database error (sanitized)</td></tr>
<tr><td><code>Internal</code></td><td>500</td><td>Other server error</td></tr>
</tbody>
</table>
</div>
<h2 id="response-format"><a class="header" href="#response-format">Response Format</a></h2>
<pre><code class="language-json">// NotFound
{
  "error": "Not found"
}

// BadRequest
{
  "error": "Invalid filter field: unknown_field"
}

// ValidationFailed
{
  "error": "Validation failed",
  "details": [
    {"field": "email", "message": "Invalid email format"},
    {"field": "age", "message": "Must be at least 18"}
  ]
}

// Database (sanitized)
{
  "error": "Database error"
}
</code></pre>
<h2 id="using-apierror"><a class="header" href="#using-apierror">Using ApiError</a></h2>
<h3 id="in-handlers"><a class="header" href="#in-handlers">In Handlers</a></h3>
<pre><code class="language-rust">use crudcrate::ApiError;

async fn get_item(
    Path(id): Path&lt;i32&gt;,
    Extension(db): Extension&lt;DatabaseConnection&gt;,
) -&gt; Result&lt;Json&lt;Item&gt;, ApiError&gt; {
    let item = Entity::find_by_id(id)
        .one(&amp;db)
        .await
        .map_err(|e| ApiError::Database(e.to_string()))?
        .ok_or(ApiError::NotFound)?;

    Ok(Json(item.into()))
}</code></pre>
<h3 id="in-crudoperations"><a class="header" href="#in-crudoperations">In CRUDOperations</a></h3>
<pre><code class="language-rust">impl CRUDOperations for MyOperations {
    type Resource = Item;

    async fn before_create(
        &amp;self,
        db: &amp;DatabaseConnection,
        data: &amp;mut ItemCreate,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Validation
        if data.name.is_empty() {
            return Err(ApiError::ValidationFailed(vec![
                ValidationError::new("name", "Name cannot be empty")
            ]));
        }

        // Permission check
        if !user_can_create(&amp;data) {
            return Err(ApiError::Forbidden);
        }

        // Uniqueness check
        if name_exists(db, &amp;data.name).await? {
            return Err(ApiError::Conflict("Name already exists".into()));
        }

        Ok(())
    }
}</code></pre>
<h2 id="validation-errors"><a class="header" href="#validation-errors">Validation Errors</a></h2>
<p>For detailed field-level errors:</p>
<pre><code class="language-rust">use crudcrate::ValidationError;

fn validate_user(data: &amp;UserCreate) -&gt; Result&lt;(), ApiError&gt; {
    let mut errors = Vec::new();

    if data.email.is_empty() {
        errors.push(ValidationError::new("email", "Email is required"));
    } else if !data.email.contains('@') {
        errors.push(ValidationError::new("email", "Invalid email format"));
    }

    if data.password.len() &lt; 8 {
        errors.push(ValidationError::new("password", "Password must be at least 8 characters"));
    }

    if data.age &lt; 18 {
        errors.push(ValidationError::new("age", "Must be at least 18 years old"));
    }

    if errors.is_empty() {
        Ok(())
    } else {
        Err(ApiError::ValidationFailed(errors))
    }
}</code></pre>
<p>Response:</p>
<pre><code class="language-json">{
  "error": "Validation failed",
  "details": [
    {"field": "email", "message": "Invalid email format"},
    {"field": "password", "message": "Password must be at least 8 characters"}
  ]
}
</code></pre>
<h2 id="error-conversion"><a class="header" href="#error-conversion">Error Conversion</a></h2>
<p>ApiError implements <code>From</code> for common error types:</p>
<pre><code class="language-rust">// Sea-ORM errors
impl From&lt;DbErr&gt; for ApiError {
    fn from(err: DbErr) -&gt; Self {
        // Log full error internally
        eprintln!("Database error: {}", err);
        // Return sanitized response
        ApiError::Database("Database error".into())
    }
}

// Use with ? operator
async fn create_item(data: ItemCreate, db: &amp;DatabaseConnection) -&gt; Result&lt;Item, ApiError&gt; {
    let active_model: ActiveModel = data.into();
    let result = active_model.insert(db).await?;  // Auto-converts DbErr
    Ok(result.into())
}</code></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="never-expose-internal-details"><a class="header" href="#never-expose-internal-details">Never Expose Internal Details</a></h3>
<pre><code class="language-rust">// ❌ Bad: exposes internal error
Err(ApiError::Database(format!("SQL error: {}", e)))

// ✅ Good: log internally, sanitize response
eprintln!("Database error: {}", e);
Err(ApiError::Database("Database error".into()))</code></pre>
<h3 id="handle-unique-constraint-violations"><a class="header" href="#handle-unique-constraint-violations">Handle Unique Constraint Violations</a></h3>
<pre><code class="language-rust">async fn create_user(data: UserCreate, db: &amp;DatabaseConnection) -&gt; Result&lt;User, ApiError&gt; {
    let result = Entity::insert(data.into())
        .exec(db)
        .await;

    match result {
        Ok(res) =&gt; { /* ... */ },
        Err(DbErr::RecordNotInserted) =&gt; {
            Err(ApiError::Conflict("User with this email already exists".into()))
        },
        Err(e) =&gt; {
            eprintln!("Insert error: {}", e);
            Err(ApiError::Database("Failed to create user".into()))
        }
    }
}</code></pre>
<h3 id="rate-limit-errors"><a class="header" href="#rate-limit-errors">Rate Limit Errors</a></h3>
<pre><code class="language-rust">async fn check_rate_limit(user_id: i32) -&gt; Result&lt;(), ApiError&gt; {
    // Implementation
    if is_rate_limited(user_id) {
        return Err(ApiError::BadRequest("Too many requests. Please wait.".into()));
    }
    Ok(())
}</code></pre>
<h2 id="logging-with-tracing"><a class="header" href="#logging-with-tracing">Logging with Tracing</a></h2>
<p>Integrate with the <code>tracing</code> crate:</p>
<pre><code class="language-rust">use tracing::{error, warn, info};

impl CRUDOperations for MyOperations {
    async fn before_delete(
        &amp;self,
        db: &amp;DatabaseConnection,
        id: i32,
    ) -&gt; Result&lt;(), ApiError&gt; {
        let item = Entity::find_by_id(id).one(db).await?;

        match item {
            Some(item) =&gt; {
                info!(id = %id, name = %item.name, "Deleting item");
                Ok(())
            },
            None =&gt; {
                warn!(id = %id, "Attempted to delete non-existent item");
                Err(ApiError::NotFound)
            }
        }
    }
}</code></pre>
<h2 id="custom-error-types"><a class="header" href="#custom-error-types">Custom Error Types</a></h2>
<p>Extend ApiError for domain-specific errors:</p>
<pre><code class="language-rust">#[derive(Debug)]
pub enum DomainError {
    InsufficientBalance(f64),
    ItemOutOfStock(String),
    OrderExpired,
}

impl From&lt;DomainError&gt; for ApiError {
    fn from(err: DomainError) -&gt; Self {
        match err {
            DomainError::InsufficientBalance(amount) =&gt; {
                ApiError::BadRequest(format!("Insufficient balance. Need ${:.2} more", amount))
            },
            DomainError::ItemOutOfStock(item) =&gt; {
                ApiError::Conflict(format!("Item '{}' is out of stock", item))
            },
            DomainError::OrderExpired =&gt; {
                ApiError::BadRequest("Order has expired".into())
            },
        }
    }
}</code></pre>
<h2 id="global-error-handler"><a class="header" href="#global-error-handler">Global Error Handler</a></h2>
<p>Configure Axum for consistent error handling:</p>
<pre><code class="language-rust">use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};

impl IntoResponse for ApiError {
    fn into_response(self) -&gt; Response {
        let (status, body) = match self {
            ApiError::NotFound =&gt; (
                StatusCode::NOT_FOUND,
                json!({"error": "Not found"})
            ),
            ApiError::BadRequest(msg) =&gt; (
                StatusCode::BAD_REQUEST,
                json!({"error": msg})
            ),
            ApiError::ValidationFailed(errors) =&gt; (
                StatusCode::UNPROCESSABLE_ENTITY,
                json!({
                    "error": "Validation failed",
                    "details": errors
                })
            ),
            // ... other variants
        };

        (status, Json(body)).into_response()
    }
}</code></pre>
<h2 id="testing-errors"><a class="header" href="#testing-errors">Testing Errors</a></h2>
<pre><code class="language-rust">#[tokio::test]
async fn test_not_found() {
    let app = create_test_app().await;

    let response = app
        .oneshot(Request::get("/items/999999").body(Body::empty()).unwrap())
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::NOT_FOUND);

    let body: Value = parse_body(response).await;
    assert_eq!(body["error"], "Not found");
}

#[tokio::test]
async fn test_validation_error() {
    let app = create_test_app().await;

    let response = app
        .oneshot(
            Request::post("/users")
                .header("Content-Type", "application/json")
                .body(Body::from(r#"{"email": "invalid"}"#))
                .unwrap()
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::UNPROCESSABLE_ENTITY);
}</code></pre>
<h2 id="next-steps-15"><a class="header" href="#next-steps-15">Next Steps</a></h2>
<ul>
<li>Implement <a href="#validation-1">Validation</a></li>
<li>Configure <a href="#security-best-practices">Security</a></li>
<li>Learn about <a href="#custom-operations">Custom Operations</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="custom-operations"><a class="header" href="#custom-operations">Custom Operations</a></h1>
<p>Extend CRUDCrate’s default behavior with the <code>CRUDOperations</code> trait.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p><code>CRUDOperations</code> provides hooks into every CRUD operation:</p>
<pre><code class="language-rust">#[async_trait]
pub trait CRUDOperations {
    type Resource: CRUDResource;

    // Create hooks
    async fn before_create(&amp;self, db: &amp;DatabaseConnection, data: &amp;mut CreateModel) -&gt; Result&lt;(), ApiError&gt;;
    async fn after_create(&amp;self, db: &amp;DatabaseConnection, created: &amp;Resource) -&gt; Result&lt;(), ApiError&gt;;

    // Update hooks
    async fn before_update(&amp;self, db: &amp;DatabaseConnection, id: PK, data: &amp;mut UpdateModel) -&gt; Result&lt;(), ApiError&gt;;
    async fn after_update(&amp;self, db: &amp;DatabaseConnection, updated: &amp;Resource) -&gt; Result&lt;(), ApiError&gt;;

    // Delete hooks
    async fn before_delete(&amp;self, db: &amp;DatabaseConnection, id: PK) -&gt; Result&lt;(), ApiError&gt;;
    async fn after_delete(&amp;self, db: &amp;DatabaseConnection, id: PK) -&gt; Result&lt;(), ApiError&gt;;

    // Read hooks
    async fn before_get_one(&amp;self, db: &amp;DatabaseConnection, id: PK) -&gt; Result&lt;(), ApiError&gt;;
    async fn before_get_all(&amp;self, db: &amp;DatabaseConnection, condition: &amp;mut Condition) -&gt; Result&lt;(), ApiError&gt;;
}</code></pre>
<h2 id="basic-setup"><a class="header" href="#basic-setup">Basic Setup</a></h2>
<h3 id="step-1-create-operations-struct"><a class="header" href="#step-1-create-operations-struct">Step 1: Create Operations Struct</a></h3>
<pre><code class="language-rust">pub struct ArticleOperations;</code></pre>
<h3 id="step-2-implement-crudoperations"><a class="header" href="#step-2-implement-crudoperations">Step 2: Implement CRUDOperations</a></h3>
<pre><code class="language-rust">use async_trait::async_trait;
use crudcrate::{CRUDOperations, ApiError};
use sea_orm::DatabaseConnection;

#[async_trait]
impl CRUDOperations for ArticleOperations {
    type Resource = Article;

    async fn before_create(
        &amp;self,
        _db: &amp;DatabaseConnection,
        data: &amp;mut ArticleCreate,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Trim whitespace
        data.title = data.title.trim().to_string();
        data.content = data.content.trim().to_string();
        Ok(())
    }

    async fn after_create(
        &amp;self,
        _db: &amp;DatabaseConnection,
        created: &amp;Article,
    ) -&gt; Result&lt;(), ApiError&gt; {
        println!("Article created: {}", created.id);
        Ok(())
    }
}</code></pre>
<h3 id="step-3-register-with-entity"><a class="header" href="#step-3-register-with-entity">Step 3: Register with Entity</a></h3>
<pre><code class="language-rust">#[derive(EntityToModels)]
#[crudcrate(generate_router, operations = ArticleOperations)]
pub struct Model {
    // ...
}</code></pre>
<h2 id="hook-execution-order"><a class="header" href="#hook-execution-order">Hook Execution Order</a></h2>
<h3 id="create"><a class="header" href="#create">Create</a></h3>
<pre><code>1. Parse request body → ArticleCreate
2. before_create(&amp;mut data)
3. Convert to ActiveModel
4. Insert into database
5. after_create(&amp;created)
6. Return response
</code></pre>
<h3 id="update"><a class="header" href="#update">Update</a></h3>
<pre><code>1. Parse request body → ArticleUpdate
2. before_update(id, &amp;mut data)
3. Load existing record
4. Merge updates
5. Update database
6. after_update(&amp;updated)
7. Return response
</code></pre>
<h3 id="delete"><a class="header" href="#delete">Delete</a></h3>
<pre><code>1. before_delete(id)
2. Delete from database
3. after_delete(id)
4. Return success
</code></pre>
<h3 id="read"><a class="header" href="#read">Read</a></h3>
<pre><code># get_one
1. before_get_one(id)
2. Query database
3. Return response

# get_all
1. before_get_all(&amp;mut condition)
2. Query database with condition
3. Return response
</code></pre>
<h2 id="common-use-cases"><a class="header" href="#common-use-cases">Common Use Cases</a></h2>
<h3 id="input-validation"><a class="header" href="#input-validation">Input Validation</a></h3>
<pre><code class="language-rust">async fn before_create(
    &amp;self,
    _db: &amp;DatabaseConnection,
    data: &amp;mut ArticleCreate,
) -&gt; Result&lt;(), ApiError&gt; {
    let mut errors = Vec::new();

    if data.title.len() &lt; 5 {
        errors.push(ValidationError::new("title", "Title must be at least 5 characters"));
    }

    if data.title.len() &gt; 200 {
        errors.push(ValidationError::new("title", "Title cannot exceed 200 characters"));
    }

    if data.content.is_empty() {
        errors.push(ValidationError::new("content", "Content is required"));
    }

    if errors.is_empty() {
        Ok(())
    } else {
        Err(ApiError::ValidationFailed(errors))
    }
}</code></pre>
<h3 id="data-transformation"><a class="header" href="#data-transformation">Data Transformation</a></h3>
<pre><code class="language-rust">async fn before_create(
    &amp;self,
    _db: &amp;DatabaseConnection,
    data: &amp;mut ArticleCreate,
) -&gt; Result&lt;(), ApiError&gt; {
    // Generate slug from title
    data.slug = Some(slugify(&amp;data.title));

    // Sanitize HTML content
    data.content = sanitize_html(&amp;data.content);

    // Normalize tags
    if let Some(tags) = &amp;mut data.tags {
        *tags = tags.iter()
            .map(|t| t.trim().to_lowercase())
            .filter(|t| !t.is_empty())
            .collect();
    }

    Ok(())
}</code></pre>
<h3 id="uniqueness-checks"><a class="header" href="#uniqueness-checks">Uniqueness Checks</a></h3>
<pre><code class="language-rust">async fn before_create(
    &amp;self,
    db: &amp;DatabaseConnection,
    data: &amp;mut ArticleCreate,
) -&gt; Result&lt;(), ApiError&gt; {
    // Check if slug already exists
    let slug = slugify(&amp;data.title);

    let exists = Entity::find()
        .filter(Column::Slug.eq(&amp;slug))
        .count(db)
        .await
        .map_err(|_| ApiError::Internal("Database error".into()))?;

    if exists &gt; 0 {
        // Append random suffix
        data.slug = Some(format!("{}-{}", slug, random_string(6)));
    } else {
        data.slug = Some(slug);
    }

    Ok(())
}</code></pre>
<h3 id="authorization"><a class="header" href="#authorization">Authorization</a></h3>
<pre><code class="language-rust">async fn before_update(
    &amp;self,
    db: &amp;DatabaseConnection,
    id: Uuid,
    _data: &amp;mut ArticleUpdate,
) -&gt; Result&lt;(), ApiError&gt; {
    // Get current user from context (you'd need to pass this)
    let current_user = get_current_user();

    // Load the article
    let article = Entity::find_by_id(id)
        .one(db)
        .await?
        .ok_or(ApiError::NotFound)?;

    // Check ownership
    if article.author_id != current_user.id &amp;&amp; !current_user.is_admin {
        return Err(ApiError::Forbidden);
    }

    Ok(())
}

async fn before_delete(
    &amp;self,
    db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt; {
    // Same authorization check
    let current_user = get_current_user();
    let article = Entity::find_by_id(id).one(db).await?.ok_or(ApiError::NotFound)?;

    if article.author_id != current_user.id &amp;&amp; !current_user.is_admin {
        return Err(ApiError::Forbidden);
    }

    Ok(())
}</code></pre>
<h3 id="cascading-operations"><a class="header" href="#cascading-operations">Cascading Operations</a></h3>
<pre><code class="language-rust">async fn before_delete(
    &amp;self,
    db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt; {
    // Delete related comments first
    comment::Entity::delete_many()
        .filter(comment::Column::ArticleId.eq(id))
        .exec(db)
        .await
        .map_err(|_| ApiError::Internal("Failed to delete comments".into()))?;

    // Delete related tags
    article_tag::Entity::delete_many()
        .filter(article_tag::Column::ArticleId.eq(id))
        .exec(db)
        .await
        .map_err(|_| ApiError::Internal("Failed to delete tags".into()))?;

    Ok(())
}</code></pre>
<h3 id="notifications"><a class="header" href="#notifications">Notifications</a></h3>
<pre><code class="language-rust">async fn after_create(
    &amp;self,
    db: &amp;DatabaseConnection,
    created: &amp;Article,
) -&gt; Result&lt;(), ApiError&gt; {
    // Notify subscribers
    let subscribers = get_subscribers_for_author(db, created.author_id).await?;

    for subscriber in subscribers {
        send_notification(
            subscriber.email,
            format!("New article: {}", created.title),
        ).await;
    }

    Ok(())
}</code></pre>
<h3 id="audit-logging"><a class="header" href="#audit-logging">Audit Logging</a></h3>
<pre><code class="language-rust">async fn after_create(
    &amp;self,
    db: &amp;DatabaseConnection,
    created: &amp;Article,
) -&gt; Result&lt;(), ApiError&gt; {
    create_audit_log(db, AuditLog {
        action: "CREATE",
        entity: "Article",
        entity_id: created.id.to_string(),
        user_id: get_current_user().id,
        timestamp: chrono::Utc::now(),
        changes: serde_json::to_value(created).ok(),
    }).await?;

    Ok(())
}

async fn after_update(
    &amp;self,
    db: &amp;DatabaseConnection,
    updated: &amp;Article,
) -&gt; Result&lt;(), ApiError&gt; {
    create_audit_log(db, AuditLog {
        action: "UPDATE",
        entity: "Article",
        entity_id: updated.id.to_string(),
        user_id: get_current_user().id,
        timestamp: chrono::Utc::now(),
        changes: None,  // Could include diff
    }).await?;

    Ok(())
}</code></pre>
<h3 id="row-level-security"><a class="header" href="#row-level-security">Row-Level Security</a></h3>
<pre><code class="language-rust">async fn before_get_all(
    &amp;self,
    _db: &amp;DatabaseConnection,
    condition: &amp;mut Condition,
) -&gt; Result&lt;(), ApiError&gt; {
    let current_user = get_current_user();

    if !current_user.is_admin {
        // Non-admins only see their own articles
        *condition = condition.clone().add(Column::AuthorId.eq(current_user.id));
    }

    Ok(())
}</code></pre>
<h2 id="complete-example-4"><a class="header" href="#complete-example-4">Complete Example</a></h2>
<pre><code class="language-rust">use async_trait::async_trait;
use crudcrate::{CRUDOperations, ApiError, ValidationError};
use sea_orm::{DatabaseConnection, EntityTrait, ColumnTrait, QueryFilter};

pub struct ArticleOperations;

#[async_trait]
impl CRUDOperations for ArticleOperations {
    type Resource = Article;

    async fn before_create(
        &amp;self,
        db: &amp;DatabaseConnection,
        data: &amp;mut ArticleCreate,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Validate
        let mut errors = Vec::new();
        if data.title.trim().len() &lt; 5 {
            errors.push(ValidationError::new("title", "Title too short"));
        }
        if !errors.is_empty() {
            return Err(ApiError::ValidationFailed(errors));
        }

        // Transform
        data.title = data.title.trim().to_string();
        data.slug = Some(slugify(&amp;data.title));

        // Ensure unique slug
        let mut slug = data.slug.clone().unwrap();
        let mut counter = 1;
        while slug_exists(db, &amp;slug).await? {
            slug = format!("{}-{}", data.slug.as_ref().unwrap(), counter);
            counter += 1;
        }
        data.slug = Some(slug);

        Ok(())
    }

    async fn after_create(
        &amp;self,
        db: &amp;DatabaseConnection,
        created: &amp;Article,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Log
        tracing::info!(article_id = %created.id, "Article created");

        // Index for search
        index_article_for_search(created).await;

        // Notify
        notify_followers(db, created).await?;

        Ok(())
    }

    async fn before_update(
        &amp;self,
        db: &amp;DatabaseConnection,
        id: Uuid,
        data: &amp;mut ArticleUpdate,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Authorize
        let article = Entity::find_by_id(id).one(db).await?.ok_or(ApiError::NotFound)?;
        let user = get_current_user();

        if article.author_id != user.id &amp;&amp; !user.is_admin {
            return Err(ApiError::Forbidden);
        }

        // Transform title if changed
        if let Some(ref mut title) = data.title {
            *title = title.trim().to_string();
        }

        Ok(())
    }

    async fn before_delete(
        &amp;self,
        db: &amp;DatabaseConnection,
        id: Uuid,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Authorize
        let article = Entity::find_by_id(id).one(db).await?.ok_or(ApiError::NotFound)?;
        let user = get_current_user();

        if article.author_id != user.id &amp;&amp; !user.is_admin {
            return Err(ApiError::Forbidden);
        }

        // Cascade delete
        comment::Entity::delete_many()
            .filter(comment::Column::ArticleId.eq(id))
            .exec(db)
            .await?;

        Ok(())
    }

    async fn after_delete(
        &amp;self,
        _db: &amp;DatabaseConnection,
        id: Uuid,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Remove from search index
        remove_from_search_index(id).await;

        tracing::info!(article_id = %id, "Article deleted");

        Ok(())
    }

    async fn before_get_all(
        &amp;self,
        _db: &amp;DatabaseConnection,
        condition: &amp;mut Condition,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Only show published articles (unless admin)
        let user = get_current_user();
        if !user.is_admin {
            *condition = condition.clone().add(Column::Status.eq("published"));
        }

        Ok(())
    }
}</code></pre>
<h2 id="default-implementation"><a class="header" href="#default-implementation">Default Implementation</a></h2>
<p>If you don’t need all hooks, the trait has default no-op implementations:</p>
<pre><code class="language-rust">#[async_trait]
impl CRUDOperations for ArticleOperations {
    type Resource = Article;

    // Only implement what you need
    async fn before_create(
        &amp;self,
        _db: &amp;DatabaseConnection,
        data: &amp;mut ArticleCreate,
    ) -&gt; Result&lt;(), ApiError&gt; {
        data.title = data.title.trim().to_string();
        Ok(())
    }

    // All other hooks use default (do nothing)
}</code></pre>
<h2 id="next-steps-16"><a class="header" href="#next-steps-16">Next Steps</a></h2>
<ul>
<li>Learn about <a href="#lifecycle-hooks-1">Lifecycle Hooks</a> for attribute-based hooks</li>
<li>Configure <a href="#validation-1">Validation</a></li>
<li>Set up <a href="#security-best-practices">Security</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lifecycle-hooks-1"><a class="header" href="#lifecycle-hooks-1">Lifecycle Hooks</a></h1>
<p>Configure operation hooks directly through attributes for simple cases.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>Lifecycle hooks provide attribute-based customization without implementing <code>CRUDOperations</code>:</p>
<pre><code class="language-rust">#[derive(EntityToModels)]
#[crudcrate(
    generate_router,
    create::one::pre = validate_article,
    create::one::post = notify_subscribers,
    update::one::pre = check_permissions,
    delete::one::pre = archive_instead_of_delete,
)]
pub struct Model {
    // ...
}</code></pre>
<h2 id="hook-types"><a class="header" href="#hook-types">Hook Types</a></h2>
<h3 id="pre-hooks-pre"><a class="header" href="#pre-hooks-pre">Pre Hooks (<code>::pre</code>)</a></h3>
<p>Execute <strong>before</strong> the database operation:</p>
<pre><code class="language-rust">#[crudcrate(create::one::pre = validate_article)]

// Hook function signature
async fn validate_article(
    db: &amp;DatabaseConnection,
    data: &amp;mut ArticleCreate,
) -&gt; Result&lt;(), ApiError&gt; {
    if data.title.is_empty() {
        return Err(ApiError::ValidationFailed(vec![
            ValidationError::new("title", "Title is required")
        ]));
    }
    Ok(())
}</code></pre>
<h3 id="post-hooks-post"><a class="header" href="#post-hooks-post">Post Hooks (<code>::post</code>)</a></h3>
<p>Execute <strong>after</strong> the database operation succeeds:</p>
<pre><code class="language-rust">#[crudcrate(create::one::post = notify_subscribers)]

// Hook function signature
async fn notify_subscribers(
    db: &amp;DatabaseConnection,
    created: &amp;Article,
) -&gt; Result&lt;(), ApiError&gt; {
    send_notifications(created.author_id).await;
    Ok(())
}</code></pre>
<h3 id="body-replacement-body"><a class="header" href="#body-replacement-body">Body Replacement (<code>::body</code>)</a></h3>
<p><strong>Replace</strong> the entire operation logic:</p>
<pre><code class="language-rust">#[crudcrate(delete::one::body = soft_delete)]

// Completely replaces the delete handler
async fn soft_delete(
    db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt; {
    // Instead of deleting, mark as deleted
    let mut article: ActiveModel = Entity::find_by_id(id)
        .one(db)
        .await?
        .ok_or(ApiError::NotFound)?
        .into();

    article.deleted_at = Set(Some(chrono::Utc::now()));
    article.update(db).await?;

    Ok(())
}</code></pre>
<h2 id="available-operations"><a class="header" href="#available-operations">Available Operations</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>create::one</code></td><td>Create single item (POST /items)</td></tr>
<tr><td><code>update::one</code></td><td>Update single item (PUT /items/:id)</td></tr>
<tr><td><code>delete::one</code></td><td>Delete single item (DELETE /items/:id)</td></tr>
<tr><td><code>delete::many</code></td><td>Bulk delete (DELETE /items with body)</td></tr>
<tr><td><code>get::one</code></td><td>Get single item (GET /items/:id)</td></tr>
<tr><td><code>get::all</code></td><td>List items (GET /items)</td></tr>
</tbody>
</table>
</div>
<h2 id="function-signatures"><a class="header" href="#function-signatures">Function Signatures</a></h2>
<h3 id="create-hooks"><a class="header" href="#create-hooks">Create Hooks</a></h3>
<pre><code class="language-rust">// Pre hook - can modify the input
async fn create_pre(
    db: &amp;DatabaseConnection,
    data: &amp;mut ArticleCreate,
) -&gt; Result&lt;(), ApiError&gt;;

// Post hook - receives the created entity
async fn create_post(
    db: &amp;DatabaseConnection,
    created: &amp;Article,
) -&gt; Result&lt;(), ApiError&gt;;

// Body replacement - full control
async fn create_body(
    db: &amp;DatabaseConnection,
    data: ArticleCreate,
) -&gt; Result&lt;Article, ApiError&gt;;</code></pre>
<h3 id="update-hooks"><a class="header" href="#update-hooks">Update Hooks</a></h3>
<pre><code class="language-rust">// Pre hook
async fn update_pre(
    db: &amp;DatabaseConnection,
    id: Uuid,
    data: &amp;mut ArticleUpdate,
) -&gt; Result&lt;(), ApiError&gt;;

// Post hook
async fn update_post(
    db: &amp;DatabaseConnection,
    updated: &amp;Article,
) -&gt; Result&lt;(), ApiError&gt;;

// Body replacement
async fn update_body(
    db: &amp;DatabaseConnection,
    id: Uuid,
    data: ArticleUpdate,
) -&gt; Result&lt;Article, ApiError&gt;;</code></pre>
<h3 id="delete-hooks"><a class="header" href="#delete-hooks">Delete Hooks</a></h3>
<pre><code class="language-rust">// Pre hook
async fn delete_pre(
    db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt;;

// Post hook
async fn delete_post(
    db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt;;

// Body replacement
async fn delete_body(
    db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt;;</code></pre>
<h3 id="get-hooks"><a class="header" href="#get-hooks">Get Hooks</a></h3>
<pre><code class="language-rust">// Pre hook for get_one
async fn get_one_pre(
    db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt;;

// Pre hook for get_all - can modify the condition
async fn get_all_pre(
    db: &amp;DatabaseConnection,
    condition: &amp;mut Condition,
) -&gt; Result&lt;(), ApiError&gt;;</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="input-validation-1"><a class="header" href="#input-validation-1">Input Validation</a></h3>
<pre><code class="language-rust">#[crudcrate(create::one::pre = validate_user)]

async fn validate_user(
    _db: &amp;DatabaseConnection,
    data: &amp;mut UserCreate,
) -&gt; Result&lt;(), ApiError&gt; {
    let mut errors = Vec::new();

    // Email validation
    if !data.email.contains('@') {
        errors.push(ValidationError::new("email", "Invalid email format"));
    }

    // Password strength
    if data.password.len() &lt; 8 {
        errors.push(ValidationError::new("password", "Must be at least 8 characters"));
    }

    if errors.is_empty() {
        Ok(())
    } else {
        Err(ApiError::ValidationFailed(errors))
    }
}</code></pre>
<h3 id="password-hashing"><a class="header" href="#password-hashing">Password Hashing</a></h3>
<pre><code class="language-rust">#[crudcrate(create::one::pre = hash_password)]

async fn hash_password(
    _db: &amp;DatabaseConnection,
    data: &amp;mut UserCreate,
) -&gt; Result&lt;(), ApiError&gt; {
    // Hash the password before storing
    data.password_hash = bcrypt::hash(&amp;data.password, bcrypt::DEFAULT_COST)
        .map_err(|_| ApiError::Internal("Failed to hash password".into()))?;

    // Clear the plain password
    data.password.clear();

    Ok(())
}</code></pre>
<h3 id="soft-delete"><a class="header" href="#soft-delete">Soft Delete</a></h3>
<pre><code class="language-rust">#[crudcrate(delete::one::body = soft_delete_article)]

async fn soft_delete_article(
    db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt; {
    let article = Entity::find_by_id(id)
        .one(db)
        .await?
        .ok_or(ApiError::NotFound)?;

    let mut active: ActiveModel = article.into();
    active.deleted_at = Set(Some(chrono::Utc::now()));
    active.update(db).await?;

    Ok(())
}</code></pre>
<h3 id="row-level-security-1"><a class="header" href="#row-level-security-1">Row-Level Security</a></h3>
<pre><code class="language-rust">#[crudcrate(get::all::pre = filter_by_tenant)]

async fn filter_by_tenant(
    _db: &amp;DatabaseConnection,
    condition: &amp;mut Condition,
) -&gt; Result&lt;(), ApiError&gt; {
    let tenant_id = get_current_tenant_id();

    *condition = condition.clone().add(Column::TenantId.eq(tenant_id));

    Ok(())
}</code></pre>
<h3 id="audit-trail"><a class="header" href="#audit-trail">Audit Trail</a></h3>
<pre><code class="language-rust">#[crudcrate(
    create::one::post = log_create,
    update::one::post = log_update,
    delete::one::post = log_delete,
)]

async fn log_create(
    db: &amp;DatabaseConnection,
    created: &amp;Article,
) -&gt; Result&lt;(), ApiError&gt; {
    save_audit_log(db, "CREATE", "Article", &amp;created.id.to_string()).await
}

async fn log_update(
    db: &amp;DatabaseConnection,
    updated: &amp;Article,
) -&gt; Result&lt;(), ApiError&gt; {
    save_audit_log(db, "UPDATE", "Article", &amp;updated.id.to_string()).await
}

async fn log_delete(
    db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt; {
    save_audit_log(db, "DELETE", "Article", &amp;id.to_string()).await
}</code></pre>
<h3 id="cascade-updates"><a class="header" href="#cascade-updates">Cascade Updates</a></h3>
<pre><code class="language-rust">#[crudcrate(update::one::post = update_search_index)]

async fn update_search_index(
    _db: &amp;DatabaseConnection,
    updated: &amp;Article,
) -&gt; Result&lt;(), ApiError&gt; {
    // Update search engine
    search_client::update_document("articles", updated.id, updated).await;
    Ok(())
}</code></pre>
<h3 id="authorization-check"><a class="header" href="#authorization-check">Authorization Check</a></h3>
<pre><code class="language-rust">#[crudcrate(
    update::one::pre = check_edit_permission,
    delete::one::pre = check_delete_permission,
)]

async fn check_edit_permission(
    db: &amp;DatabaseConnection,
    id: Uuid,
    _data: &amp;mut ArticleUpdate,
) -&gt; Result&lt;(), ApiError&gt; {
    let article = Entity::find_by_id(id).one(db).await?.ok_or(ApiError::NotFound)?;
    let user = get_current_user();

    if article.author_id != user.id &amp;&amp; !user.is_admin {
        return Err(ApiError::Forbidden);
    }

    Ok(())
}

async fn check_delete_permission(
    db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt; {
    let article = Entity::find_by_id(id).one(db).await?.ok_or(ApiError::NotFound)?;
    let user = get_current_user();

    if !user.is_admin {
        return Err(ApiError::Forbidden);
    }

    Ok(())
}</code></pre>
<h2 id="hooks-vs-crudoperations"><a class="header" href="#hooks-vs-crudoperations">Hooks vs CRUDOperations</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Hooks</th><th>CRUDOperations</th></tr>
</thead>
<tbody>
<tr><td>Configuration</td><td>Attribute</td><td>Trait impl</td></tr>
<tr><td>Scope</td><td>Per-operation</td><td>All operations</td></tr>
<tr><td>State</td><td>Stateless functions</td><td>Can hold state</td></tr>
<tr><td>Testing</td><td>Function mocking</td><td>Trait mocking</td></tr>
<tr><td>Use when</td><td>Simple cases</td><td>Complex logic</td></tr>
</tbody>
</table>
</div>
<h3 id="when-to-use-hooks"><a class="header" href="#when-to-use-hooks">When to Use Hooks</a></h3>
<ul>
<li>Simple validation</li>
<li>Data transformation</li>
<li>Logging/notifications</li>
<li>Single operation customization</li>
</ul>
<h3 id="when-to-use-crudoperations"><a class="header" href="#when-to-use-crudoperations">When to Use CRUDOperations</a></h3>
<ul>
<li>Complex authorization logic</li>
<li>Shared state across operations</li>
<li>Database-dependent validation</li>
<li>Multiple operations need same logic</li>
</ul>
<h2 id="combining-both"><a class="header" href="#combining-both">Combining Both</a></h2>
<p>You can use both hooks and CRUDOperations:</p>
<pre><code class="language-rust">#[derive(EntityToModels)]
#[crudcrate(
    generate_router,
    operations = ArticleOperations,
    create::one::pre = validate_article,  // Runs before CRUDOperations::before_create
)]
pub struct Model { }</code></pre>
<p>Execution order:</p>
<ol>
<li>Attribute hook (<code>create::one::pre</code>)</li>
<li><code>CRUDOperations::before_create</code></li>
<li>Database operation</li>
<li><code>CRUDOperations::after_create</code></li>
<li>Attribute hook (<code>create::one::post</code>)</li>
</ol>
<h2 id="next-steps-17"><a class="header" href="#next-steps-17">Next Steps</a></h2>
<ul>
<li>Learn about <a href="#validation-1">Validation</a></li>
<li>Configure <a href="#security-best-practices">Security</a></li>
<li>Set up <a href="#performance-optimization">Performance Optimization</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="validation-1"><a class="header" href="#validation-1">Validation</a></h1>
<p>Validate input data before it reaches your database.</p>
<h2 id="validationerror-type"><a class="header" href="#validationerror-type">ValidationError Type</a></h2>
<pre><code class="language-rust">pub struct ValidationError {
    pub field: String,
    pub message: String,
}

impl ValidationError {
    pub fn new(field: &amp;str, message: &amp;str) -&gt; Self {
        Self {
            field: field.to_string(),
            message: message.to_string(),
        }
    }
}</code></pre>
<h2 id="basic-validation"><a class="header" href="#basic-validation">Basic Validation</a></h2>
<h3 id="in-hooks"><a class="header" href="#in-hooks">In Hooks</a></h3>
<pre><code class="language-rust">#[crudcrate(create::one::pre = validate_user)]

async fn validate_user(
    _db: &amp;DatabaseConnection,
    data: &amp;mut UserCreate,
) -&gt; Result&lt;(), ApiError&gt; {
    let mut errors = Vec::new();

    // Required field
    if data.name.trim().is_empty() {
        errors.push(ValidationError::new("name", "Name is required"));
    }

    // Email format
    if !data.email.contains('@') {
        errors.push(ValidationError::new("email", "Invalid email format"));
    }

    // Length constraints
    if data.password.len() &lt; 8 {
        errors.push(ValidationError::new("password", "Must be at least 8 characters"));
    }

    if data.password.len() &gt; 128 {
        errors.push(ValidationError::new("password", "Must be at most 128 characters"));
    }

    if errors.is_empty() {
        Ok(())
    } else {
        Err(ApiError::ValidationFailed(errors))
    }
}</code></pre>
<h3 id="in-crudoperations-1"><a class="header" href="#in-crudoperations-1">In CRUDOperations</a></h3>
<pre><code class="language-rust">impl CRUDOperations for UserOperations {
    type Resource = User;

    async fn before_create(
        &amp;self,
        db: &amp;DatabaseConnection,
        data: &amp;mut UserCreate,
    ) -&gt; Result&lt;(), ApiError&gt; {
        validate_user_data(data)?;
        check_email_unique(db, &amp;data.email).await?;
        Ok(())
    }
}

fn validate_user_data(data: &amp;UserCreate) -&gt; Result&lt;(), ApiError&gt; {
    let mut errors = Vec::new();

    if data.name.is_empty() {
        errors.push(ValidationError::new("name", "Required"));
    }

    if !errors.is_empty() {
        return Err(ApiError::ValidationFailed(errors));
    }

    Ok(())
}</code></pre>
<h2 id="common-validators"><a class="header" href="#common-validators">Common Validators</a></h2>
<h3 id="required-fields"><a class="header" href="#required-fields">Required Fields</a></h3>
<pre><code class="language-rust">fn required(value: &amp;str, field: &amp;str) -&gt; Option&lt;ValidationError&gt; {
    if value.trim().is_empty() {
        Some(ValidationError::new(field, "This field is required"))
    } else {
        None
    }
}</code></pre>
<h3 id="string-length"><a class="header" href="#string-length">String Length</a></h3>
<pre><code class="language-rust">fn min_length(value: &amp;str, min: usize, field: &amp;str) -&gt; Option&lt;ValidationError&gt; {
    if value.len() &lt; min {
        Some(ValidationError::new(field, &amp;format!("Must be at least {} characters", min)))
    } else {
        None
    }
}

fn max_length(value: &amp;str, max: usize, field: &amp;str) -&gt; Option&lt;ValidationError&gt; {
    if value.len() &gt; max {
        Some(ValidationError::new(field, &amp;format!("Must be at most {} characters", max)))
    } else {
        None
    }
}</code></pre>
<h3 id="email-format"><a class="header" href="#email-format">Email Format</a></h3>
<pre><code class="language-rust">fn valid_email(email: &amp;str, field: &amp;str) -&gt; Option&lt;ValidationError&gt; {
    // Simple validation
    if !email.contains('@') || !email.contains('.') {
        return Some(ValidationError::new(field, "Invalid email format"));
    }

    // Or use regex for more thorough validation
    let email_regex = regex::Regex::new(
        r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    ).unwrap();

    if !email_regex.is_match(email) {
        Some(ValidationError::new(field, "Invalid email format"))
    } else {
        None
    }
}</code></pre>
<h3 id="numeric-range"><a class="header" href="#numeric-range">Numeric Range</a></h3>
<pre><code class="language-rust">fn in_range&lt;T: PartialOrd + std::fmt::Display&gt;(
    value: T,
    min: T,
    max: T,
    field: &amp;str,
) -&gt; Option&lt;ValidationError&gt; {
    if value &lt; min || value &gt; max {
        Some(ValidationError::new(
            field,
            &amp;format!("Must be between {} and {}", min, max)
        ))
    } else {
        None
    }
}</code></pre>
<h3 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h3>
<pre><code class="language-rust">fn matches_pattern(value: &amp;str, pattern: &amp;str, field: &amp;str, message: &amp;str) -&gt; Option&lt;ValidationError&gt; {
    let regex = regex::Regex::new(pattern).unwrap();
    if !regex.is_match(value) {
        Some(ValidationError::new(field, message))
    } else {
        None
    }
}

// Usage
fn validate_username(username: &amp;str) -&gt; Option&lt;ValidationError&gt; {
    matches_pattern(
        username,
        r"^[a-zA-Z0-9_]{3,20}$",
        "username",
        "Username must be 3-20 characters, letters, numbers, and underscores only"
    )
}</code></pre>
<h2 id="database-validation"><a class="header" href="#database-validation">Database Validation</a></h2>
<h3 id="uniqueness-check"><a class="header" href="#uniqueness-check">Uniqueness Check</a></h3>
<pre><code class="language-rust">async fn check_unique_email(
    db: &amp;DatabaseConnection,
    email: &amp;str,
    exclude_id: Option&lt;Uuid&gt;,
) -&gt; Result&lt;(), ApiError&gt; {
    let mut query = Entity::find().filter(Column::Email.eq(email));

    // Exclude current record during update
    if let Some(id) = exclude_id {
        query = query.filter(Column::Id.ne(id));
    }

    let exists = query.count(db).await.map_err(|_| ApiError::Internal("Database error".into()))?;

    if exists &gt; 0 {
        Err(ApiError::ValidationFailed(vec![
            ValidationError::new("email", "Email already in use")
        ]))
    } else {
        Ok(())
    }
}</code></pre>
<h3 id="foreign-key-existence"><a class="header" href="#foreign-key-existence">Foreign Key Existence</a></h3>
<pre><code class="language-rust">async fn check_category_exists(
    db: &amp;DatabaseConnection,
    category_id: i32,
) -&gt; Result&lt;(), ApiError&gt; {
    let exists = category::Entity::find_by_id(category_id)
        .count(db)
        .await
        .map_err(|_| ApiError::Internal("Database error".into()))?;

    if exists == 0 {
        Err(ApiError::ValidationFailed(vec![
            ValidationError::new("category_id", "Category does not exist")
        ]))
    } else {
        Ok(())
    }
}</code></pre>
<h2 id="validator-builder-pattern"><a class="header" href="#validator-builder-pattern">Validator Builder Pattern</a></h2>
<p>Create a fluent validation API:</p>
<pre><code class="language-rust">pub struct Validator {
    errors: Vec&lt;ValidationError&gt;,
}

impl Validator {
    pub fn new() -&gt; Self {
        Self { errors: Vec::new() }
    }

    pub fn required(mut self, value: &amp;str, field: &amp;str) -&gt; Self {
        if value.trim().is_empty() {
            self.errors.push(ValidationError::new(field, "Required"));
        }
        self
    }

    pub fn min_length(mut self, value: &amp;str, min: usize, field: &amp;str) -&gt; Self {
        if value.len() &lt; min {
            self.errors.push(ValidationError::new(
                field,
                &amp;format!("Must be at least {} characters", min)
            ));
        }
        self
    }

    pub fn max_length(mut self, value: &amp;str, max: usize, field: &amp;str) -&gt; Self {
        if value.len() &gt; max {
            self.errors.push(ValidationError::new(
                field,
                &amp;format!("Must be at most {} characters", max)
            ));
        }
        self
    }

    pub fn email(mut self, value: &amp;str, field: &amp;str) -&gt; Self {
        if !value.contains('@') {
            self.errors.push(ValidationError::new(field, "Invalid email"));
        }
        self
    }

    pub fn validate(self) -&gt; Result&lt;(), ApiError&gt; {
        if self.errors.is_empty() {
            Ok(())
        } else {
            Err(ApiError::ValidationFailed(self.errors))
        }
    }
}

// Usage
fn validate_user(data: &amp;UserCreate) -&gt; Result&lt;(), ApiError&gt; {
    Validator::new()
        .required(&amp;data.name, "name")
        .min_length(&amp;data.name, 2, "name")
        .max_length(&amp;data.name, 100, "name")
        .required(&amp;data.email, "email")
        .email(&amp;data.email, "email")
        .min_length(&amp;data.password, 8, "password")
        .validate()
}</code></pre>
<h2 id="using-the-validator-crate"><a class="header" href="#using-the-validator-crate">Using the <code>validator</code> Crate</a></h2>
<p>Integrate with the popular <code>validator</code> crate:</p>
<pre><code class="language-toml">[dependencies]
validator = { version = "0.18", features = ["derive"] }
</code></pre>
<pre><code class="language-rust">use validator::{Validate, ValidationErrors};

#[derive(Validate, Deserialize)]
pub struct UserCreate {
    #[validate(length(min = 2, max = 100))]
    pub name: String,

    #[validate(email)]
    pub email: String,

    #[validate(length(min = 8))]
    pub password: String,

    #[validate(range(min = 18, max = 150))]
    pub age: Option&lt;i32&gt;,

    #[validate(url)]
    pub website: Option&lt;String&gt;,
}

// Convert validator errors to CRUDCrate errors
fn to_api_errors(errors: ValidationErrors) -&gt; ApiError {
    let validation_errors: Vec&lt;ValidationError&gt; = errors
        .field_errors()
        .iter()
        .flat_map(|(field, errs)| {
            errs.iter().map(|e| {
                ValidationError::new(
                    field,
                    e.message.as_ref().map(|m| m.to_string()).unwrap_or_else(|| "Invalid".to_string()).as_str()
                )
            })
        })
        .collect();

    ApiError::ValidationFailed(validation_errors)
}

// In hook
async fn validate_user(
    _db: &amp;DatabaseConnection,
    data: &amp;mut UserCreate,
) -&gt; Result&lt;(), ApiError&gt; {
    data.validate().map_err(to_api_errors)?;
    Ok(())
}</code></pre>
<h2 id="conditional-validation"><a class="header" href="#conditional-validation">Conditional Validation</a></h2>
<pre><code class="language-rust">fn validate_article(data: &amp;ArticleCreate) -&gt; Result&lt;(), ApiError&gt; {
    let mut errors = Vec::new();

    // Always required
    if data.title.is_empty() {
        errors.push(ValidationError::new("title", "Title is required"));
    }

    // Required only if publishing
    if data.status == ArticleStatus::Published {
        if data.content.is_empty() {
            errors.push(ValidationError::new("content", "Content required for published articles"));
        }

        if data.excerpt.is_none() {
            errors.push(ValidationError::new("excerpt", "Excerpt required for published articles"));
        }
    }

    if errors.is_empty() {
        Ok(())
    } else {
        Err(ApiError::ValidationFailed(errors))
    }
}</code></pre>
<h2 id="async-validation"><a class="header" href="#async-validation">Async Validation</a></h2>
<pre><code class="language-rust">async fn validate_article_async(
    db: &amp;DatabaseConnection,
    data: &amp;ArticleCreate,
) -&gt; Result&lt;(), ApiError&gt; {
    let mut errors = Vec::new();

    // Sync validations
    if data.title.is_empty() {
        errors.push(ValidationError::new("title", "Required"));
    }

    // Async validations
    if !errors.is_empty() {
        // Skip async checks if basic validation fails
        return Err(ApiError::ValidationFailed(errors));
    }

    // Check slug uniqueness
    let slug = slugify(&amp;data.title);
    if slug_exists(db, &amp;slug).await? {
        errors.push(ValidationError::new("title", "An article with this title already exists"));
    }

    // Check category exists
    if let Some(cat_id) = data.category_id {
        if !category_exists(db, cat_id).await? {
            errors.push(ValidationError::new("category_id", "Category not found"));
        }
    }

    if errors.is_empty() {
        Ok(())
    } else {
        Err(ApiError::ValidationFailed(errors))
    }
}</code></pre>
<h2 id="response-format-1"><a class="header" href="#response-format-1">Response Format</a></h2>
<p>Validation errors return HTTP 422:</p>
<pre><code class="language-json">{
  "error": "Validation failed",
  "details": [
    {"field": "email", "message": "Invalid email format"},
    {"field": "password", "message": "Must be at least 8 characters"},
    {"field": "age", "message": "Must be between 18 and 150"}
  ]
}
</code></pre>
<h2 id="next-steps-18"><a class="header" href="#next-steps-18">Next Steps</a></h2>
<ul>
<li>Configure <a href="#security-best-practices">Security</a></li>
<li>Set up <a href="#performance-optimization">Performance Optimization</a></li>
<li>Learn about <a href="#multi-database-support">Multi-Database Support</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="security-best-practices"><a class="header" href="#security-best-practices">Security Best Practices</a></h1>
<p>CRUDCrate includes built-in security features, but here’s how to maximize protection.</p>
<h2 id="built-in-protections"><a class="header" href="#built-in-protections">Built-in Protections</a></h2>
<h3 id="sql-injection-prevention-1"><a class="header" href="#sql-injection-prevention-1">SQL Injection Prevention</a></h3>
<p>All queries use parameterization:</p>
<pre><code class="language-rust">// User input is NEVER interpolated into SQL
let condition = Column::Email.eq(user_input);

// Generated SQL:
// SELECT * FROM users WHERE email = $1
// With parameter: user_input (escaped)</code></pre>
<h3 id="pagination-limits"><a class="header" href="#pagination-limits">Pagination Limits</a></h3>
<p>Prevents denial-of-service via large queries:</p>
<pre><code class="language-rust">// Built-in limits
const MAX_PAGE_SIZE: u64 = 1000;
const MAX_OFFSET: u64 = 1_000_000;

// Even if user requests 10000 items, only 1000 returned</code></pre>
<h3 id="overflow-protection"><a class="header" href="#overflow-protection">Overflow Protection</a></h3>
<p>Pagination calculations use saturating arithmetic to prevent integer overflow panics:</p>
<pre><code class="language-rust">// Malicious request: page=18446744073709551615&amp;per_page=18446744073709551615
// Would normally cause: panic on integer overflow

// CRUDCrate uses saturating arithmetic:
let offset = (page.saturating_sub(1)).saturating_mul(safe_per_page);
// Result: Returns max safe values instead of panicking</code></pre>
<h3 id="field-value-length-limits"><a class="header" href="#field-value-length-limits">Field Value Length Limits</a></h3>
<p>Protects against memory exhaustion from oversized filter values:</p>
<pre><code class="language-rust">// Built-in limit
const MAX_FIELD_VALUE_LENGTH: usize = 10_000;  // 10KB max per field

// User provides: {"name": "A".repeat(1_000_000)}
// Result: Value truncated or rejected, not processed</code></pre>
<h3 id="fulltext-search-query-limits"><a class="header" href="#fulltext-search-query-limits">Fulltext Search Query Limits</a></h3>
<p>Prevents oversized search queries from consuming resources:</p>
<pre><code class="language-rust">// Built-in limit
const MAX_SEARCH_QUERY_LENGTH: usize = 10_000;  // 10KB max

// User provides: {"q": "A".repeat(1_000_000)}
// Result: Query truncated to 10KB before processing</code></pre>
<h3 id="header-injection-prevention"><a class="header" href="#header-injection-prevention">Header Injection Prevention</a></h3>
<p>Sanitizes resource names to prevent HTTP header injection attacks:</p>
<pre><code class="language-rust">// Malicious resource name: "items\r\nInjected-Header: evil"
// Could inject headers into Content-Range response

// CRUDCrate sanitizes:
fn sanitize_resource_name(name: &amp;str) -&gt; String {
    name.chars()
        .filter(|c| c.is_ascii() &amp;&amp; !c.is_ascii_control())
        .collect()
}
// Result: Control characters stripped, header injection prevented</code></pre>
<h3 id="like-wildcard-escaping"><a class="header" href="#like-wildcard-escaping">LIKE Wildcard Escaping</a></h3>
<p>Prevents wildcard injection in search queries:</p>
<pre><code class="language-rust">// User provides: {"name": "%admin%"}
// Without escaping: matches ALL records containing "admin"

// CRUDCrate escapes wildcards:
// % → \%
// _ → \_
// Result: Literal search for "%admin%" string</code></pre>
<h3 id="batch-operation-limits"><a class="header" href="#batch-operation-limits">Batch Operation Limits</a></h3>
<pre><code class="language-rust">// Bulk delete limited to 100 items
async fn delete_many(ids: Vec&lt;Uuid&gt;) -&gt; Result&lt;u64, ApiError&gt; {
    if ids.len() &gt; 100 {
        return Err(ApiError::BadRequest("Cannot delete more than 100 items".into()));
    }
    // ...
}</code></pre>
<h3 id="error-sanitization"><a class="header" href="#error-sanitization">Error Sanitization</a></h3>
<p>Internal errors are logged but not exposed:</p>
<pre><code class="language-rust">// Internal: "SQLSTATE[42P01]: Undefined table: 7 ERROR: relation \"users\" does not exist"
// Response: "Database error"</code></pre>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>CRUDCrate doesn’t include authentication - use Axum middleware:</p>
<h3 id="jwt-authentication"><a class="header" href="#jwt-authentication">JWT Authentication</a></h3>
<pre><code class="language-rust">use axum::{
    middleware,
    http::{Request, StatusCode},
    response::Response,
    extract::State,
};
use jsonwebtoken::{decode, Validation, DecodingKey};

#[derive(Clone)]
pub struct AuthState {
    pub jwt_secret: String,
}

async fn auth_middleware&lt;B&gt;(
    State(state): State&lt;AuthState&gt;,
    mut request: Request&lt;B&gt;,
    next: middleware::Next&lt;B&gt;,
) -&gt; Result&lt;Response, StatusCode&gt; {
    let auth_header = request.headers()
        .get("Authorization")
        .and_then(|h| h.to_str().ok())
        .ok_or(StatusCode::UNAUTHORIZED)?;

    let token = auth_header
        .strip_prefix("Bearer ")
        .ok_or(StatusCode::UNAUTHORIZED)?;

    let token_data = decode::&lt;Claims&gt;(
        token,
        &amp;DecodingKey::from_secret(state.jwt_secret.as_bytes()),
        &amp;Validation::default()
    ).map_err(|_| StatusCode::UNAUTHORIZED)?;

    // Add user to request extensions
    request.extensions_mut().insert(token_data.claims.user_id);

    Ok(next.run(request).await)
}

// Apply to routes
let app = Router::new()
    .merge(protected_router())
    .layer(middleware::from_fn_with_state(auth_state, auth_middleware));</code></pre>
<h3 id="api-key-authentication"><a class="header" href="#api-key-authentication">API Key Authentication</a></h3>
<pre><code class="language-rust">async fn api_key_middleware&lt;B&gt;(
    State(valid_keys): State&lt;HashSet&lt;String&gt;&gt;,
    request: Request&lt;B&gt;,
    next: middleware::Next&lt;B&gt;,
) -&gt; Result&lt;Response, StatusCode&gt; {
    let api_key = request.headers()
        .get("X-API-Key")
        .and_then(|h| h.to_str().ok())
        .ok_or(StatusCode::UNAUTHORIZED)?;

    if !valid_keys.contains(api_key) {
        return Err(StatusCode::UNAUTHORIZED);
    }

    Ok(next.run(request).await)
}</code></pre>
<h2 id="authorization-1"><a class="header" href="#authorization-1">Authorization</a></h2>
<h3 id="row-level-security-2"><a class="header" href="#row-level-security-2">Row-Level Security</a></h3>
<p>Use <code>before_get_all</code> to filter results:</p>
<pre><code class="language-rust">impl CRUDOperations for ArticleOperations {
    async fn before_get_all(
        &amp;self,
        _db: &amp;DatabaseConnection,
        condition: &amp;mut Condition,
    ) -&gt; Result&lt;(), ApiError&gt; {
        let user = get_current_user();

        if !user.is_admin {
            // Users only see their own articles
            *condition = condition.clone().add(Column::AuthorId.eq(user.id));
        }

        Ok(())
    }
}</code></pre>
<h3 id="operation-level-authorization"><a class="header" href="#operation-level-authorization">Operation-Level Authorization</a></h3>
<pre><code class="language-rust">impl CRUDOperations for ArticleOperations {
    async fn before_update(
        &amp;self,
        db: &amp;DatabaseConnection,
        id: Uuid,
        _data: &amp;mut ArticleUpdate,
    ) -&gt; Result&lt;(), ApiError&gt; {
        let user = get_current_user();
        let article = Entity::find_by_id(id).one(db).await?.ok_or(ApiError::NotFound)?;

        // Only author or admin can edit
        if article.author_id != user.id &amp;&amp; !user.is_admin {
            return Err(ApiError::Forbidden);
        }

        Ok(())
    }

    async fn before_delete(
        &amp;self,
        db: &amp;DatabaseConnection,
        id: Uuid,
    ) -&gt; Result&lt;(), ApiError&gt; {
        let user = get_current_user();

        // Only admins can delete
        if !user.is_admin {
            return Err(ApiError::Forbidden);
        }

        Ok(())
    }
}</code></pre>
<h3 id="role-based-access-control"><a class="header" href="#role-based-access-control">Role-Based Access Control</a></h3>
<pre><code class="language-rust">#[derive(Clone, Copy, PartialEq)]
pub enum Role {
    User,
    Moderator,
    Admin,
}

fn require_role(user: &amp;User, required: Role) -&gt; Result&lt;(), ApiError&gt; {
    let user_level = match user.role {
        Role::Admin =&gt; 3,
        Role::Moderator =&gt; 2,
        Role::User =&gt; 1,
    };

    let required_level = match required {
        Role::Admin =&gt; 3,
        Role::Moderator =&gt; 2,
        Role::User =&gt; 1,
    };

    if user_level &gt;= required_level {
        Ok(())
    } else {
        Err(ApiError::Forbidden)
    }
}</code></pre>
<h2 id="input-validation-2"><a class="header" href="#input-validation-2">Input Validation</a></h2>
<h3 id="sanitize-user-input"><a class="header" href="#sanitize-user-input">Sanitize User Input</a></h3>
<pre><code class="language-rust">async fn before_create(
    &amp;self,
    _db: &amp;DatabaseConnection,
    data: &amp;mut ArticleCreate,
) -&gt; Result&lt;(), ApiError&gt; {
    // Trim whitespace
    data.title = data.title.trim().to_string();

    // Sanitize HTML (if allowing rich text)
    data.content = ammonia::clean(&amp;data.content);

    // Validate length
    if data.title.len() &gt; 200 {
        return Err(ApiError::ValidationFailed(vec![
            ValidationError::new("title", "Title too long (max 200 characters)")
        ]));
    }

    Ok(())
}</code></pre>
<h3 id="prevent-mass-assignment"><a class="header" href="#prevent-mass-assignment">Prevent Mass Assignment</a></h3>
<p>Only allow specific fields to be updated:</p>
<pre><code class="language-rust">async fn before_update(
    &amp;self,
    _db: &amp;DatabaseConnection,
    _id: Uuid,
    data: &amp;mut UserUpdate,
) -&gt; Result&lt;(), ApiError&gt; {
    // Prevent updating sensitive fields via API
    data.is_admin = None;
    data.email_verified = None;
    data.password_reset_token = None;

    Ok(())
}</code></pre>
<h2 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h2>
<p>Use tower middleware:</p>
<pre><code class="language-rust">use tower_governor::{GovernorLayer, GovernorConfig};

let governor_conf = GovernorConfig::default();

let app = Router::new()
    .merge(api_router())
    .layer(GovernorLayer {
        config: &amp;governor_conf,
    });</code></pre>
<p>Or custom rate limiting:</p>
<pre><code class="language-rust">use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;

struct RateLimiter {
    requests: HashMap&lt;String, (u32, Instant)&gt;,
    max_requests: u32,
    window: Duration,
}

async fn rate_limit_middleware&lt;B&gt;(
    State(limiter): State&lt;Arc&lt;Mutex&lt;RateLimiter&gt;&gt;&gt;,
    request: Request&lt;B&gt;,
    next: middleware::Next&lt;B&gt;,
) -&gt; Result&lt;Response, StatusCode&gt; {
    let ip = request.headers()
        .get("X-Forwarded-For")
        .and_then(|h| h.to_str().ok())
        .unwrap_or("unknown")
        .to_string();

    let mut limiter = limiter.lock().await;

    let (count, start) = limiter.requests
        .entry(ip.clone())
        .or_insert((0, Instant::now()));

    if start.elapsed() &gt; limiter.window {
        *count = 0;
        *start = Instant::now();
    }

    *count += 1;

    if *count &gt; limiter.max_requests {
        return Err(StatusCode::TOO_MANY_REQUESTS);
    }

    drop(limiter);
    Ok(next.run(request).await)
}</code></pre>
<h2 id="cors-configuration"><a class="header" href="#cors-configuration">CORS Configuration</a></h2>
<pre><code class="language-rust">use tower_http::cors::{CorsLayer, Any};

// Development (permissive)
let cors = CorsLayer::permissive();

// Production (restrictive)
let cors = CorsLayer::new()
    .allow_origin("https://yourdomain.com".parse::&lt;HeaderValue&gt;().unwrap())
    .allow_methods([Method::GET, Method::POST, Method::PUT, Method::DELETE])
    .allow_headers([header::CONTENT_TYPE, header::AUTHORIZATION])
    .max_age(Duration::from_secs(3600));

let app = Router::new()
    .merge(api_router())
    .layer(cors);</code></pre>
<h2 id="https"><a class="header" href="#https">HTTPS</a></h2>
<p>Always use HTTPS in production:</p>
<pre><code class="language-rust">// In production, terminate TLS at load balancer/reverse proxy
// Or use rustls for direct TLS:

use axum_server::tls_rustls::RustlsConfig;

let config = RustlsConfig::from_pem_file("cert.pem", "key.pem").await?;

axum_server::bind_rustls(addr, config)
    .serve(app.into_make_service())
    .await?;</code></pre>
<h2 id="security-headers"><a class="header" href="#security-headers">Security Headers</a></h2>
<pre><code class="language-rust">use tower_http::set_header::SetResponseHeaderLayer;
use axum::http::header;

let app = Router::new()
    .merge(api_router())
    .layer(SetResponseHeaderLayer::if_not_present(
        header::X_CONTENT_TYPE_OPTIONS,
        HeaderValue::from_static("nosniff")
    ))
    .layer(SetResponseHeaderLayer::if_not_present(
        header::X_FRAME_OPTIONS,
        HeaderValue::from_static("DENY")
    ))
    .layer(SetResponseHeaderLayer::if_not_present(
        header::STRICT_TRANSPORT_SECURITY,
        HeaderValue::from_static("max-age=31536000; includeSubDomains")
    ));</code></pre>
<h2 id="logging-and-monitoring"><a class="header" href="#logging-and-monitoring">Logging and Monitoring</a></h2>
<pre><code class="language-rust">use tracing::{info, warn, error, instrument};

impl CRUDOperations for ArticleOperations {
    #[instrument(skip(self, db))]
    async fn before_delete(
        &amp;self,
        db: &amp;DatabaseConnection,
        id: Uuid,
    ) -&gt; Result&lt;(), ApiError&gt; {
        let user = get_current_user();

        info!(
            user_id = %user.id,
            article_id = %id,
            "User attempting to delete article"
        );

        // Authorization check
        let article = Entity::find_by_id(id).one(db).await?;

        if article.is_none() {
            warn!(article_id = %id, "Attempted to delete non-existent article");
            return Err(ApiError::NotFound);
        }

        if !user.is_admin {
            warn!(
                user_id = %user.id,
                article_id = %id,
                "Unauthorized delete attempt"
            );
            return Err(ApiError::Forbidden);
        }

        Ok(())
    }
}</code></pre>
<h2 id="security-checklist"><a class="header" href="#security-checklist">Security Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"> All routes require authentication (where needed)</li>
<li><input disabled="" type="checkbox"> Authorization checks on all mutations</li>
<li><input disabled="" type="checkbox"> Input validation on all user data</li>
<li><input disabled="" type="checkbox"> Rate limiting configured</li>
<li><input disabled="" type="checkbox"> CORS restricted to allowed origins</li>
<li><input disabled="" type="checkbox"> HTTPS enabled in production</li>
<li><input disabled="" type="checkbox"> Security headers set</li>
<li><input disabled="" type="checkbox"> Sensitive fields excluded from responses</li>
<li><input disabled="" type="checkbox"> Logging enabled for security events</li>
<li><input disabled="" type="checkbox"> Database credentials not in code</li>
<li><input disabled="" type="checkbox"> Dependencies updated regularly</li>
</ul>
<h2 id="next-steps-19"><a class="header" href="#next-steps-19">Next Steps</a></h2>
<ul>
<li>Learn about <a href="#performance-optimization">Performance Optimization</a></li>
<li>Configure <a href="#multi-database-support">Multi-Database Support</a></li>
<li>Set up <a href="#custom-operations">Custom Operations</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h1>
<p>Optimize your CRUDCrate API for production workloads.</p>
<h2 id="database-indexing"><a class="header" href="#database-indexing">Database Indexing</a></h2>
<h3 id="index-filtered-fields"><a class="header" href="#index-filtered-fields">Index Filtered Fields</a></h3>
<pre><code class="language-sql">-- Single column indexes for filterable fields
CREATE INDEX idx_articles_status ON articles(status);
CREATE INDEX idx_articles_author_id ON articles(author_id);
CREATE INDEX idx_articles_created_at ON articles(created_at);

-- Composite index for common filter combinations
CREATE INDEX idx_articles_status_created ON articles(status, created_at DESC);
</code></pre>
<h3 id="index-sorted-fields-1"><a class="header" href="#index-sorted-fields-1">Index Sorted Fields</a></h3>
<pre><code class="language-sql">-- DESC index for newest-first queries
CREATE INDEX idx_articles_created_at_desc ON articles(created_at DESC);

-- Composite for filter + sort
CREATE INDEX idx_articles_author_created ON articles(author_id, created_at DESC);
</code></pre>
<h3 id="fulltext-indexes"><a class="header" href="#fulltext-indexes">Fulltext Indexes</a></h3>
<pre><code class="language-sql">-- PostgreSQL GIN index
CREATE INDEX idx_articles_search ON articles USING GIN(
    to_tsvector('english', coalesce(title, '') || ' ' || coalesce(content, ''))
);

-- MySQL FULLTEXT index
ALTER TABLE articles ADD FULLTEXT INDEX idx_articles_fulltext (title, content);
</code></pre>
<h2 id="query-optimization-1"><a class="header" href="#query-optimization-1">Query Optimization</a></h2>
<h3 id="use-selective-filters"><a class="header" href="#use-selective-filters">Use Selective Filters</a></h3>
<pre><code class="language-bash"># ❌ Full table scan
GET /articles

# ✅ Filtered query uses index
GET /articles?filter={"status":"published"}
</code></pre>
<h3 id="limit-result-size"><a class="header" href="#limit-result-size">Limit Result Size</a></h3>
<pre><code class="language-bash"># ✅ Always paginate
GET /articles?range=[0,19]

# Built-in limit: max 1000 items per request
</code></pre>
<h3 id="avoid-deep-joins"><a class="header" href="#avoid-deep-joins">Avoid Deep Joins</a></h3>
<pre><code class="language-rust">// ❌ Deep recursion
#[crudcrate(non_db_attr, join(one, all, depth = 10))]
pub comments: Vec&lt;Comment&gt;,

// ✅ Limited depth
#[crudcrate(non_db_attr, join(one, depth = 2))]
pub comments: Vec&lt;Comment&gt;,</code></pre>
<h2 id="connection-pooling"><a class="header" href="#connection-pooling">Connection Pooling</a></h2>
<p>Configure Sea-ORM connection pool:</p>
<pre><code class="language-rust">use sea_orm::{Database, ConnectOptions};

let mut opt = ConnectOptions::new(database_url);
opt.max_connections(100)
   .min_connections(5)
   .connect_timeout(Duration::from_secs(8))
   .acquire_timeout(Duration::from_secs(8))
   .idle_timeout(Duration::from_secs(8))
   .max_lifetime(Duration::from_secs(8))
   .sqlx_logging(false);  // Disable query logging in production

let db = Database::connect(opt).await?;</code></pre>
<h2 id="caching-strategies"><a class="header" href="#caching-strategies">Caching Strategies</a></h2>
<h3 id="response-caching"><a class="header" href="#response-caching">Response Caching</a></h3>
<pre><code class="language-rust">use axum::http::header;
use tower_http::set_header::SetResponseHeaderLayer;

// Cache static-ish data
let app = Router::new()
    .route("/categories", get(list_categories))
    .layer(SetResponseHeaderLayer::if_not_present(
        header::CACHE_CONTROL,
        HeaderValue::from_static("public, max-age=300")  // 5 minutes
    ));</code></pre>
<h3 id="query-caching-with-redis"><a class="header" href="#query-caching-with-redis">Query Caching with Redis</a></h3>
<pre><code class="language-rust">use redis::AsyncCommands;

async fn get_articles_cached(
    db: &amp;DatabaseConnection,
    redis: &amp;redis::Client,
    filter: &amp;FilterOptions,
) -&gt; Result&lt;Vec&lt;Article&gt;, ApiError&gt; {
    let cache_key = format!("articles:{}", hash_filter(filter));

    // Try cache first
    if let Ok(mut conn) = redis.get_async_connection().await {
        if let Ok(cached) = conn.get::&lt;_, String&gt;(&amp;cache_key).await {
            if let Ok(articles) = serde_json::from_str(&amp;cached) {
                return Ok(articles);
            }
        }
    }

    // Cache miss - query database
    let articles = Article::get_all(db, /* ... */).await?;

    // Store in cache
    if let Ok(mut conn) = redis.get_async_connection().await {
        let _ = conn.set_ex::&lt;_, _, ()&gt;(
            &amp;cache_key,
            serde_json::to_string(&amp;articles).unwrap(),
            300  // 5 minute TTL
        ).await;
    }

    Ok(articles)
}</code></pre>
<h3 id="count-caching"><a class="header" href="#count-caching">Count Caching</a></h3>
<p>Counting large tables is expensive:</p>
<pre><code class="language-rust">// Cache total counts
async fn get_total_count_cached(
    db: &amp;DatabaseConnection,
    redis: &amp;redis::Client,
    entity: &amp;str,
) -&gt; u64 {
    let cache_key = format!("count:{}", entity);

    if let Ok(mut conn) = redis.get_async_connection().await {
        if let Ok(count) = conn.get::&lt;_, u64&gt;(&amp;cache_key).await {
            return count;
        }
    }

    // Cache miss
    let count = Entity::find().count(db).await.unwrap_or(0);

    // Cache for 60 seconds
    if let Ok(mut conn) = redis.get_async_connection().await {
        let _ = conn.set_ex::&lt;_, _, ()&gt;(&amp;cache_key, count, 60).await;
    }

    count
}</code></pre>
<h2 id="pagination-optimization"><a class="header" href="#pagination-optimization">Pagination Optimization</a></h2>
<h3 id="keyset-pagination"><a class="header" href="#keyset-pagination">Keyset Pagination</a></h3>
<p>For large datasets, use cursor-based pagination:</p>
<pre><code class="language-rust">// Instead of OFFSET (slow for large values)
// Use WHERE id &gt; last_id (fast with index)

async fn list_articles_keyset(
    db: &amp;DatabaseConnection,
    after_id: Option&lt;Uuid&gt;,
    limit: u64,
) -&gt; Result&lt;Vec&lt;Article&gt;, ApiError&gt; {
    let mut query = Entity::find()
        .order_by(Column::Id, Order::Asc);

    if let Some(id) = after_id {
        query = query.filter(Column::Id.gt(id));
    }

    let articles = query
        .limit(limit)
        .all(db)
        .await?;

    Ok(articles.into_iter().map(Into::into).collect())
}</code></pre>
<h3 id="skip-count-for-infinite-scroll"><a class="header" href="#skip-count-for-infinite-scroll">Skip Count for Infinite Scroll</a></h3>
<pre><code class="language-rust">async fn list_articles_no_count(
    db: &amp;DatabaseConnection,
    offset: u64,
    limit: u64,
) -&gt; Result&lt;(Vec&lt;Article&gt;, bool), ApiError&gt; {
    // Fetch one extra to check for more
    let articles = Entity::find()
        .offset(offset)
        .limit(limit + 1)
        .all(db)
        .await?;

    let has_more = articles.len() &gt; limit as usize;
    let articles: Vec&lt;Article&gt; = articles
        .into_iter()
        .take(limit as usize)
        .map(Into::into)
        .collect();

    Ok((articles, has_more))
}</code></pre>
<h2 id="list-optimization"><a class="header" href="#list-optimization">List Optimization</a></h2>
<h3 id="exclude-heavy-fields-from-lists"><a class="header" href="#exclude-heavy-fields-from-lists">Exclude Heavy Fields from Lists</a></h3>
<pre><code class="language-rust">// Full content not needed in lists
#[crudcrate(exclude(list))]
pub content: String,

// Relationships only in detail view
#[crudcrate(non_db_attr, join(one))]  // NOT join(all)
pub comments: Vec&lt;Comment&gt;,</code></pre>
<h3 id="select-only-needed-columns"><a class="header" href="#select-only-needed-columns">Select Only Needed Columns</a></h3>
<pre><code class="language-rust">// Custom list handler with column selection
async fn list_articles_optimized(
    Query(params): Query&lt;FilterOptions&gt;,
    Extension(db): Extension&lt;DatabaseConnection&gt;,
) -&gt; Result&lt;Json&lt;Vec&lt;ArticleListItem&gt;&gt;, ApiError&gt; {
    let articles = Entity::find()
        .select_only()
        .column(Column::Id)
        .column(Column::Title)
        .column(Column::Excerpt)
        .column(Column::CreatedAt)
        // Omit content, relationships
        .into_model::&lt;ArticleListItem&gt;()
        .all(&amp;db)
        .await?;

    Ok(Json(articles))
}</code></pre>
<h2 id="async-best-practices"><a class="header" href="#async-best-practices">Async Best Practices</a></h2>
<h3 id="batch-database-operations"><a class="header" href="#batch-database-operations">Batch Database Operations</a></h3>
<pre><code class="language-rust">// ❌ Sequential queries
for id in ids {
    let item = Entity::find_by_id(id).one(db).await?;
    results.push(item);
}

// ✅ Batch query
let items = Entity::find()
    .filter(Column::Id.is_in(ids))
    .all(db)
    .await?;</code></pre>
<h3 id="parallel-independent-queries"><a class="header" href="#parallel-independent-queries">Parallel Independent Queries</a></h3>
<pre><code class="language-rust">use tokio::join;

async fn get_article_with_stats(
    db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;ArticleWithStats, ApiError&gt; {
    // Run queries in parallel
    let (article, comment_count, view_count) = join!(
        Entity::find_by_id(id).one(db),
        comment::Entity::find().filter(comment::Column::ArticleId.eq(id)).count(db),
        get_view_count(id),
    );

    let article = article?.ok_or(ApiError::NotFound)?;

    Ok(ArticleWithStats {
        article: article.into(),
        comment_count: comment_count?,
        view_count: view_count?,
    })
}</code></pre>
<h2 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h2>
<h3 id="query-logging"><a class="header" href="#query-logging">Query Logging</a></h3>
<pre><code class="language-rust">// Enable in development
let mut opt = ConnectOptions::new(database_url);
opt.sqlx_logging(true)
   .sqlx_logging_level(tracing::log::LevelFilter::Debug);</code></pre>
<h3 id="slow-query-detection"><a class="header" href="#slow-query-detection">Slow Query Detection</a></h3>
<pre><code class="language-rust">use tracing::{info, warn};
use std::time::Instant;

async fn timed_query&lt;T, F, Fut&gt;(name: &amp;str, f: F) -&gt; T
where
    F: FnOnce() -&gt; Fut,
    Fut: std::future::Future&lt;Output = T&gt;,
{
    let start = Instant::now();
    let result = f().await;
    let elapsed = start.elapsed();

    if elapsed &gt; Duration::from_millis(100) {
        warn!(query = name, elapsed_ms = elapsed.as_millis(), "Slow query");
    } else {
        info!(query = name, elapsed_ms = elapsed.as_millis(), "Query completed");
    }

    result
}</code></pre>
<h2 id="performance-checklist"><a class="header" href="#performance-checklist">Performance Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"> Indexes on all filtered columns</li>
<li><input disabled="" type="checkbox"> Indexes on all sorted columns</li>
<li><input disabled="" type="checkbox"> Composite indexes for common query patterns</li>
<li><input disabled="" type="checkbox"> Fulltext indexes for search fields</li>
<li><input disabled="" type="checkbox"> Connection pool properly sized</li>
<li><input disabled="" type="checkbox"> Pagination enforced</li>
<li><input disabled="" type="checkbox"> Heavy fields excluded from lists</li>
<li><input disabled="" type="checkbox"> Join depth limited</li>
<li><input disabled="" type="checkbox"> Query caching for hot paths</li>
<li><input disabled="" type="checkbox"> Count caching for large tables</li>
<li><input disabled="" type="checkbox"> Query logging enabled (dev) / disabled (prod)</li>
<li><input disabled="" type="checkbox"> Slow query monitoring</li>
</ul>
<h2 id="next-steps-20"><a class="header" href="#next-steps-20">Next Steps</a></h2>
<ul>
<li>Configure <a href="#multi-database-support">Multi-Database Support</a></li>
<li>Set up <a href="#security-best-practices">Security</a></li>
<li>Learn about <a href="#custom-operations">Custom Operations</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="multi-database-support"><a class="header" href="#multi-database-support">Multi-Database Support</a></h1>
<p>CRUDCrate works with PostgreSQL, MySQL, and SQLite, with database-specific optimizations.</p>
<h2 id="supported-databases"><a class="header" href="#supported-databases">Supported Databases</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Database</th><th>Support Level</th><th>Fulltext Search</th><th>Best For</th></tr>
</thead>
<tbody>
<tr><td><strong>PostgreSQL</strong></td><td>✅ Full</td><td>GIN + tsvector</td><td>Complex queries, high concurrency</td></tr>
<tr><td><strong>MySQL</strong></td><td>✅ Full</td><td>FULLTEXT index</td><td>Traditional deployments</td></tr>
<tr><td><strong>SQLite</strong></td><td>✅ Full</td><td>LIKE fallback</td><td>Development, embedded apps</td></tr>
</tbody>
</table>
</div>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<h3 id="postgresql"><a class="header" href="#postgresql">PostgreSQL</a></h3>
<pre><code class="language-toml">[dependencies]
sea-orm = { version = "1.0", features = ["runtime-tokio-rustls", "sqlx-postgres"] }
</code></pre>
<pre><code class="language-rust">let db = Database::connect("postgres://user:pass@localhost/mydb").await?;</code></pre>
<p><strong>Optimizations:</strong></p>
<ul>
<li>GIN indexes for fulltext</li>
<li><code>tsvector</code> query optimization</li>
<li>Array operations for <code>IN</code> clauses</li>
</ul>
<h3 id="mysql-1"><a class="header" href="#mysql-1">MySQL</a></h3>
<pre><code class="language-toml">[dependencies]
sea-orm = { version = "1.0", features = ["runtime-tokio-rustls", "sqlx-mysql"] }
</code></pre>
<pre><code class="language-rust">let db = Database::connect("mysql://user:pass@localhost/mydb").await?;</code></pre>
<p><strong>Optimizations:</strong></p>
<ul>
<li>FULLTEXT indexes</li>
<li><code>MATCH AGAINST</code> queries</li>
<li>Optimized <code>LIKE</code> patterns</li>
</ul>
<h3 id="sqlite-1"><a class="header" href="#sqlite-1">SQLite</a></h3>
<pre><code class="language-toml">[dependencies]
sea-orm = { version = "1.0", features = ["runtime-tokio-rustls", "sqlx-sqlite"] }
</code></pre>
<pre><code class="language-rust">// File-based
let db = Database::connect("sqlite:./data.db").await?;

// In-memory (for testing)
let db = Database::connect("sqlite::memory:").await?;</code></pre>
<p><strong>Limitations:</strong></p>
<ul>
<li>No native fulltext (uses LIKE)</li>
<li>Single-writer limitation</li>
<li>Limited concurrent access</li>
</ul>
<h2 id="database-specific-features"><a class="header" href="#database-specific-features">Database-Specific Features</a></h2>
<h3 id="fulltext-search-1"><a class="header" href="#fulltext-search-1">Fulltext Search</a></h3>
<p>PostgreSQL (recommended):</p>
<pre><code class="language-sql">-- Create tsvector column and index
ALTER TABLE articles ADD COLUMN search_vector tsvector;

CREATE INDEX idx_articles_search ON articles
    USING GIN(search_vector);

-- Update trigger
CREATE FUNCTION articles_search_trigger() RETURNS trigger AS $$
BEGIN
    NEW.search_vector :=
        setweight(to_tsvector('english', coalesce(NEW.title, '')), 'A') ||
        setweight(to_tsvector('english', coalesce(NEW.content, '')), 'B');
    RETURN NEW;
END $$ LANGUAGE plpgsql;

CREATE TRIGGER articles_search_update
    BEFORE INSERT OR UPDATE ON articles
    FOR EACH ROW
    EXECUTE FUNCTION articles_search_trigger();
</code></pre>
<p>MySQL:</p>
<pre><code class="language-sql">ALTER TABLE articles
    ADD FULLTEXT INDEX idx_articles_fulltext (title, content);
</code></pre>
<p>SQLite:</p>
<pre><code class="language-sql">-- For better fulltext, use FTS5
CREATE VIRTUAL TABLE articles_fts USING fts5(
    title, content, content=articles, content_rowid=id
);
</code></pre>
<h3 id="json-types-1"><a class="header" href="#json-types-1">JSON Types</a></h3>
<p>PostgreSQL has native JSONB:</p>
<pre><code class="language-rust">use sea_orm::prelude::Json;

pub metadata: Json,  // Uses JSONB in PostgreSQL</code></pre>
<p>MySQL uses JSON type:</p>
<pre><code class="language-rust">pub metadata: Json,  // Uses JSON in MySQL</code></pre>
<p>SQLite stores as TEXT:</p>
<pre><code class="language-rust">pub metadata: String,  // Store JSON as string, parse in application</code></pre>
<h3 id="uuid-types"><a class="header" href="#uuid-types">UUID Types</a></h3>
<p>PostgreSQL has native UUID:</p>
<pre><code class="language-rust">use uuid::Uuid;

#[sea_orm(primary_key, column_type = "Uuid")]
pub id: Uuid,</code></pre>
<p>MySQL/SQLite store as CHAR(36) or BINARY(16):</p>
<pre><code class="language-rust">#[sea_orm(primary_key, column_type = "String(StringLen::N(36))")]
pub id: Uuid,</code></pre>
<h2 id="migration-strategy"><a class="header" href="#migration-strategy">Migration Strategy</a></h2>
<h3 id="development--production"><a class="header" href="#development--production">Development → Production</a></h3>
<ol>
<li>Develop with SQLite</li>
<li>Test with PostgreSQL locally</li>
<li>Deploy to PostgreSQL in production</li>
</ol>
<pre><code class="language-rust">fn get_database_url() -&gt; String {
    match std::env::var("RUST_ENV").as_deref() {
        Ok("production") =&gt; std::env::var("DATABASE_URL").unwrap(),
        _ =&gt; "sqlite::memory:".to_string(),
    }
}</code></pre>
<h3 id="database-detection"><a class="header" href="#database-detection">Database Detection</a></h3>
<pre><code class="language-rust">use sea_orm::DatabaseBackend;

fn get_backend(db: &amp;DatabaseConnection) -&gt; DatabaseBackend {
    db.get_database_backend()
}

// Use in queries
match db.get_database_backend() {
    DatabaseBackend::Postgres =&gt; {
        // PostgreSQL-specific query
    },
    DatabaseBackend::MySql =&gt; {
        // MySQL-specific query
    },
    DatabaseBackend::Sqlite =&gt; {
        // SQLite-specific query
    },
}</code></pre>
<h2 id="connection-strings"><a class="header" href="#connection-strings">Connection Strings</a></h2>
<h3 id="postgresql-1"><a class="header" href="#postgresql-1">PostgreSQL</a></h3>
<pre><code># Basic
postgres://user:password@host:5432/database

# With SSL
postgres://user:password@host:5432/database?sslmode=require

# With connection pool settings
postgres://user:password@host:5432/database?pool_max=10
</code></pre>
<h3 id="mysql-1-1"><a class="header" href="#mysql-1-1">MySQL</a></h3>
<pre><code># Basic
mysql://user:password@host:3306/database

# With charset
mysql://user:password@host:3306/database?charset=utf8mb4
</code></pre>
<h3 id="sqlite-1-1"><a class="header" href="#sqlite-1-1">SQLite</a></h3>
<pre><code># File
sqlite:./path/to/database.db

# In-memory
sqlite::memory:

# In-memory with shared cache
sqlite:file::memory:?cache=shared
</code></pre>
<h2 id="testing-across-databases"><a class="header" href="#testing-across-databases">Testing Across Databases</a></h2>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use sea_orm::Database;

    async fn setup_test_db() -&gt; DatabaseConnection {
        // Use SQLite for fast tests
        let db = Database::connect("sqlite::memory:").await.unwrap();

        // Run migrations
        Migrator::up(&amp;db, None).await.unwrap();

        db
    }

    #[tokio::test]
    async fn test_create_article() {
        let db = setup_test_db().await;
        // Test code using SQLite
    }
}

// Integration tests with real database
#[cfg(test)]
mod integration_tests {
    #[tokio::test]
    #[ignore] // Run with: cargo test -- --ignored
    async fn test_postgres_specific() {
        let db = Database::connect(&amp;std::env::var("TEST_DATABASE_URL").unwrap())
            .await
            .unwrap();
        // PostgreSQL-specific tests
    }
}</code></pre>
<h2 id="performance-by-database"><a class="header" href="#performance-by-database">Performance by Database</a></h2>
<h3 id="postgresql-strengths"><a class="header" href="#postgresql-strengths">PostgreSQL Strengths</a></h3>
<ul>
<li>Excellent for complex queries</li>
<li>Best fulltext search</li>
<li>JSONB operations</li>
<li>Concurrent access</li>
<li>Advanced indexing (GIN, BRIN, partial)</li>
</ul>
<h3 id="mysql-strengths"><a class="header" href="#mysql-strengths">MySQL Strengths</a></h3>
<ul>
<li>Widely deployed</li>
<li>Good FULLTEXT support</li>
<li>Simpler replication</li>
<li>Broad hosting support</li>
</ul>
<h3 id="sqlite-strengths"><a class="header" href="#sqlite-strengths">SQLite Strengths</a></h3>
<ul>
<li>Zero configuration</li>
<li>Embedded deployment</li>
<li>Fast for small datasets</li>
<li>Perfect for testing</li>
</ul>
<h2 id="recommendations"><a class="header" href="#recommendations">Recommendations</a></h2>
<h3 id="for-production"><a class="header" href="#for-production">For Production</a></h3>
<p><strong>PostgreSQL</strong> is recommended for:</p>
<ul>
<li>Complex filtering</li>
<li>Fulltext search</li>
<li>JSON data</li>
<li>High concurrency</li>
</ul>
<h3 id="for-development"><a class="header" href="#for-development">For Development</a></h3>
<p><strong>SQLite</strong> is recommended for:</p>
<ul>
<li>Quick setup</li>
<li>Unit tests</li>
<li>Local development</li>
<li>Prototyping</li>
</ul>
<h3 id="migration-path-1"><a class="header" href="#migration-path-1">Migration Path</a></h3>
<pre><code>Development: SQLite (fast, easy setup)
    ↓
Staging: PostgreSQL (production-like)
    ↓
Production: PostgreSQL (optimized)
</code></pre>
<h2 id="next-steps-21"><a class="header" href="#next-steps-21">Next Steps</a></h2>
<ul>
<li>Set up <a href="#security-best-practices">Security</a></li>
<li>Configure <a href="#performance-optimization">Performance Optimization</a></li>
<li>Learn about <a href="#custom-operations">Custom Operations</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="struct-attributes-reference"><a class="header" href="#struct-attributes-reference">Struct Attributes Reference</a></h1>
<p>Complete reference for <code>#[crudcrate(...)]</code> attributes on structs.</p>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<pre><code class="language-rust">#[derive(EntityToModels)]
#[crudcrate(attribute1, attribute2 = value, ...)]
pub struct Model { }</code></pre>
<h2 id="attributes"><a class="header" href="#attributes">Attributes</a></h2>
<h3 id="generate_router-1"><a class="header" href="#generate_router-1"><code>generate_router</code></a></h3>
<p>Generates an Axum router function for all CRUD operations.</p>
<pre><code class="language-rust">#[crudcrate(generate_router)]
pub struct Model { }

// Generates:
pub fn model_router() -&gt; Router { }</code></pre>
<p><strong>Type:</strong> Flag (no value)</p>
<hr>
<h3 id="api_struct-1"><a class="header" href="#api_struct-1"><code>api_struct</code></a></h3>
<p>Override the name of generated API structs.</p>
<pre><code class="language-rust">#[crudcrate(api_struct = "Product")]
pub struct Model { }

// Generates: Product, ProductCreate, ProductUpdate, ProductList</code></pre>
<p><strong>Type:</strong> String literal
<strong>Default:</strong> Derives from table name (e.g., “products” → “Product”)</p>
<hr>
<h3 id="name_singular"><a class="header" href="#name_singular"><code>name_singular</code></a></h3>
<p>Override the singular resource name for routing and headers.</p>
<pre><code class="language-rust">#[crudcrate(name_singular = "person")]
pub struct Model { }

// Used in: Content-Range header
// Content-Range: person 0-9/100</code></pre>
<p><strong>Type:</strong> String literal
<strong>Default:</strong> Lowercase struct name</p>
<hr>
<h3 id="name_plural"><a class="header" href="#name_plural"><code>name_plural</code></a></h3>
<p>Override the plural resource name for routing.</p>
<pre><code class="language-rust">#[crudcrate(name_plural = "people")]
pub struct Model { }

// Routes: GET /people, POST /people, etc.</code></pre>
<p><strong>Type:</strong> String literal
<strong>Default:</strong> <code>{name_singular}s</code></p>
<hr>
<h3 id="operations-1"><a class="header" href="#operations-1"><code>operations</code></a></h3>
<p>Specify a custom <code>CRUDOperations</code> implementation.</p>
<pre><code class="language-rust">#[crudcrate(operations = MyOperations)]
pub struct Model { }

// MyOperations must implement CRUDOperations trait
pub struct MyOperations;

impl CRUDOperations for MyOperations {
    type Resource = Model;
    // ...
}</code></pre>
<p><strong>Type:</strong> Type path
<strong>Default:</strong> <code>DefaultCRUDOperations&lt;Self&gt;</code></p>
<hr>
<h3 id="description-1"><a class="header" href="#description-1"><code>description</code></a></h3>
<p>Add description for OpenAPI documentation.</p>
<pre><code class="language-rust">#[crudcrate(description = "Blog articles with comments")]
pub struct Model { }</code></pre>
<p><strong>Type:</strong> String literal
<strong>Default:</strong> None</p>
<hr>
<h3 id="fulltext_language-1"><a class="header" href="#fulltext_language-1"><code>fulltext_language</code></a></h3>
<p>Set language for PostgreSQL fulltext search.</p>
<pre><code class="language-rust">#[crudcrate(fulltext_language = "spanish")]
pub struct Model { }</code></pre>
<p><strong>Type:</strong> String literal
<strong>Default:</strong> <code>"english"</code>
<strong>Options:</strong> <code>"english"</code>, <code>"spanish"</code>, <code>"german"</code>, <code>"french"</code>, <code>"simple"</code>, etc.</p>
<hr>
<h2 id="lifecycle-hook-attributes"><a class="header" href="#lifecycle-hook-attributes">Lifecycle Hook Attributes</a></h2>
<h3 id="createonepre"><a class="header" href="#createonepre"><code>create::one::pre</code></a></h3>
<p>Function called before create operation.</p>
<pre><code class="language-rust">#[crudcrate(create::one::pre = validate_create)]

async fn validate_create(
    db: &amp;DatabaseConnection,
    data: &amp;mut ModelCreate,
) -&gt; Result&lt;(), ApiError&gt; { }</code></pre>
<hr>
<h3 id="createonepost"><a class="header" href="#createonepost"><code>create::one::post</code></a></h3>
<p>Function called after successful create.</p>
<pre><code class="language-rust">#[crudcrate(create::one::post = notify_created)]

async fn notify_created(
    db: &amp;DatabaseConnection,
    created: &amp;Model,
) -&gt; Result&lt;(), ApiError&gt; { }</code></pre>
<hr>
<h3 id="createonebody"><a class="header" href="#createonebody"><code>create::one::body</code></a></h3>
<p>Replace entire create logic.</p>
<pre><code class="language-rust">#[crudcrate(create::one::body = custom_create)]

async fn custom_create(
    db: &amp;DatabaseConnection,
    data: ModelCreate,
) -&gt; Result&lt;Model, ApiError&gt; { }</code></pre>
<hr>
<h3 id="updateonepre"><a class="header" href="#updateonepre"><code>update::one::pre</code></a></h3>
<p>Function called before update operation.</p>
<pre><code class="language-rust">#[crudcrate(update::one::pre = check_update_permission)]

async fn check_update_permission(
    db: &amp;DatabaseConnection,
    id: PrimaryKeyType,
    data: &amp;mut ModelUpdate,
) -&gt; Result&lt;(), ApiError&gt; { }</code></pre>
<hr>
<h3 id="updateonepost"><a class="header" href="#updateonepost"><code>update::one::post</code></a></h3>
<p>Function called after successful update.</p>
<pre><code class="language-rust">#[crudcrate(update::one::post = invalidate_cache)]

async fn invalidate_cache(
    db: &amp;DatabaseConnection,
    updated: &amp;Model,
) -&gt; Result&lt;(), ApiError&gt; { }</code></pre>
<hr>
<h3 id="updateonebody"><a class="header" href="#updateonebody"><code>update::one::body</code></a></h3>
<p>Replace entire update logic.</p>
<pre><code class="language-rust">#[crudcrate(update::one::body = custom_update)]

async fn custom_update(
    db: &amp;DatabaseConnection,
    id: PrimaryKeyType,
    data: ModelUpdate,
) -&gt; Result&lt;Model, ApiError&gt; { }</code></pre>
<hr>
<h3 id="deleteonepre"><a class="header" href="#deleteonepre"><code>delete::one::pre</code></a></h3>
<p>Function called before delete operation.</p>
<pre><code class="language-rust">#[crudcrate(delete::one::pre = check_delete_permission)]

async fn check_delete_permission(
    db: &amp;DatabaseConnection,
    id: PrimaryKeyType,
) -&gt; Result&lt;(), ApiError&gt; { }</code></pre>
<hr>
<h3 id="deleteonepost"><a class="header" href="#deleteonepost"><code>delete::one::post</code></a></h3>
<p>Function called after successful delete.</p>
<pre><code class="language-rust">#[crudcrate(delete::one::post = cleanup_related)]

async fn cleanup_related(
    db: &amp;DatabaseConnection,
    id: PrimaryKeyType,
) -&gt; Result&lt;(), ApiError&gt; { }</code></pre>
<hr>
<h3 id="deleteonebody"><a class="header" href="#deleteonebody"><code>delete::one::body</code></a></h3>
<p>Replace entire delete logic (e.g., for soft delete).</p>
<pre><code class="language-rust">#[crudcrate(delete::one::body = soft_delete)]

async fn soft_delete(
    db: &amp;DatabaseConnection,
    id: PrimaryKeyType,
) -&gt; Result&lt;(), ApiError&gt; { }</code></pre>
<hr>
<h3 id="getonepre"><a class="header" href="#getonepre"><code>get::one::pre</code></a></h3>
<p>Function called before get_one operation.</p>
<pre><code class="language-rust">#[crudcrate(get::one::pre = check_view_permission)]

async fn check_view_permission(
    db: &amp;DatabaseConnection,
    id: PrimaryKeyType,
) -&gt; Result&lt;(), ApiError&gt; { }</code></pre>
<hr>
<h3 id="getallpre"><a class="header" href="#getallpre"><code>get::all::pre</code></a></h3>
<p>Function called before get_all operation, can modify condition.</p>
<pre><code class="language-rust">#[crudcrate(get::all::pre = filter_by_tenant)]

async fn filter_by_tenant(
    db: &amp;DatabaseConnection,
    condition: &amp;mut Condition,
) -&gt; Result&lt;(), ApiError&gt; { }</code></pre>
<hr>
<h2 id="complete-example-5"><a class="header" href="#complete-example-5">Complete Example</a></h2>
<pre><code class="language-rust">#[derive(EntityToModels)]
#[crudcrate(
    generate_router,
    api_struct = "Article",
    name_singular = "article",
    name_plural = "articles",
    operations = ArticleOperations,
    description = "Blog articles with comments",
    fulltext_language = "english",
    create::one::pre = validate_article,
    create::one::post = index_for_search,
    update::one::pre = check_edit_permission,
    delete::one::body = soft_delete_article,
    get::all::pre = filter_published_only,
)]
#[sea_orm(table_name = "articles")]
pub struct Model {
    // ...
}</code></pre>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="#field-attributes-reference">Field Attributes Reference</a></li>
<li><a href="#crudresource-api-reference">CRUDResource API</a></li>
<li><a href="#crudoperations-api-reference">CRUDOperations API</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="field-attributes-reference"><a class="header" href="#field-attributes-reference">Field Attributes Reference</a></h1>
<p>Complete reference for <code>#[crudcrate(...)]</code> attributes on fields.</p>
<h2 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h2>
<pre><code class="language-rust">#[crudcrate(attribute1, attribute2 = value, ...)]
pub field_name: FieldType,</code></pre>
<h2 id="core-attributes"><a class="header" href="#core-attributes">Core Attributes</a></h2>
<h3 id="primary_key-1"><a class="header" href="#primary_key-1"><code>primary_key</code></a></h3>
<p>Marks the field as the primary key.</p>
<pre><code class="language-rust">#[crudcrate(primary_key)]
pub id: i32,</code></pre>
<p><strong>Required:</strong> Yes (exactly one field)
<strong>Type:</strong> Flag</p>
<hr>
<h3 id="exclude-1"><a class="header" href="#exclude-1"><code>exclude(...)</code></a></h3>
<p>Exclude field from specific generated models.</p>
<pre><code class="language-rust">#[crudcrate(exclude(create, update))]
pub id: Uuid,

#[crudcrate(exclude(one, list))]
pub password_hash: String,</code></pre>
<p><strong>Type:</strong> List of targets
<strong>Targets:</strong></p>
<ul>
<li><code>one</code> - Response model (GET /items/:id)</li>
<li><code>create</code> - Create model (POST /items)</li>
<li><code>update</code> - Update model (PUT /items/:id)</li>
<li><code>list</code> - List model (GET /items)</li>
</ul>
<hr>
<h3 id="filterable-1"><a class="header" href="#filterable-1"><code>filterable</code></a></h3>
<p>Enable filtering on this field.</p>
<pre><code class="language-rust">#[crudcrate(filterable)]
pub status: String,</code></pre>
<p><strong>Type:</strong> Flag
<strong>Effect:</strong> Allows <code>?filter={"status":"value"}</code> and <code>?status_eq=value</code></p>
<hr>
<h3 id="sortable-1"><a class="header" href="#sortable-1"><code>sortable</code></a></h3>
<p>Enable sorting on this field.</p>
<pre><code class="language-rust">#[crudcrate(sortable)]
pub created_at: DateTimeUtc,</code></pre>
<p><strong>Type:</strong> Flag
<strong>Effect:</strong> Allows <code>?sort=["created_at","DESC"]</code></p>
<hr>
<h3 id="fulltext-1"><a class="header" href="#fulltext-1"><code>fulltext</code></a></h3>
<p>Include field in fulltext search.</p>
<pre><code class="language-rust">#[crudcrate(fulltext)]
pub title: String,

#[crudcrate(fulltext)]
pub content: String,</code></pre>
<p><strong>Type:</strong> Flag
<strong>Effect:</strong> Field included when using <code>?q=search+terms</code></p>
<hr>
<h2 id="default-value-attributes"><a class="header" href="#default-value-attributes">Default Value Attributes</a></h2>
<h3 id="on_create-2"><a class="header" href="#on_create-2"><code>on_create</code></a></h3>
<p>Set default value when creating new records.</p>
<pre><code class="language-rust">#[crudcrate(on_create = Uuid::new_v4())]
pub id: Uuid,

#[crudcrate(on_create = chrono::Utc::now())]
pub created_at: DateTimeUtc,

#[crudcrate(on_create = "pending".to_string())]
pub status: String,

#[crudcrate(on_create = 0)]
pub view_count: i32,</code></pre>
<p><strong>Type:</strong> Rust expression
<strong>When:</strong> Evaluated during <code>create</code> operation</p>
<hr>
<h3 id="on_update-2"><a class="header" href="#on_update-2"><code>on_update</code></a></h3>
<p>Set default value when updating records.</p>
<pre><code class="language-rust">#[crudcrate(on_update = chrono::Utc::now())]
pub updated_at: DateTimeUtc,</code></pre>
<p><strong>Type:</strong> Rust expression
<strong>When:</strong> Evaluated during every <code>update</code> operation</p>
<hr>
<h2 id="relationship-attributes"><a class="header" href="#relationship-attributes">Relationship Attributes</a></h2>
<h3 id="non_db_attr-1"><a class="header" href="#non_db_attr-1"><code>non_db_attr</code></a></h3>
<p>Marks field as non-database (for computed or relationship fields).</p>
<pre><code class="language-rust">#[sea_orm(ignore)]
#[crudcrate(non_db_attr)]
pub comments: Vec&lt;Comment&gt;,</code></pre>
<p><strong>Type:</strong> Flag
<strong>Required:</strong> Yes, when using <code>join(...)</code></p>
<hr>
<h3 id="join-1"><a class="header" href="#join-1"><code>join(...)</code></a></h3>
<p>Configure relationship loading.</p>
<pre><code class="language-rust">// Load in get_one only
#[crudcrate(non_db_attr, join(one))]
pub comments: Vec&lt;Comment&gt;,

// Load in both get_one and get_all
#[crudcrate(non_db_attr, join(one, all))]
pub author: Option&lt;User&gt;,

// Limit recursion depth
#[crudcrate(non_db_attr, join(one, all, depth = 2))]
pub nested: Vec&lt;Nested&gt;,</code></pre>
<p><strong>Type:</strong> Configuration
<strong>Parameters:</strong></p>
<ul>
<li><code>one</code> - Load in single-item responses</li>
<li><code>all</code> - Load in list responses</li>
<li><code>depth = N</code> - Maximum recursion depth (default: 5)</li>
</ul>
<hr>
<h3 id="join_filterable"><a class="header" href="#join_filterable"><code>join_filterable(...)</code></a></h3>
<p>Enable filtering on columns from related entities using dot-notation.</p>
<pre><code class="language-rust">#[sea_orm(ignore)]
#[crudcrate(
    non_db_attr,
    join(one, all),
    join_filterable("make", "year", "color")
)]
pub vehicles: Vec&lt;Vehicle&gt;,</code></pre>
<p><strong>Type:</strong> List of column names
<strong>Effect:</strong> Enables <code>?filter={"vehicles.make":"BMW","vehicles.year_gte":2020}</code>
<strong>Security:</strong> Only listed columns can be filtered - unlisted columns are silently ignored</p>
<hr>
<h3 id="join_sortable"><a class="header" href="#join_sortable"><code>join_sortable(...)</code></a></h3>
<p>Enable sorting on columns from related entities using dot-notation.</p>
<pre><code class="language-rust">#[sea_orm(ignore)]
#[crudcrate(
    non_db_attr,
    join(one, all),
    join_sortable("year", "mileage")
)]
pub vehicles: Vec&lt;Vehicle&gt;,</code></pre>
<p><strong>Type:</strong> List of column names
<strong>Effect:</strong> Enables <code>?sort=["vehicles.year","DESC"]</code>
<strong>Security:</strong> Only listed columns can be sorted - unlisted columns fall back to default sort</p>
<hr>
<h2 id="common-patterns-3"><a class="header" href="#common-patterns-3">Common Patterns</a></h2>
<h3 id="auto-generated-id"><a class="header" href="#auto-generated-id">Auto-Generated ID</a></h3>
<pre><code class="language-rust">#[sea_orm(primary_key, auto_increment = false)]
#[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
pub id: Uuid,</code></pre>
<h3 id="managed-timestamps"><a class="header" href="#managed-timestamps">Managed Timestamps</a></h3>
<pre><code class="language-rust">#[crudcrate(sortable, exclude(create, update), on_create = chrono::Utc::now())]
pub created_at: DateTimeUtc,

#[crudcrate(exclude(create, update), on_create = chrono::Utc::now(), on_update = chrono::Utc::now())]
pub updated_at: DateTimeUtc,</code></pre>
<h3 id="sensitive-data-1"><a class="header" href="#sensitive-data-1">Sensitive Data</a></h3>
<pre><code class="language-rust">#[crudcrate(exclude(one, list))]
pub password_hash: String,

#[crudcrate(exclude(one, list))]
pub api_secret: String,</code></pre>
<h3 id="searchable-content"><a class="header" href="#searchable-content">Searchable Content</a></h3>
<pre><code class="language-rust">#[crudcrate(filterable, sortable, fulltext)]
pub title: String,

#[crudcrate(fulltext, exclude(list))]
pub content: String,</code></pre>
<h3 id="foreign-key-with-relation"><a class="header" href="#foreign-key-with-relation">Foreign Key with Relation</a></h3>
<pre><code class="language-rust">#[crudcrate(filterable)]
pub author_id: Uuid,

#[sea_orm(ignore)]
#[crudcrate(non_db_attr, join(one, all, depth = 1))]
pub author: Option&lt;User&gt;,</code></pre>
<h3 id="relationship-with-join-filteringsorting"><a class="header" href="#relationship-with-join-filteringsorting">Relationship with Join Filtering/Sorting</a></h3>
<pre><code class="language-rust">// Enable filtering and sorting on related entity columns
#[sea_orm(ignore)]
#[crudcrate(
    non_db_attr,
    join(one, all, depth = 1),
    join_filterable("make", "year", "color"),
    join_sortable("year", "mileage")
)]
pub vehicles: Vec&lt;Vehicle&gt;,</code></pre>
<p>Enables queries like:</p>
<ul>
<li><code>?filter={"vehicles.make":"BMW"}</code></li>
<li><code>?sort=["vehicles.year","DESC"]</code></li>
</ul>
<h3 id="computed-field-read-only"><a class="header" href="#computed-field-read-only">Computed Field (Read-Only)</a></h3>
<pre><code class="language-rust">#[crudcrate(sortable, exclude(create, update))]
pub view_count: i32,</code></pre>
<hr>
<h2 id="complete-example-6"><a class="header" href="#complete-example-6">Complete Example</a></h2>
<pre><code class="language-rust">#[derive(EntityToModels)]
#[crudcrate(generate_router)]
#[sea_orm(table_name = "articles")]
pub struct Model {
    // Primary key with auto-generation
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    // Searchable, filterable, sortable title
    #[crudcrate(filterable, sortable, fulltext)]
    pub title: String,

    // Searchable content, excluded from lists
    #[crudcrate(fulltext, exclude(list))]
    pub content: String,

    // Optional summary for lists
    pub summary: Option&lt;String&gt;,

    // Filterable status
    #[crudcrate(filterable)]
    pub status: ArticleStatus,

    // Foreign key with relationship
    #[crudcrate(filterable)]
    pub author_id: Uuid,

    // Read-only view counter
    #[crudcrate(sortable, exclude(create, update), on_create = 0)]
    pub view_count: i32,

    // Auto-managed timestamps
    #[crudcrate(sortable, exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTimeUtc,

    #[crudcrate(exclude(create, update), on_create = chrono::Utc::now(), on_update = chrono::Utc::now())]
    pub updated_at: DateTimeUtc,

    // Relationships
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one, all, depth = 1))]
    pub author: Option&lt;User&gt;,

    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one))]
    pub comments: Vec&lt;Comment&gt;,

    // Relationship with join filtering/sorting
    #[sea_orm(ignore)]
    #[crudcrate(
        non_db_attr,
        join(one, all, depth = 1),
        join_filterable("tag_name"),
        join_sortable("tag_name")
    )]
    pub tags: Vec&lt;Tag&gt;,
}</code></pre>
<h2 id="attribute-compatibility"><a class="header" href="#attribute-compatibility">Attribute Compatibility</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Combinable With</th></tr>
</thead>
<tbody>
<tr><td><code>primary_key</code></td><td><code>exclude</code>, <code>on_create</code></td></tr>
<tr><td><code>exclude</code></td><td>All except <code>join</code> targets conflict</td></tr>
<tr><td><code>filterable</code></td><td><code>sortable</code>, <code>fulltext</code>, <code>exclude</code></td></tr>
<tr><td><code>sortable</code></td><td><code>filterable</code>, <code>fulltext</code>, <code>exclude</code></td></tr>
<tr><td><code>fulltext</code></td><td><code>filterable</code>, <code>sortable</code>, <code>exclude</code></td></tr>
<tr><td><code>on_create</code></td><td><code>on_update</code>, <code>exclude(create)</code></td></tr>
<tr><td><code>on_update</code></td><td><code>on_create</code>, <code>exclude(update)</code></td></tr>
<tr><td><code>non_db_attr</code></td><td><code>join</code>, <code>join_filterable</code>, <code>join_sortable</code> (required)</td></tr>
<tr><td><code>join</code></td><td><code>non_db_attr</code> (required), <code>join_filterable</code>, <code>join_sortable</code></td></tr>
<tr><td><code>join_filterable</code></td><td><code>non_db_attr</code>, <code>join</code>, <code>join_sortable</code></td></tr>
<tr><td><code>join_sortable</code></td><td><code>non_db_attr</code>, <code>join</code>, <code>join_filterable</code></td></tr>
</tbody>
</table>
</div>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See Also</a></h2>
<ul>
<li><a href="#struct-attributes-reference">Struct Attributes Reference</a></li>
<li><a href="#field-exclusion">Field Exclusion</a></li>
<li><a href="#relationships--joins">Relationships</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="crudresource-api-reference"><a class="header" href="#crudresource-api-reference">CRUDResource API Reference</a></h1>
<p>The <code>CRUDResource</code> trait is the core abstraction for CRUD operations.</p>
<h2 id="trait-definition-1"><a class="header" href="#trait-definition-1">Trait Definition</a></h2>
<pre><code class="language-rust">#[async_trait]
pub trait CRUDResource: Sized + Send + Sync {
    /// The Sea-ORM entity type
    type EntityType: EntityTrait;

    /// Model for creating new records
    type CreateModel: DeserializeOwned + Send + Sync;

    /// Model for updating existing records
    type UpdateModel: DeserializeOwned + Send + Sync;

    /// Model for list responses
    type ListModel: Serialize + Send + Sync;

    /// The primary key type
    type PrimaryKey: Send + Sync;

    /// Get a single record by ID
    async fn get_one(
        db: &amp;DatabaseConnection,
        id: Self::PrimaryKey,
    ) -&gt; Result&lt;Self, ApiError&gt;;

    /// Get all records with filtering, sorting, and pagination
    async fn get_all(
        db: &amp;DatabaseConnection,
        condition: Condition,
        order: (Self::EntityType::Column, Order),
        offset: u64,
        limit: u64,
    ) -&gt; Result&lt;Vec&lt;Self::ListModel&gt;, ApiError&gt;;

    /// Create a new record
    async fn create(
        db: &amp;DatabaseConnection,
        data: Self::CreateModel,
    ) -&gt; Result&lt;Self, ApiError&gt;;

    /// Update an existing record
    async fn update(
        db: &amp;DatabaseConnection,
        id: Self::PrimaryKey,
        data: Self::UpdateModel,
    ) -&gt; Result&lt;Self, ApiError&gt;;

    /// Delete a single record
    async fn delete(
        db: &amp;DatabaseConnection,
        id: Self::PrimaryKey,
    ) -&gt; Result&lt;(), ApiError&gt;;

    /// Delete multiple records
    async fn delete_many(
        db: &amp;DatabaseConnection,
        ids: Vec&lt;Self::PrimaryKey&gt;,
    ) -&gt; Result&lt;u64, ApiError&gt;;

    /// Get total count matching condition
    async fn total_count(
        db: &amp;DatabaseConnection,
        condition: &amp;Condition,
    ) -&gt; u64;
}</code></pre>
<h2 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h2>
<h3 id="entitytype"><a class="header" href="#entitytype"><code>EntityType</code></a></h3>
<p>The Sea-ORM entity for database operations.</p>
<pre><code class="language-rust">type EntityType = entity::Entity;</code></pre>
<h3 id="createmodel"><a class="header" href="#createmodel"><code>CreateModel</code></a></h3>
<p>Request model for creating records. Excludes auto-generated fields.</p>
<pre><code class="language-rust">type CreateModel = ArticleCreate;

// Generated struct
pub struct ArticleCreate {
    pub title: String,
    pub content: String,
    // id, created_at excluded
}</code></pre>
<h3 id="updatemodel"><a class="header" href="#updatemodel"><code>UpdateModel</code></a></h3>
<p>Request model for updating records. All fields optional.</p>
<pre><code class="language-rust">type UpdateModel = ArticleUpdate;

// Generated struct
pub struct ArticleUpdate {
    pub title: Option&lt;String&gt;,
    pub content: Option&lt;String&gt;,
}</code></pre>
<h3 id="listmodel"><a class="header" href="#listmodel"><code>ListModel</code></a></h3>
<p>Response model for list operations. May exclude expensive fields.</p>
<pre><code class="language-rust">type ListModel = ArticleList;

// Generated struct
pub struct ArticleList {
    pub id: Uuid,
    pub title: String,
    // content excluded from list
}</code></pre>
<h3 id="primarykey"><a class="header" href="#primarykey"><code>PrimaryKey</code></a></h3>
<p>Type of the primary key.</p>
<pre><code class="language-rust">type PrimaryKey = Uuid;
// or
type PrimaryKey = i32;</code></pre>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<h3 id="get_one"><a class="header" href="#get_one"><code>get_one</code></a></h3>
<p>Retrieve a single record by primary key.</p>
<pre><code class="language-rust">async fn get_one(
    db: &amp;DatabaseConnection,
    id: Self::PrimaryKey,
) -&gt; Result&lt;Self, ApiError&gt;;</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>db</code> - Database connection</li>
<li><code>id</code> - Primary key value</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Ok(Self)</code> - The record as response model</li>
<li><code>Err(ApiError::NotFound)</code> - Record doesn’t exist</li>
<li><code>Err(ApiError::Database)</code> - Database error</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">let article = Article::get_one(&amp;db, article_id).await?;</code></pre>
<hr>
<h3 id="get_all"><a class="header" href="#get_all"><code>get_all</code></a></h3>
<p>Retrieve multiple records with filtering, sorting, and pagination.</p>
<pre><code class="language-rust">async fn get_all(
    db: &amp;DatabaseConnection,
    condition: Condition,
    order: (Self::EntityType::Column, Order),
    offset: u64,
    limit: u64,
) -&gt; Result&lt;Vec&lt;Self::ListModel&gt;, ApiError&gt;;</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>db</code> - Database connection</li>
<li><code>condition</code> - Sea-ORM condition for filtering</li>
<li><code>order</code> - Tuple of (Column, Order) for sorting</li>
<li><code>offset</code> - Number of records to skip</li>
<li><code>limit</code> - Maximum records to return</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Ok(Vec&lt;ListModel&gt;)</code> - List of records</li>
<li><code>Err(ApiError::Database)</code> - Database error</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">use sea_orm::{Condition, Order};

let condition = Condition::all()
    .add(Column::Status.eq("published"));

let articles = Article::get_all(
    &amp;db,
    condition,
    (Column::CreatedAt, Order::Desc),
    0,   // offset
    20,  // limit
).await?;</code></pre>
<hr>
<h3 id="create-1"><a class="header" href="#create-1"><code>create</code></a></h3>
<p>Create a new record.</p>
<pre><code class="language-rust">async fn create(
    db: &amp;DatabaseConnection,
    data: Self::CreateModel,
) -&gt; Result&lt;Self, ApiError&gt;;</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>db</code> - Database connection</li>
<li><code>data</code> - Create model with field values</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Ok(Self)</code> - Created record as response model</li>
<li><code>Err(ApiError::Database)</code> - Database error (e.g., constraint violation)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">let new_article = Article::create(&amp;db, ArticleCreate {
    title: "Hello World".into(),
    content: "My first post".into(),
}).await?;</code></pre>
<hr>
<h3 id="update-1"><a class="header" href="#update-1"><code>update</code></a></h3>
<p>Update an existing record.</p>
<pre><code class="language-rust">async fn update(
    db: &amp;DatabaseConnection,
    id: Self::PrimaryKey,
    data: Self::UpdateModel,
) -&gt; Result&lt;Self, ApiError&gt;;</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>db</code> - Database connection</li>
<li><code>id</code> - Primary key of record to update</li>
<li><code>data</code> - Update model (only Some fields are updated)</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Ok(Self)</code> - Updated record as response model</li>
<li><code>Err(ApiError::NotFound)</code> - Record doesn’t exist</li>
<li><code>Err(ApiError::Database)</code> - Database error</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">let updated = Article::update(&amp;db, article_id, ArticleUpdate {
    title: Some("New Title".into()),
    content: None,  // Don't change
}).await?;</code></pre>
<hr>
<h3 id="delete-1"><a class="header" href="#delete-1"><code>delete</code></a></h3>
<p>Delete a single record.</p>
<pre><code class="language-rust">async fn delete(
    db: &amp;DatabaseConnection,
    id: Self::PrimaryKey,
) -&gt; Result&lt;(), ApiError&gt;;</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>db</code> - Database connection</li>
<li><code>id</code> - Primary key of record to delete</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Ok(())</code> - Record deleted</li>
<li><code>Err(ApiError::NotFound)</code> - Record doesn’t exist</li>
<li><code>Err(ApiError::Database)</code> - Database error</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">Article::delete(&amp;db, article_id).await?;</code></pre>
<hr>
<h3 id="delete_many"><a class="header" href="#delete_many"><code>delete_many</code></a></h3>
<p>Delete multiple records by IDs.</p>
<pre><code class="language-rust">async fn delete_many(
    db: &amp;DatabaseConnection,
    ids: Vec&lt;Self::PrimaryKey&gt;,
) -&gt; Result&lt;u64, ApiError&gt;;</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>db</code> - Database connection</li>
<li><code>ids</code> - List of primary keys (max 100)</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Ok(u64)</code> - Number of records deleted</li>
<li><code>Err(ApiError::BadRequest)</code> - More than 100 IDs provided</li>
<li><code>Err(ApiError::Database)</code> - Database error</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">let deleted_count = Article::delete_many(&amp;db, vec![id1, id2, id3]).await?;</code></pre>
<hr>
<h3 id="total_count"><a class="header" href="#total_count"><code>total_count</code></a></h3>
<p>Get count of records matching a condition.</p>
<pre><code class="language-rust">async fn total_count(
    db: &amp;DatabaseConnection,
    condition: &amp;Condition,
) -&gt; u64;</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>db</code> - Database connection</li>
<li><code>condition</code> - Sea-ORM condition for filtering</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>Count of matching records (0 on error)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">let condition = Condition::all()
    .add(Column::Status.eq("published"));

let count = Article::total_count(&amp;db, &amp;condition).await;</code></pre>
<h2 id="usage-in-custom-handlers"><a class="header" href="#usage-in-custom-handlers">Usage in Custom Handlers</a></h2>
<pre><code class="language-rust">use crudcrate::CRUDResource;

async fn custom_list_handler(
    Query(params): Query&lt;FilterOptions&gt;,
    Extension(db): Extension&lt;DatabaseConnection&gt;,
) -&gt; Result&lt;Json&lt;Vec&lt;ArticleList&gt;&gt;, ApiError&gt; {
    let condition = apply_filters::&lt;Entity&gt;(&amp;params)?;
    let (offset, limit) = parse_pagination(&amp;params);
    let order = parse_sorting::&lt;Entity&gt;(&amp;params);

    let articles = Article::get_all(&amp;db, condition, order, offset, limit).await?;

    Ok(Json(articles))
}

async fn custom_create_handler(
    Extension(db): Extension&lt;DatabaseConnection&gt;,
    Json(data): Json&lt;ArticleCreate&gt;,
) -&gt; Result&lt;Json&lt;Article&gt;, ApiError&gt; {
    // Additional validation
    if data.title.is_empty() {
        return Err(ApiError::BadRequest("Title required".into()));
    }

    let article = Article::create(&amp;db, data).await?;

    Ok(Json(article))
}</code></pre>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See Also</a></h2>
<ul>
<li><a href="#crudoperations-api-reference">CRUDOperations API</a></li>
<li><a href="#error-types-reference">Error Types</a></li>
<li><a href="#custom-operations">Custom Operations</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="crudoperations-api-reference"><a class="header" href="#crudoperations-api-reference">CRUDOperations API Reference</a></h1>
<p>The <code>CRUDOperations</code> trait provides hooks to customize CRUD behavior.</p>
<h2 id="trait-definition-2"><a class="header" href="#trait-definition-2">Trait Definition</a></h2>
<pre><code class="language-rust">#[async_trait]
pub trait CRUDOperations: Send + Sync {
    /// The resource type this operates on
    type Resource: CRUDResource;

    /// Called before creating a new record
    async fn before_create(
        &amp;self,
        db: &amp;DatabaseConnection,
        data: &amp;mut &lt;Self::Resource as CRUDResource&gt;::CreateModel,
    ) -&gt; Result&lt;(), ApiError&gt; {
        Ok(())  // Default: no-op
    }

    /// Called after successfully creating a record
    async fn after_create(
        &amp;self,
        db: &amp;DatabaseConnection,
        created: &amp;Self::Resource,
    ) -&gt; Result&lt;(), ApiError&gt; {
        Ok(())  // Default: no-op
    }

    /// Called before updating a record
    async fn before_update(
        &amp;self,
        db: &amp;DatabaseConnection,
        id: &lt;Self::Resource as CRUDResource&gt;::PrimaryKey,
        data: &amp;mut &lt;Self::Resource as CRUDResource&gt;::UpdateModel,
    ) -&gt; Result&lt;(), ApiError&gt; {
        Ok(())  // Default: no-op
    }

    /// Called after successfully updating a record
    async fn after_update(
        &amp;self,
        db: &amp;DatabaseConnection,
        updated: &amp;Self::Resource,
    ) -&gt; Result&lt;(), ApiError&gt; {
        Ok(())  // Default: no-op
    }

    /// Called before deleting a record
    async fn before_delete(
        &amp;self,
        db: &amp;DatabaseConnection,
        id: &lt;Self::Resource as CRUDResource&gt;::PrimaryKey,
    ) -&gt; Result&lt;(), ApiError&gt; {
        Ok(())  // Default: no-op
    }

    /// Called after successfully deleting a record
    async fn after_delete(
        &amp;self,
        db: &amp;DatabaseConnection,
        id: &lt;Self::Resource as CRUDResource&gt;::PrimaryKey,
    ) -&gt; Result&lt;(), ApiError&gt; {
        Ok(())  // Default: no-op
    }

    /// Called before get_one
    async fn before_get_one(
        &amp;self,
        db: &amp;DatabaseConnection,
        id: &lt;Self::Resource as CRUDResource&gt;::PrimaryKey,
    ) -&gt; Result&lt;(), ApiError&gt; {
        Ok(())  // Default: no-op
    }

    /// Called before get_all, can modify the condition
    async fn before_get_all(
        &amp;self,
        db: &amp;DatabaseConnection,
        condition: &amp;mut Condition,
    ) -&gt; Result&lt;(), ApiError&gt; {
        Ok(())  // Default: no-op
    }
}</code></pre>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<h3 id="basic-implementation"><a class="header" href="#basic-implementation">Basic Implementation</a></h3>
<pre><code class="language-rust">use async_trait::async_trait;
use crudcrate::{CRUDOperations, ApiError};
use sea_orm::DatabaseConnection;

pub struct ArticleOperations;

#[async_trait]
impl CRUDOperations for ArticleOperations {
    type Resource = Article;

    // Override only the hooks you need
    async fn before_create(
        &amp;self,
        _db: &amp;DatabaseConnection,
        data: &amp;mut ArticleCreate,
    ) -&gt; Result&lt;(), ApiError&gt; {
        data.title = data.title.trim().to_string();
        Ok(())
    }
}</code></pre>
<h3 id="registration"><a class="header" href="#registration">Registration</a></h3>
<pre><code class="language-rust">#[derive(EntityToModels)]
#[crudcrate(operations = ArticleOperations)]
pub struct Model { }</code></pre>
<h2 id="hook-methods"><a class="header" href="#hook-methods">Hook Methods</a></h2>
<h3 id="before_create"><a class="header" href="#before_create"><code>before_create</code></a></h3>
<p>Called before inserting a new record. Can modify the input data.</p>
<pre><code class="language-rust">async fn before_create(
    &amp;self,
    db: &amp;DatabaseConnection,
    data: &amp;mut ArticleCreate,
) -&gt; Result&lt;(), ApiError&gt;;</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Input validation</li>
<li>Data transformation (trim, normalize)</li>
<li>Uniqueness checks</li>
<li>Generating derived values (slug from title)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">async fn before_create(
    &amp;self,
    db: &amp;DatabaseConnection,
    data: &amp;mut ArticleCreate,
) -&gt; Result&lt;(), ApiError&gt; {
    // Validate
    if data.title.len() &lt; 5 {
        return Err(ApiError::ValidationFailed(vec![
            ValidationError::new("title", "Too short")
        ]));
    }

    // Transform
    data.slug = Some(slugify(&amp;data.title));

    // Check uniqueness
    if slug_exists(db, data.slug.as_ref().unwrap()).await? {
        return Err(ApiError::Conflict("Slug already exists".into()));
    }

    Ok(())
}</code></pre>
<hr>
<h3 id="after_create"><a class="header" href="#after_create"><code>after_create</code></a></h3>
<p>Called after the record is successfully inserted.</p>
<pre><code class="language-rust">async fn after_create(
    &amp;self,
    db: &amp;DatabaseConnection,
    created: &amp;Article,
) -&gt; Result&lt;(), ApiError&gt;;</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Sending notifications</li>
<li>Updating search indexes</li>
<li>Creating audit logs</li>
<li>Triggering background jobs</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">async fn after_create(
    &amp;self,
    db: &amp;DatabaseConnection,
    created: &amp;Article,
) -&gt; Result&lt;(), ApiError&gt; {
    // Log creation
    tracing::info!(article_id = %created.id, "Article created");

    // Index for search
    search_client::index_document("articles", created).await;

    // Notify followers
    notify_followers(db, created.author_id).await?;

    Ok(())
}</code></pre>
<hr>
<h3 id="before_update"><a class="header" href="#before_update"><code>before_update</code></a></h3>
<p>Called before updating a record. Can modify the update data.</p>
<pre><code class="language-rust">async fn before_update(
    &amp;self,
    db: &amp;DatabaseConnection,
    id: Uuid,
    data: &amp;mut ArticleUpdate,
) -&gt; Result&lt;(), ApiError&gt;;</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Authorization checks (user owns resource)</li>
<li>Preventing certain field updates</li>
<li>Validating state transitions</li>
<li>Transforming input</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">async fn before_update(
    &amp;self,
    db: &amp;DatabaseConnection,
    id: Uuid,
    data: &amp;mut ArticleUpdate,
) -&gt; Result&lt;(), ApiError&gt; {
    // Authorization
    let article = Entity::find_by_id(id).one(db).await?.ok_or(ApiError::NotFound)?;
    let user = get_current_user();

    if article.author_id != user.id &amp;&amp; !user.is_admin {
        return Err(ApiError::Forbidden);
    }

    // Prevent changing author
    data.author_id = None;

    Ok(())
}</code></pre>
<hr>
<h3 id="after_update"><a class="header" href="#after_update"><code>after_update</code></a></h3>
<p>Called after the record is successfully updated.</p>
<pre><code class="language-rust">async fn after_update(
    &amp;self,
    db: &amp;DatabaseConnection,
    updated: &amp;Article,
) -&gt; Result&lt;(), ApiError&gt;;</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Invalidating caches</li>
<li>Updating search indexes</li>
<li>Creating audit logs</li>
<li>Sending change notifications</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">async fn after_update(
    &amp;self,
    _db: &amp;DatabaseConnection,
    updated: &amp;Article,
) -&gt; Result&lt;(), ApiError&gt; {
    // Update search index
    search_client::update_document("articles", updated.id, updated).await;

    // Invalidate cache
    cache::invalidate(&amp;format!("article:{}", updated.id)).await;

    Ok(())
}</code></pre>
<hr>
<h3 id="before_delete"><a class="header" href="#before_delete"><code>before_delete</code></a></h3>
<p>Called before deleting a record.</p>
<pre><code class="language-rust">async fn before_delete(
    &amp;self,
    db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt;;</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Authorization checks</li>
<li>Preventing deletion of important records</li>
<li>Cascading deletes</li>
<li>Checking references</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">async fn before_delete(
    &amp;self,
    db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt; {
    // Only admins can delete
    let user = get_current_user();
    if !user.is_admin {
        return Err(ApiError::Forbidden);
    }

    // Cascade delete comments
    comment::Entity::delete_many()
        .filter(comment::Column::ArticleId.eq(id))
        .exec(db)
        .await?;

    Ok(())
}</code></pre>
<hr>
<h3 id="after_delete"><a class="header" href="#after_delete"><code>after_delete</code></a></h3>
<p>Called after the record is successfully deleted.</p>
<pre><code class="language-rust">async fn after_delete(
    &amp;self,
    db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt;;</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Cleanup (files, related data)</li>
<li>Removing from search index</li>
<li>Creating audit logs</li>
<li>Sending notifications</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">async fn after_delete(
    &amp;self,
    _db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt; {
    // Remove from search
    search_client::delete_document("articles", id).await;

    // Delete uploaded files
    storage::delete_files_for_article(id).await;

    tracing::info!(article_id = %id, "Article deleted");

    Ok(())
}</code></pre>
<hr>
<h3 id="before_get_one"><a class="header" href="#before_get_one"><code>before_get_one</code></a></h3>
<p>Called before fetching a single record.</p>
<pre><code class="language-rust">async fn before_get_one(
    &amp;self,
    db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt;;</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Authorization checks</li>
<li>Access logging</li>
<li>Rate limiting</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">async fn before_get_one(
    &amp;self,
    _db: &amp;DatabaseConnection,
    id: Uuid,
) -&gt; Result&lt;(), ApiError&gt; {
    // Log access
    tracing::info!(article_id = %id, "Article accessed");

    // Rate limit check
    if is_rate_limited() {
        return Err(ApiError::BadRequest("Rate limited".into()));
    }

    Ok(())
}</code></pre>
<hr>
<h3 id="before_get_all"><a class="header" href="#before_get_all"><code>before_get_all</code></a></h3>
<p>Called before fetching multiple records. Can modify the condition.</p>
<pre><code class="language-rust">async fn before_get_all(
    &amp;self,
    db: &amp;DatabaseConnection,
    condition: &amp;mut Condition,
) -&gt; Result&lt;(), ApiError&gt;;</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Row-level security (filter by tenant/user)</li>
<li>Adding default filters (exclude deleted)</li>
<li>Access control</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">async fn before_get_all(
    &amp;self,
    _db: &amp;DatabaseConnection,
    condition: &amp;mut Condition,
) -&gt; Result&lt;(), ApiError&gt; {
    let user = get_current_user();

    // Non-admins only see published articles
    if !user.is_admin {
        *condition = condition.clone()
            .add(Column::Status.eq("published"));
    }

    // Always exclude soft-deleted
    *condition = condition.clone()
        .add(Column::DeletedAt.is_null());

    Ok(())
}</code></pre>
<h2 id="complete-example-7"><a class="header" href="#complete-example-7">Complete Example</a></h2>
<pre><code class="language-rust">use async_trait::async_trait;
use crudcrate::{CRUDOperations, ApiError, ValidationError};
use sea_orm::{DatabaseConnection, EntityTrait, Condition, ColumnTrait};

pub struct ArticleOperations;

#[async_trait]
impl CRUDOperations for ArticleOperations {
    type Resource = Article;

    async fn before_create(
        &amp;self,
        db: &amp;DatabaseConnection,
        data: &amp;mut ArticleCreate,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Validate
        let mut errors = Vec::new();
        if data.title.len() &lt; 5 {
            errors.push(ValidationError::new("title", "Minimum 5 characters"));
        }
        if !errors.is_empty() {
            return Err(ApiError::ValidationFailed(errors));
        }

        // Transform
        data.title = data.title.trim().to_string();
        data.slug = Some(slugify(&amp;data.title));

        Ok(())
    }

    async fn after_create(
        &amp;self,
        _db: &amp;DatabaseConnection,
        created: &amp;Article,
    ) -&gt; Result&lt;(), ApiError&gt; {
        tracing::info!(id = %created.id, "Article created");
        search_client::index("articles", created).await;
        Ok(())
    }

    async fn before_update(
        &amp;self,
        db: &amp;DatabaseConnection,
        id: Uuid,
        _data: &amp;mut ArticleUpdate,
    ) -&gt; Result&lt;(), ApiError&gt; {
        let article = Entity::find_by_id(id).one(db).await?.ok_or(ApiError::NotFound)?;
        let user = get_current_user();

        if article.author_id != user.id &amp;&amp; !user.is_admin {
            return Err(ApiError::Forbidden);
        }

        Ok(())
    }

    async fn after_update(
        &amp;self,
        _db: &amp;DatabaseConnection,
        updated: &amp;Article,
    ) -&gt; Result&lt;(), ApiError&gt; {
        search_client::update("articles", updated).await;
        cache::invalidate(&amp;format!("article:{}", updated.id)).await;
        Ok(())
    }

    async fn before_delete(
        &amp;self,
        _db: &amp;DatabaseConnection,
        _id: Uuid,
    ) -&gt; Result&lt;(), ApiError&gt; {
        let user = get_current_user();
        if !user.is_admin {
            return Err(ApiError::Forbidden);
        }
        Ok(())
    }

    async fn after_delete(
        &amp;self,
        _db: &amp;DatabaseConnection,
        id: Uuid,
    ) -&gt; Result&lt;(), ApiError&gt; {
        search_client::delete("articles", id).await;
        storage::cleanup(id).await;
        Ok(())
    }

    async fn before_get_all(
        &amp;self,
        _db: &amp;DatabaseConnection,
        condition: &amp;mut Condition,
    ) -&gt; Result&lt;(), ApiError&gt; {
        let user = get_current_user();

        if !user.is_admin {
            *condition = condition.clone().add(Column::Status.eq("published"));
        }

        Ok(())
    }
}</code></pre>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See Also</a></h2>
<ul>
<li><a href="#crudresource-api-reference">CRUDResource API</a></li>
<li><a href="#lifecycle-hooks-1">Lifecycle Hooks</a></li>
<li><a href="#custom-operations">Custom Operations</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-types-reference"><a class="header" href="#error-types-reference">Error Types Reference</a></h1>
<p>Complete reference for CRUDCrate error types and HTTP responses.</p>
<h2 id="apierror-enum"><a class="header" href="#apierror-enum">ApiError Enum</a></h2>
<pre><code class="language-rust">pub enum ApiError {
    NotFound,
    BadRequest(String),
    Unauthorized,
    Forbidden,
    Conflict(String),
    ValidationFailed(Vec&lt;ValidationError&gt;),
    Database(String),
    Internal(String),
}</code></pre>
<h2 id="error-types"><a class="header" href="#error-types">Error Types</a></h2>
<h3 id="notfound"><a class="header" href="#notfound">NotFound</a></h3>
<p>Resource doesn’t exist.</p>
<pre><code class="language-rust">ApiError::NotFound</code></pre>
<p><strong>HTTP Status:</strong> 404
<strong>Response:</strong></p>
<pre><code class="language-json">{"error": "Not found"}
</code></pre>
<p><strong>When Used:</strong></p>
<ul>
<li><code>get_one</code> with non-existent ID</li>
<li><code>update</code> on non-existent record</li>
<li><code>delete</code> on non-existent record</li>
</ul>
<hr>
<h3 id="badrequest"><a class="header" href="#badrequest">BadRequest</a></h3>
<p>Invalid request data or parameters.</p>
<pre><code class="language-rust">ApiError::BadRequest("Invalid filter syntax".into())</code></pre>
<p><strong>HTTP Status:</strong> 400
<strong>Response:</strong></p>
<pre><code class="language-json">{"error": "Invalid filter syntax"}
</code></pre>
<p><strong>When Used:</strong></p>
<ul>
<li>Invalid query parameters</li>
<li>Malformed JSON body</li>
<li>Invalid filter field</li>
<li>Too many items in bulk operation</li>
</ul>
<hr>
<h3 id="unauthorized"><a class="header" href="#unauthorized">Unauthorized</a></h3>
<p>Authentication required or failed.</p>
<pre><code class="language-rust">ApiError::Unauthorized</code></pre>
<p><strong>HTTP Status:</strong> 401
<strong>Response:</strong></p>
<pre><code class="language-json">{"error": "Unauthorized"}
</code></pre>
<p><strong>When Used:</strong></p>
<ul>
<li>Missing authentication</li>
<li>Invalid/expired token</li>
<li>Custom auth checks in hooks</li>
</ul>
<hr>
<h3 id="forbidden"><a class="header" href="#forbidden">Forbidden</a></h3>
<p>User lacks permission.</p>
<pre><code class="language-rust">ApiError::Forbidden</code></pre>
<p><strong>HTTP Status:</strong> 403
<strong>Response:</strong></p>
<pre><code class="language-json">{"error": "Forbidden"}
</code></pre>
<p><strong>When Used:</strong></p>
<ul>
<li>Authorization checks in hooks</li>
<li>Row-level security violations</li>
<li>Role-based access denial</li>
</ul>
<hr>
<h3 id="conflict"><a class="header" href="#conflict">Conflict</a></h3>
<p>Resource conflict (usually uniqueness violation).</p>
<pre><code class="language-rust">ApiError::Conflict("Email already in use".into())</code></pre>
<p><strong>HTTP Status:</strong> 409
<strong>Response:</strong></p>
<pre><code class="language-json">{"error": "Email already in use"}
</code></pre>
<p><strong>When Used:</strong></p>
<ul>
<li>Unique constraint violations</li>
<li>Concurrent modification conflicts</li>
<li>State machine transitions</li>
</ul>
<hr>
<h3 id="validationfailed"><a class="header" href="#validationfailed">ValidationFailed</a></h3>
<p>Input validation errors with field details.</p>
<pre><code class="language-rust">ApiError::ValidationFailed(vec![
    ValidationError::new("email", "Invalid format"),
    ValidationError::new("password", "Too short"),
])</code></pre>
<p><strong>HTTP Status:</strong> 422
<strong>Response:</strong></p>
<pre><code class="language-json">{
  "error": "Validation failed",
  "details": [
    {"field": "email", "message": "Invalid format"},
    {"field": "password", "message": "Too short"}
  ]
}
</code></pre>
<p><strong>When Used:</strong></p>
<ul>
<li>Input validation in hooks</li>
<li>Business rule violations</li>
<li>Data format errors</li>
</ul>
<hr>
<h3 id="database"><a class="header" href="#database">Database</a></h3>
<p>Database operation failed (details sanitized).</p>
<pre><code class="language-rust">ApiError::Database("Database error".into())</code></pre>
<p><strong>HTTP Status:</strong> 500
<strong>Response:</strong></p>
<pre><code class="language-json">{"error": "Database error"}
</code></pre>
<p><strong>Note:</strong> The actual error is logged server-side, not exposed to clients.</p>
<p><strong>When Used:</strong></p>
<ul>
<li>Connection failures</li>
<li>Query errors</li>
<li>Constraint violations (when not caught as Conflict)</li>
</ul>
<hr>
<h3 id="internal"><a class="header" href="#internal">Internal</a></h3>
<p>Generic server error.</p>
<pre><code class="language-rust">ApiError::Internal("Unexpected error".into())</code></pre>
<p><strong>HTTP Status:</strong> 500
<strong>Response:</strong></p>
<pre><code class="language-json">{"error": "Unexpected error"}
</code></pre>
<p><strong>When Used:</strong></p>
<ul>
<li>Unhandled errors</li>
<li>Infrastructure failures</li>
<li>Configuration errors</li>
</ul>
<h2 id="validationerror"><a class="header" href="#validationerror">ValidationError</a></h2>
<pre><code class="language-rust">pub struct ValidationError {
    pub field: String,
    pub message: String,
}

impl ValidationError {
    pub fn new(field: &amp;str, message: &amp;str) -&gt; Self {
        Self {
            field: field.to_string(),
            message: message.to_string(),
        }
    }
}</code></pre>
<h2 id="creating-errors"><a class="header" href="#creating-errors">Creating Errors</a></h2>
<pre><code class="language-rust">use crudcrate::{ApiError, ValidationError};

// Not found
return Err(ApiError::NotFound);

// Bad request
return Err(ApiError::BadRequest("Invalid parameter".into()));

// Unauthorized
return Err(ApiError::Unauthorized);

// Forbidden
return Err(ApiError::Forbidden);

// Conflict
return Err(ApiError::Conflict("Duplicate entry".into()));

// Validation failed
return Err(ApiError::ValidationFailed(vec![
    ValidationError::new("email", "Required"),
    ValidationError::new("age", "Must be positive"),
]));

// Database error (use with caution)
return Err(ApiError::Database("Connection failed".into()));

// Internal error
return Err(ApiError::Internal("Configuration error".into()));</code></pre>
<h2 id="error-conversion-1"><a class="header" href="#error-conversion-1">Error Conversion</a></h2>
<p>ApiError implements <code>From</code> for common types:</p>
<pre><code class="language-rust">// From sea_orm::DbErr
impl From&lt;DbErr&gt; for ApiError {
    fn from(err: DbErr) -&gt; Self {
        eprintln!("Database error: {}", err);
        ApiError::Database("Database error".into())
    }
}

// Usage with ? operator
async fn get_item(db: &amp;DatabaseConnection, id: i32) -&gt; Result&lt;Item, ApiError&gt; {
    let item = Entity::find_by_id(id)
        .one(db)
        .await?  // DbErr automatically converted
        .ok_or(ApiError::NotFound)?;
    Ok(item.into())
}</code></pre>
<h2 id="http-response-mapping"><a class="header" href="#http-response-mapping">HTTP Response Mapping</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Error Type</th><th>Status</th><th>Body</th></tr>
</thead>
<tbody>
<tr><td><code>NotFound</code></td><td>404</td><td><code>{"error": "Not found"}</code></td></tr>
<tr><td><code>BadRequest(msg)</code></td><td>400</td><td><code>{"error": "{msg}"}</code></td></tr>
<tr><td><code>Unauthorized</code></td><td>401</td><td><code>{"error": "Unauthorized"}</code></td></tr>
<tr><td><code>Forbidden</code></td><td>403</td><td><code>{"error": "Forbidden"}</code></td></tr>
<tr><td><code>Conflict(msg)</code></td><td>409</td><td><code>{"error": "{msg}"}</code></td></tr>
<tr><td><code>ValidationFailed(errs)</code></td><td>422</td><td><code>{"error": "...", "details": [...]}</code></td></tr>
<tr><td><code>Database(msg)</code></td><td>500</td><td><code>{"error": "{msg}"}</code></td></tr>
<tr><td><code>Internal(msg)</code></td><td>500</td><td><code>{"error": "{msg}"}</code></td></tr>
</tbody>
</table>
</div>
<h2 id="usage-in-hooks"><a class="header" href="#usage-in-hooks">Usage in Hooks</a></h2>
<pre><code class="language-rust">async fn before_create(
    &amp;self,
    db: &amp;DatabaseConnection,
    data: &amp;mut ArticleCreate,
) -&gt; Result&lt;(), ApiError&gt; {
    // Validation
    let mut errors = Vec::new();

    if data.title.is_empty() {
        errors.push(ValidationError::new("title", "Required"));
    }

    if data.title.len() &gt; 200 {
        errors.push(ValidationError::new("title", "Max 200 characters"));
    }

    if !errors.is_empty() {
        return Err(ApiError::ValidationFailed(errors));
    }

    // Uniqueness check
    let exists = Entity::find()
        .filter(Column::Slug.eq(&amp;data.slug))
        .count(db)
        .await?;

    if exists &gt; 0 {
        return Err(ApiError::Conflict("Article with this slug exists".into()));
    }

    Ok(())
}

async fn before_update(
    &amp;self,
    db: &amp;DatabaseConnection,
    id: Uuid,
    _data: &amp;mut ArticleUpdate,
) -&gt; Result&lt;(), ApiError&gt; {
    let article = Entity::find_by_id(id)
        .one(db)
        .await?
        .ok_or(ApiError::NotFound)?;

    let user = get_current_user();

    if article.author_id != user.id {
        return Err(ApiError::Forbidden);
    }

    Ok(())
}</code></pre>
<h2 id="custom-error-extension"><a class="header" href="#custom-error-extension">Custom Error Extension</a></h2>
<p>Create domain-specific errors:</p>
<pre><code class="language-rust">pub enum DomainError {
    InsufficientFunds(f64),
    OrderExpired,
    InventoryDepleted(String),
}

impl From&lt;DomainError&gt; for ApiError {
    fn from(err: DomainError) -&gt; Self {
        match err {
            DomainError::InsufficientFunds(needed) =&gt; {
                ApiError::BadRequest(format!("Insufficient funds. Need ${:.2}", needed))
            }
            DomainError::OrderExpired =&gt; {
                ApiError::BadRequest("Order has expired".into())
            }
            DomainError::InventoryDepleted(item) =&gt; {
                ApiError::Conflict(format!("'{}' is out of stock", item))
            }
        }
    }
}

// Usage
fn process_order(order: &amp;Order) -&gt; Result&lt;(), ApiError&gt; {
    if order.is_expired() {
        return Err(DomainError::OrderExpired.into());
    }
    Ok(())
}</code></pre>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See Also</a></h2>
<ul>
<li><a href="#error-handling-3">Error Handling</a></li>
<li><a href="#validation-1">Validation</a></li>
<li><a href="#security-best-practices">Security</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="query-parameters-reference"><a class="header" href="#query-parameters-reference">Query Parameters Reference</a></h1>
<p>Complete reference for all supported query parameters.</p>
<h2 id="filteroptions-struct"><a class="header" href="#filteroptions-struct">FilterOptions Struct</a></h2>
<pre><code class="language-rust">pub struct FilterOptions {
    pub filter: Option&lt;String&gt;,      // JSON filter object
    pub sort: Option&lt;String&gt;,        // Sort specification
    pub order: Option&lt;String&gt;,       // Sort order (ASC/DESC)
    pub range: Option&lt;String&gt;,       // Pagination range [start, end]
    pub page: Option&lt;u64&gt;,           // Page number
    pub per_page: Option&lt;u64&gt;,       // Items per page
    pub q: Option&lt;String&gt;,           // Fulltext search query
    // Plus dynamic field-specific filters
}</code></pre>
<h2 id="filtering-parameters"><a class="header" href="#filtering-parameters">Filtering Parameters</a></h2>
<h3 id="filter-json-object"><a class="header" href="#filter-json-object"><code>filter</code> (JSON Object)</a></h3>
<p>Filter by exact field values.</p>
<pre><code class="language-bash"># Single field
?filter={"status":"active"}

# Multiple fields (AND)
?filter={"status":"active","priority":5}

# Null check
?filter={"deleted_at":null}
</code></pre>
<h3 id="field-specific-operators"><a class="header" href="#field-specific-operators">Field-Specific Operators</a></h3>
<pre><code class="language-bash"># Exact match (default)
?status=active
?status_eq=active

# Not equal
?status_ne=deleted

# Greater than
?priority_gt=5

# Greater than or equal
?priority_gte=5

# Less than
?priority_lt=10

# Less than or equal
?priority_lte=10

# Contains (LIKE)
?title_like=urgent

# In list
?status_in=active,pending,review
</code></pre>
<p><strong>Operator Reference:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Suffix</th><th>SQL</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>_eq</code></td><td><code>=</code></td><td><code>?status_eq=active</code></td></tr>
<tr><td><code>_ne</code></td><td><code>!=</code></td><td><code>?status_ne=deleted</code></td></tr>
<tr><td><code>_gt</code></td><td><code>&gt;</code></td><td><code>?age_gt=18</code></td></tr>
<tr><td><code>_gte</code></td><td><code>&gt;=</code></td><td><code>?age_gte=18</code></td></tr>
<tr><td><code>_lt</code></td><td><code>&lt;</code></td><td><code>?price_lt=100</code></td></tr>
<tr><td><code>_lte</code></td><td><code>&lt;=</code></td><td><code>?price_lte=100</code></td></tr>
<tr><td><code>_like</code></td><td><code>LIKE</code></td><td><code>?name_like=john</code></td></tr>
<tr><td><code>_in</code></td><td><code>IN</code></td><td><code>?status_in=a,b,c</code></td></tr>
</tbody>
</table>
</div>
<h2 id="sorting-parameters"><a class="header" href="#sorting-parameters">Sorting Parameters</a></h2>
<h3 id="sort-json-array---react-admin"><a class="header" href="#sort-json-array---react-admin"><code>sort</code> (JSON Array - React Admin)</a></h3>
<pre><code class="language-bash"># Field and direction
?sort=["created_at","DESC"]

# Field only (defaults to ASC)
?sort=["name"]
</code></pre>
<h3 id="sort--order-standard"><a class="header" href="#sort--order-standard"><code>sort</code> + <code>order</code> (Standard)</a></h3>
<pre><code class="language-bash">?sort=created_at&amp;order=DESC
?sort=name&amp;order=ASC
</code></pre>
<h3 id="combined-format"><a class="header" href="#combined-format">Combined Format</a></h3>
<pre><code class="language-bash">?sort=created_at_desc
?sort=name_asc
</code></pre>
<p><strong>Order Values:</strong></p>
<ul>
<li><code>ASC</code> / <code>asc</code> - Ascending (A-Z, 0-9, oldest)</li>
<li><code>DESC</code> / <code>desc</code> - Descending (Z-A, 9-0, newest)</li>
</ul>
<h2 id="pagination-parameters"><a class="header" href="#pagination-parameters">Pagination Parameters</a></h2>
<h3 id="range-react-admin"><a class="header" href="#range-react-admin"><code>range</code> (React Admin)</a></h3>
<pre><code class="language-bash"># Items 0-9 (first 10)
?range=[0,9]

# Items 20-29
?range=[20,29]

# Items 0-99 (first 100)
?range=[0,99]
</code></pre>
<h3 id="page--per_page-standard"><a class="header" href="#page--per_page-standard"><code>page</code> + <code>per_page</code> (Standard)</a></h3>
<pre><code class="language-bash"># Page 1, 20 per page
?page=1&amp;per_page=20

# Page 5, 50 per page
?page=5&amp;per_page=50
</code></pre>
<p><strong>Limits:</strong></p>
<ul>
<li>Maximum <code>per_page</code>: 1,000</li>
<li>Maximum offset: 1,000,000</li>
</ul>
<h2 id="search-parameters"><a class="header" href="#search-parameters">Search Parameters</a></h2>
<h3 id="q-fulltext-search"><a class="header" href="#q-fulltext-search"><code>q</code> (Fulltext Search)</a></h3>
<pre><code class="language-bash"># Search all fulltext fields
?q=meeting notes

# Combined with filters
?q=urgent&amp;filter={"status":"open"}
</code></pre>
<h2 id="response-headers-1"><a class="header" href="#response-headers-1">Response Headers</a></h2>
<h3 id="content-range"><a class="header" href="#content-range">Content-Range</a></h3>
<pre><code class="language-http">Content-Range: items 0-19/150
</code></pre>
<p>Format: <code>{resource} {start}-{end}/{total}</code></p>
<h2 id="complete-examples"><a class="header" href="#complete-examples">Complete Examples</a></h2>
<h3 id="basic-list"><a class="header" href="#basic-list">Basic List</a></h3>
<pre><code class="language-bash">GET /articles
</code></pre>
<h3 id="filtered-list"><a class="header" href="#filtered-list">Filtered List</a></h3>
<pre><code class="language-bash">GET /articles?filter={"status":"published","author_id":5}
</code></pre>
<h3 id="sorted-list"><a class="header" href="#sorted-list">Sorted List</a></h3>
<pre><code class="language-bash">GET /articles?sort=["created_at","DESC"]
</code></pre>
<h3 id="paginated-list"><a class="header" href="#paginated-list">Paginated List</a></h3>
<pre><code class="language-bash">GET /articles?range=[0,19]
</code></pre>
<h3 id="search"><a class="header" href="#search">Search</a></h3>
<pre><code class="language-bash">GET /articles?q=rust programming
</code></pre>
<h3 id="combined-query"><a class="header" href="#combined-query">Combined Query</a></h3>
<pre><code class="language-bash">GET /articles?filter={"status":"published"}&amp;sort=["views","DESC"]&amp;range=[0,9]&amp;q=tutorial
</code></pre>
<h3 id="complex-filter"><a class="header" href="#complex-filter">Complex Filter</a></h3>
<pre><code class="language-bash">GET /articles?status=published&amp;views_gte=1000&amp;created_at_gte=2024-01-01
</code></pre>
<h2 id="parsing-functions"><a class="header" href="#parsing-functions">Parsing Functions</a></h2>
<h3 id="apply_filters"><a class="header" href="#apply_filters"><code>apply_filters</code></a></h3>
<p>Build Sea-ORM condition from query parameters.</p>
<pre><code class="language-rust">use crudcrate::filtering::apply_filters;

let condition = apply_filters::&lt;Entity&gt;(&amp;params)?;</code></pre>
<h3 id="parse_pagination"><a class="header" href="#parse_pagination"><code>parse_pagination</code></a></h3>
<p>Extract offset and limit from parameters.</p>
<pre><code class="language-rust">use crudcrate::filtering::parse_pagination;

let (offset, limit) = parse_pagination(&amp;params);
// Default: (0, 20)</code></pre>
<h3 id="parse_sorting"><a class="header" href="#parse_sorting"><code>parse_sorting</code></a></h3>
<p>Extract column and order from parameters.</p>
<pre><code class="language-rust">use crudcrate::filtering::parse_sorting;

let (column, order) = parse_sorting::&lt;Entity&gt;(&amp;params);
// Default: (primary_key_column, Order::Asc)</code></pre>
<h3 id="build_fulltext_condition"><a class="header" href="#build_fulltext_condition"><code>build_fulltext_condition</code></a></h3>
<p>Build fulltext search condition.</p>
<pre><code class="language-rust">use crudcrate::filtering::build_fulltext_condition;

let condition = build_fulltext_condition(
    query,
    &amp;["title", "content"],
    db.get_database_backend()
);</code></pre>
<h2 id="url-encoding"><a class="header" href="#url-encoding">URL Encoding</a></h2>
<p>Special characters in values must be URL-encoded:</p>
<pre><code class="language-bash"># Space → %20 or +
?q=hello+world
?q=hello%20world

# Brackets → %5B %5D
?range=%5B0,9%5D

# Curly braces → %7B %7D
?filter=%7B"status":"active"%7D

# Comma in value → %2C
?tags_in=one%2Ctwo%2Cthree
</code></pre>
<h2 id="error-responses"><a class="header" href="#error-responses">Error Responses</a></h2>
<h3 id="invalid-filter-field"><a class="header" href="#invalid-filter-field">Invalid Filter Field</a></h3>
<pre><code class="language-bash">GET /articles?unknown_field=value
</code></pre>
<pre><code class="language-json">{"error": "Invalid filter field: unknown_field"}
</code></pre>
<h3 id="invalid-filter-value"><a class="header" href="#invalid-filter-value">Invalid Filter Value</a></h3>
<pre><code class="language-bash">GET /articles?priority_gte=not-a-number
</code></pre>
<pre><code class="language-json">{"error": "Invalid filter value for field 'priority': expected number"}
</code></pre>
<h3 id="invalid-sort-field"><a class="header" href="#invalid-sort-field">Invalid Sort Field</a></h3>
<p>Invalid sort fields are silently ignored (falls back to default).</p>
<h3 id="invalid-range-format"><a class="header" href="#invalid-range-format">Invalid Range Format</a></h3>
<pre><code class="language-bash">GET /articles?range=invalid
</code></pre>
<p>Falls back to default pagination.</p>
<h2 id="see-also-5"><a class="header" href="#see-also-5">See Also</a></h2>
<ul>
<li><a href="#filtering">Filtering</a></li>
<li><a href="#sorting">Sorting</a></li>
<li><a href="#pagination-1">Pagination</a></li>
<li><a href="#fulltext-search">Fulltext Search</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="minimal-api-example"><a class="header" href="#minimal-api-example">Minimal API Example</a></h1>
<p>The simplest possible CRUDCrate API.</p>
<h2 id="full-code"><a class="header" href="#full-code">Full Code</a></h2>
<pre><code class="language-rust">// main.rs
use axum::{Extension, Router};
use crudcrate::EntityToModels;
use sea_orm::{entity::prelude::*, Database, DatabaseConnection};
use serde::{Deserialize, Serialize};
use std::net::SocketAddr;
use uuid::Uuid;

// Define the entity
#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(generate_router)]
#[sea_orm(table_name = "items")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    #[crudcrate(filterable, sortable)]
    pub name: String,

    pub description: Option&lt;String&gt;,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

#[tokio::main]
async fn main() {
    let db: DatabaseConnection = Database::connect("sqlite::memory:")
        .await
        .expect("Failed to connect");

    // Create table (use migrations in production)
    let schema = sea_orm::Schema::new(sea_orm::DatabaseBackend::Sqlite);
    db.execute(db.get_database_backend().build(&amp;schema.create_table_from_entity(Entity)))
        .await
        .expect("Failed to create table");

    let app = Router::new()
        .merge(item_router())
        .layer(Extension(db));

    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    println!("Running at http://{}", addr);

    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}</code></pre>
<h2 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h2>
<pre><code class="language-toml">[package]
name = "minimal-api"
version = "0.1.0"
edition = "2021"

[dependencies]
crudcrate = "0.1"
sea-orm = { version = "1.0", features = ["runtime-tokio-rustls", "sqlx-sqlite"] }
axum = "0.7"
tokio = { version = "1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
</code></pre>
<h2 id="run"><a class="header" href="#run">Run</a></h2>
<pre><code class="language-bash">cargo run
</code></pre>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<pre><code class="language-bash"># Create
curl -X POST http://localhost:3000/items \
  -H "Content-Type: application/json" \
  -d '{"name": "Test Item"}'

# List
curl http://localhost:3000/items

# Get
curl http://localhost:3000/items/{id}

# Update
curl -X PUT http://localhost:3000/items/{id} \
  -H "Content-Type: application/json" \
  -d '{"name": "Updated"}'

# Delete
curl -X DELETE http://localhost:3000/items/{id}
</code></pre>
<h2 id="lines-of-code"><a class="header" href="#lines-of-code">Lines of Code</a></h2>
<ul>
<li>Entity definition: ~20 lines</li>
<li>Server setup: ~15 lines</li>
<li><strong>Total: ~35 lines</strong></li>
</ul>
<p>Without CRUDCrate, this would require ~500+ lines for handlers, models, filtering, pagination, etc.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="todo-application-example"><a class="header" href="#todo-application-example">Todo Application Example</a></h1>
<p>A practical todo app with filtering, sorting, and search.</p>
<h2 id="entity-definition"><a class="header" href="#entity-definition">Entity Definition</a></h2>
<pre><code class="language-rust">use crudcrate::EntityToModels;
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Clone, Debug, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(StringLen::N(15))")]
pub enum Priority {
    #[sea_orm(string_value = "low")]
    Low,
    #[sea_orm(string_value = "medium")]
    Medium,
    #[sea_orm(string_value = "high")]
    High,
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(generate_router)]
#[sea_orm(table_name = "todos")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    #[crudcrate(filterable, sortable, fulltext)]
    pub title: String,

    #[crudcrate(fulltext)]
    pub description: Option&lt;String&gt;,

    #[crudcrate(filterable)]
    pub completed: bool,

    #[crudcrate(filterable, sortable)]
    pub priority: Priority,

    #[crudcrate(filterable, sortable)]
    pub due_date: Option&lt;DateTimeUtc&gt;,

    #[crudcrate(sortable, exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}</code></pre>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="create-todos"><a class="header" href="#create-todos">Create Todos</a></h3>
<pre><code class="language-bash"># High priority task
curl -X POST http://localhost:3000/todos \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Review pull request",
    "description": "Check the new authentication feature",
    "completed": false,
    "priority": "high"
  }'

# Medium priority with due date
curl -X POST http://localhost:3000/todos \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Update documentation",
    "completed": false,
    "priority": "medium",
    "due_date": "2024-12-31T23:59:59Z"
  }'
</code></pre>
<h3 id="filter-by-status-1"><a class="header" href="#filter-by-status-1">Filter by Status</a></h3>
<pre><code class="language-bash"># Incomplete tasks
curl "http://localhost:3000/todos?filter={\"completed\":false}"

# Completed tasks
curl "http://localhost:3000/todos?filter={\"completed\":true}"
</code></pre>
<h3 id="filter-by-priority-1"><a class="header" href="#filter-by-priority-1">Filter by Priority</a></h3>
<pre><code class="language-bash"># High priority only
curl "http://localhost:3000/todos?filter={\"priority\":\"high\"}"

# High and medium
curl "http://localhost:3000/todos?priority_in=high,medium"
</code></pre>
<h3 id="sort-by-due-date"><a class="header" href="#sort-by-due-date">Sort by Due Date</a></h3>
<pre><code class="language-bash"># Earliest due first
curl "http://localhost:3000/todos?sort=[\"due_date\",\"ASC\"]"

# Latest due first
curl "http://localhost:3000/todos?sort=[\"due_date\",\"DESC\"]"
</code></pre>
<h3 id="search-1"><a class="header" href="#search-1">Search</a></h3>
<pre><code class="language-bash"># Search title and description
curl "http://localhost:3000/todos?q=authentication"
</code></pre>
<h3 id="combined-queries"><a class="header" href="#combined-queries">Combined Queries</a></h3>
<pre><code class="language-bash"># Incomplete high-priority, sorted by due date
curl "http://localhost:3000/todos?filter={\"completed\":false,\"priority\":\"high\"}&amp;sort=[\"due_date\",\"ASC\"]"
</code></pre>
<h3 id="mark-complete"><a class="header" href="#mark-complete">Mark Complete</a></h3>
<pre><code class="language-bash">curl -X PUT http://localhost:3000/todos/{id} \
  -H "Content-Type: application/json" \
  -d '{"completed": true}'
</code></pre>
<h2 id="react-admin-integration"><a class="header" href="#react-admin-integration">React Admin Integration</a></h2>
<pre><code class="language-javascript">// dataProvider.js
import { fetchUtils } from 'react-admin';

const apiUrl = 'http://localhost:3000';

export const dataProvider = {
  getList: (resource, params) =&gt; {
    const { page, perPage } = params.pagination;
    const { field, order } = params.sort;
    const range = [(page - 1) * perPage, page * perPage - 1];

    const query = {
      sort: JSON.stringify([field, order]),
      range: JSON.stringify(range),
      filter: JSON.stringify(params.filter),
    };

    const url = `${apiUrl}/${resource}?${fetchUtils.queryParameters(query)}`;

    return fetchUtils.fetchJson(url).then(({ headers, json }) =&gt; {
      const contentRange = headers.get('Content-Range');
      const total = parseInt(contentRange.split('/').pop(), 10);
      return { data: json, total };
    });
  },
  // ... other methods
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="blog-with-comments-example"><a class="header" href="#blog-with-comments-example">Blog with Comments Example</a></h1>
<p>A blog API with posts, comments, and authors.</p>
<h2 id="entities"><a class="header" href="#entities">Entities</a></h2>
<h3 id="user-author"><a class="header" href="#user-author">User (Author)</a></h3>
<pre><code class="language-rust">#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(generate_router)]
#[sea_orm(table_name = "users")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    #[crudcrate(filterable, sortable)]
    pub name: String,

    #[crudcrate(filterable)]
    pub email: String,

    #[crudcrate(exclude(one, list))]
    pub password_hash: String,

    pub bio: Option&lt;String&gt;,

    #[crudcrate(sortable, exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTimeUtc,

    // Relationship: User has many Posts
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one))]
    pub posts: Vec&lt;super::post::Post&gt;,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::post::Entity")]
    Posts,
}

impl Related&lt;super::post::Entity&gt; for Entity {
    fn to() -&gt; RelationDef {
        Relation::Posts.def()
    }
}</code></pre>
<h3 id="post"><a class="header" href="#post">Post</a></h3>
<pre><code class="language-rust">#[derive(Clone, Debug, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(StringLen::N(15))")]
pub enum PostStatus {
    #[sea_orm(string_value = "draft")]
    Draft,
    #[sea_orm(string_value = "published")]
    Published,
    #[sea_orm(string_value = "archived")]
    Archived,
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(generate_router)]
#[sea_orm(table_name = "posts")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    #[crudcrate(filterable, sortable, fulltext)]
    pub title: String,

    pub slug: String,

    #[crudcrate(fulltext, exclude(list))]
    pub content: String,

    pub excerpt: Option&lt;String&gt;,

    #[crudcrate(filterable)]
    pub status: PostStatus,

    #[crudcrate(filterable)]
    pub author_id: Uuid,

    #[crudcrate(sortable, filterable)]
    pub published_at: Option&lt;DateTimeUtc&gt;,

    #[crudcrate(sortable, exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTimeUtc,

    // Author (belongs_to)
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one, all, depth = 1))]
    pub author: Option&lt;super::user::User&gt;,

    // Comments (has_many) - only in detail view
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one))]
    pub comments: Vec&lt;super::comment::Comment&gt;,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::user::Entity",
        from = "Column::AuthorId",
        to = "super::user::Column::Id"
    )]
    Author,

    #[sea_orm(has_many = "super::comment::Entity")]
    Comments,
}

impl Related&lt;super::user::Entity&gt; for Entity {
    fn to() -&gt; RelationDef { Relation::Author.def() }
}

impl Related&lt;super::comment::Entity&gt; for Entity {
    fn to() -&gt; RelationDef { Relation::Comments.def() }
}</code></pre>
<h3 id="comment"><a class="header" href="#comment">Comment</a></h3>
<pre><code class="language-rust">#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(generate_router)]
#[sea_orm(table_name = "comments")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    #[crudcrate(fulltext)]
    pub content: String,

    #[crudcrate(filterable)]
    pub post_id: Uuid,

    #[crudcrate(filterable)]
    pub author_id: Uuid,

    #[crudcrate(sortable, exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTimeUtc,

    // Comment author
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one, all, depth = 1))]
    pub author: Option&lt;super::user::User&gt;,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::post::Entity",
        from = "Column::PostId",
        to = "super::post::Column::Id"
    )]
    Post,

    #[sea_orm(
        belongs_to = "super::user::Entity",
        from = "Column::AuthorId",
        to = "super::user::Column::Id"
    )]
    Author,
}

impl Related&lt;super::user::Entity&gt; for Entity {
    fn to() -&gt; RelationDef { Relation::Author.def() }
}

impl Related&lt;super::post::Entity&gt; for Entity {
    fn to() -&gt; RelationDef { Relation::Post.def() }
}</code></pre>
<h2 id="router-setup"><a class="header" href="#router-setup">Router Setup</a></h2>
<pre><code class="language-rust">let app = Router::new()
    .merge(user::user_router())
    .merge(post::post_router())
    .merge(comment::comment_router())
    .layer(Extension(db));</code></pre>
<h2 id="api-examples"><a class="header" href="#api-examples">API Examples</a></h2>
<h3 id="create-a-user"><a class="header" href="#create-a-user">Create a User</a></h3>
<pre><code class="language-bash">curl -X POST http://localhost:3000/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Alice",
    "email": "alice@example.com",
    "password_hash": "hashed_password",
    "bio": "Software developer"
  }'
</code></pre>
<h3 id="create-a-post"><a class="header" href="#create-a-post">Create a Post</a></h3>
<pre><code class="language-bash">curl -X POST http://localhost:3000/posts \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Getting Started with Rust",
    "slug": "getting-started-with-rust",
    "content": "Full article content...",
    "excerpt": "Learn the basics of Rust programming",
    "status": "published",
    "author_id": "{user-id}",
    "published_at": "2024-01-15T10:00:00Z"
  }'
</code></pre>
<h3 id="list-published-posts-with-authors"><a class="header" href="#list-published-posts-with-authors">List Published Posts with Authors</a></h3>
<pre><code class="language-bash">curl "http://localhost:3000/posts?filter={\"status\":\"published\"}&amp;sort=[\"published_at\",\"DESC\"]"
</code></pre>
<h3 id="get-post-with-comments"><a class="header" href="#get-post-with-comments">Get Post with Comments</a></h3>
<pre><code class="language-bash">curl "http://localhost:3000/posts/{post-id}"

# Response includes author and comments
{
  "id": "...",
  "title": "Getting Started with Rust",
  "author": {
    "id": "...",
    "name": "Alice"
  },
  "comments": [
    {
      "id": "...",
      "content": "Great article!",
      "author": {"name": "Bob"}
    }
  ]
}
</code></pre>
<h3 id="add-a-comment"><a class="header" href="#add-a-comment">Add a Comment</a></h3>
<pre><code class="language-bash">curl -X POST http://localhost:3000/comments \
  -H "Content-Type: application/json" \
  -d '{
    "content": "This really helped me understand Rust!",
    "post_id": "{post-id}",
    "author_id": "{user-id}"
  }'
</code></pre>
<h3 id="search-posts"><a class="header" href="#search-posts">Search Posts</a></h3>
<pre><code class="language-bash">curl "http://localhost:3000/posts?q=rust programming"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="e-commerce-orders-example"><a class="header" href="#e-commerce-orders-example">E-commerce Orders Example</a></h1>
<p>Order management with products, customers, and line items.</p>
<h2 id="entities-1"><a class="header" href="#entities-1">Entities</a></h2>
<h3 id="product"><a class="header" href="#product">Product</a></h3>
<pre><code class="language-rust">#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(generate_router)]
#[sea_orm(table_name = "products")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    #[crudcrate(filterable, sortable, fulltext)]
    pub name: String,

    #[crudcrate(fulltext)]
    pub description: Option&lt;String&gt;,

    #[crudcrate(filterable, sortable)]
    pub price: Decimal,

    #[crudcrate(filterable)]
    pub category: String,

    #[crudcrate(filterable, sortable)]
    pub stock_quantity: i32,

    #[crudcrate(filterable)]
    pub active: bool,

    #[crudcrate(sortable, exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}</code></pre>
<h3 id="customer"><a class="header" href="#customer">Customer</a></h3>
<pre><code class="language-rust">#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(generate_router)]
#[sea_orm(table_name = "customers")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    #[crudcrate(filterable, sortable)]
    pub name: String,

    #[crudcrate(filterable)]
    pub email: String,

    pub phone: Option&lt;String&gt;,

    pub shipping_address: Option&lt;String&gt;,

    #[crudcrate(sortable, exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTimeUtc,

    // Customer's orders
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one))]
    pub orders: Vec&lt;super::order::Order&gt;,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::order::Entity")]
    Orders,
}

impl Related&lt;super::order::Entity&gt; for Entity {
    fn to() -&gt; RelationDef { Relation::Orders.def() }
}</code></pre>
<h3 id="order"><a class="header" href="#order">Order</a></h3>
<pre><code class="language-rust">#[derive(Clone, Debug, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(StringLen::N(20))")]
pub enum OrderStatus {
    #[sea_orm(string_value = "pending")]
    Pending,
    #[sea_orm(string_value = "confirmed")]
    Confirmed,
    #[sea_orm(string_value = "shipped")]
    Shipped,
    #[sea_orm(string_value = "delivered")]
    Delivered,
    #[sea_orm(string_value = "cancelled")]
    Cancelled,
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(generate_router, operations = OrderOperations)]
#[sea_orm(table_name = "orders")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    #[crudcrate(filterable)]
    pub customer_id: Uuid,

    #[crudcrate(filterable, sortable)]
    pub status: OrderStatus,

    #[crudcrate(sortable)]
    pub total_amount: Decimal,

    pub shipping_address: String,

    pub notes: Option&lt;String&gt;,

    #[crudcrate(sortable, filterable, exclude(create, update), on_create = chrono::Utc::now())]
    pub created_at: DateTimeUtc,

    #[crudcrate(exclude(create, update), on_create = chrono::Utc::now(), on_update = chrono::Utc::now())]
    pub updated_at: DateTimeUtc,

    // Customer
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one, all, depth = 1))]
    pub customer: Option&lt;super::customer::Customer&gt;,

    // Line items
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one))]
    pub items: Vec&lt;super::order_item::OrderItem&gt;,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::customer::Entity",
        from = "Column::CustomerId",
        to = "super::customer::Column::Id"
    )]
    Customer,

    #[sea_orm(has_many = "super::order_item::Entity")]
    Items,
}

impl Related&lt;super::customer::Entity&gt; for Entity {
    fn to() -&gt; RelationDef { Relation::Customer.def() }
}

impl Related&lt;super::order_item::Entity&gt; for Entity {
    fn to() -&gt; RelationDef { Relation::Items.def() }
}</code></pre>
<h3 id="order-item"><a class="header" href="#order-item">Order Item</a></h3>
<pre><code class="language-rust">#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize, EntityToModels)]
#[crudcrate(generate_router)]
#[sea_orm(table_name = "order_items")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    #[crudcrate(filterable)]
    pub order_id: Uuid,

    #[crudcrate(filterable)]
    pub product_id: Uuid,

    pub quantity: i32,

    pub unit_price: Decimal,

    pub total_price: Decimal,

    // Product details at time of order
    #[sea_orm(ignore)]
    #[crudcrate(non_db_attr, join(one, all, depth = 1))]
    pub product: Option&lt;super::product::Product&gt;,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::order::Entity",
        from = "Column::OrderId",
        to = "super::order::Column::Id"
    )]
    Order,

    #[sea_orm(
        belongs_to = "super::product::Entity",
        from = "Column::ProductId",
        to = "super::product::Column::Id"
    )]
    Product,
}

impl Related&lt;super::product::Entity&gt; for Entity {
    fn to() -&gt; RelationDef { Relation::Product.def() }
}</code></pre>
<h2 id="custom-operations-1"><a class="header" href="#custom-operations-1">Custom Operations</a></h2>
<pre><code class="language-rust">pub struct OrderOperations;

#[async_trait]
impl CRUDOperations for OrderOperations {
    type Resource = Order;

    async fn before_create(
        &amp;self,
        db: &amp;DatabaseConnection,
        data: &amp;mut OrderCreate,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Calculate total from items
        // Validate stock availability
        Ok(())
    }

    async fn after_create(
        &amp;self,
        db: &amp;DatabaseConnection,
        created: &amp;Order,
    ) -&gt; Result&lt;(), ApiError&gt; {
        // Update stock quantities
        // Send confirmation email
        Ok(())
    }

    async fn before_update(
        &amp;self,
        db: &amp;DatabaseConnection,
        id: Uuid,
        data: &amp;mut OrderUpdate,
    ) -&gt; Result&lt;(), ApiError&gt; {
        let order = Entity::find_by_id(id).one(db).await?.ok_or(ApiError::NotFound)?;

        // Prevent changing cancelled orders
        if order.status == OrderStatus::Cancelled {
            return Err(ApiError::BadRequest("Cannot modify cancelled order".into()));
        }

        // Validate status transitions
        if let Some(new_status) = &amp;data.status {
            if !is_valid_transition(&amp;order.status, new_status) {
                return Err(ApiError::BadRequest("Invalid status transition".into()));
            }
        }

        Ok(())
    }
}</code></pre>
<h2 id="api-examples-1"><a class="header" href="#api-examples-1">API Examples</a></h2>
<h3 id="create-order"><a class="header" href="#create-order">Create Order</a></h3>
<pre><code class="language-bash">curl -X POST http://localhost:3000/orders \
  -H "Content-Type: application/json" \
  -d '{
    "customer_id": "{customer-id}",
    "status": "pending",
    "total_amount": "99.99",
    "shipping_address": "123 Main St, City, Country"
  }'
</code></pre>
<h3 id="get-order-with-items"><a class="header" href="#get-order-with-items">Get Order with Items</a></h3>
<pre><code class="language-bash">curl "http://localhost:3000/orders/{order-id}"

# Response
{
  "id": "...",
  "status": "confirmed",
  "customer": {"name": "John Doe", "email": "..."},
  "items": [
    {"product": {"name": "Widget"}, "quantity": 2, "total_price": "49.98"}
  ]
}
</code></pre>
<h3 id="filter-orders-by-status"><a class="header" href="#filter-orders-by-status">Filter Orders by Status</a></h3>
<pre><code class="language-bash"># Pending orders
curl "http://localhost:3000/orders?filter={\"status\":\"pending\"}"

# Customer's orders
curl "http://localhost:3000/orders?filter={\"customer_id\":\"{id}\"}"
</code></pre>
<h3 id="update-order-status"><a class="header" href="#update-order-status">Update Order Status</a></h3>
<pre><code class="language-bash">curl -X PUT http://localhost:3000/orders/{id} \
  -H "Content-Type: application/json" \
  -d '{"status": "shipped"}'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<h3 id="what-is-crudcrate"><a class="header" href="#what-is-crudcrate">What is CRUDCrate?</a></h3>
<p>CRUDCrate is a Rust library that generates complete REST APIs from Sea-ORM entities using derive macros. It eliminates boilerplate code for CRUD operations, filtering, sorting, pagination, and relationships.</p>
<h3 id="how-does-it-compare-to-other-solutions"><a class="header" href="#how-does-it-compare-to-other-solutions">How does it compare to other solutions?</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>CRUDCrate</th><th>Manual Axum</th><th>Diesel</th><th>Other ORMs</th></tr>
</thead>
<tbody>
<tr><td>Code Generation</td><td>✅ Derive macro</td><td>❌ Manual</td><td>❌ Manual</td><td>Varies</td></tr>
<tr><td>Filtering</td><td>✅ Built-in</td><td>❌ Manual</td><td>❌ Manual</td><td>Varies</td></tr>
<tr><td>Pagination</td><td>✅ Built-in</td><td>❌ Manual</td><td>❌ Manual</td><td>Varies</td></tr>
<tr><td>Relationships</td><td>✅ Automatic</td><td>❌ Manual</td><td>❌ Manual</td><td>Varies</td></tr>
<tr><td>Type Safety</td><td>✅ Full</td><td>✅ Full</td><td>✅ Full</td><td>Varies</td></tr>
</tbody>
</table>
</div>
<h3 id="what-security-features-are-included"><a class="header" href="#what-security-features-are-included">What security features are included?</a></h3>
<p>CRUDCrate includes:</p>
<ul>
<li>SQL injection prevention</li>
<li>Pagination DoS protection</li>
<li>Comprehensive error handling</li>
<li>Proper logging integration</li>
</ul>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<h3 id="what-are-the-minimum-rust-version-requirements"><a class="header" href="#what-are-the-minimum-rust-version-requirements">What are the minimum Rust version requirements?</a></h3>
<p>Rust 1.70+ is required for stable proc-macro features.</p>
<h3 id="do-i-need-to-install-sea-orm-separately"><a class="header" href="#do-i-need-to-install-sea-orm-separately">Do I need to install Sea-ORM separately?</a></h3>
<p>Yes. CRUDCrate works alongside Sea-ORM:</p>
<pre><code class="language-toml">[dependencies]
crudcrate = "0.1"
sea-orm = { version = "1.0", features = ["runtime-tokio-rustls", "sqlx-postgres"] }
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="can-i-use-crudcrate-with-an-existing-sea-orm-project"><a class="header" href="#can-i-use-crudcrate-with-an-existing-sea-orm-project">Can I use CRUDCrate with an existing Sea-ORM project?</a></h3>
<p>Yes! Just add <code>#[derive(EntityToModels)]</code> and <code>#[crudcrate(...)]</code> attributes to your existing entities.</p>
<h3 id="how-do-i-customize-the-generated-endpoints"><a class="header" href="#how-do-i-customize-the-generated-endpoints">How do I customize the generated endpoints?</a></h3>
<p>Three ways:</p>
<ol>
<li><strong>Attributes</strong>: Configure behavior with <code>#[crudcrate(...)]</code></li>
<li><strong>CRUDOperations</strong>: Implement hooks for business logic</li>
<li><strong>Custom Handlers</strong>: Replace entire handlers when needed</li>
</ol>
<h3 id="can-i-have-some-entities-without-routers"><a class="header" href="#can-i-have-some-entities-without-routers">Can I have some entities without routers?</a></h3>
<p>Yes. Only add <code>generate_router</code> when you want endpoints:</p>
<pre><code class="language-rust">// With router
#[crudcrate(generate_router)]

// Without router (just models)
#[crudcrate()]</code></pre>
<h3 id="how-do-i-add-authentication"><a class="header" href="#how-do-i-add-authentication">How do I add authentication?</a></h3>
<p>Use Axum middleware:</p>
<pre><code class="language-rust">let app = Router::new()
    .merge(protected_router())
    .layer(middleware::from_fn(auth_middleware));</code></pre>
<p>See <a href="#security-best-practices">Security</a> for details.</p>
<h3 id="can-i-have-different-auth-for-different-routes"><a class="header" href="#can-i-have-different-auth-for-different-routes">Can I have different auth for different routes?</a></h3>
<p>Yes. Use nested routers:</p>
<pre><code class="language-rust">let public = Router::new().merge(public_routes());

let protected = Router::new()
    .merge(admin_routes())
    .layer(admin_auth_layer);

let app = Router::new().merge(public).merge(protected);</code></pre>
<h2 id="filtering--search"><a class="header" href="#filtering--search">Filtering &amp; Search</a></h2>
<h3 id="which-fields-can-be-filtered"><a class="header" href="#which-fields-can-be-filtered">Which fields can be filtered?</a></h3>
<p>Only fields marked <code>#[crudcrate(filterable)]</code>:</p>
<pre><code class="language-rust">#[crudcrate(filterable)]  // Can filter
pub status: String,

pub secret: String,  // Cannot filter</code></pre>
<h3 id="how-does-fulltext-search-work"><a class="header" href="#how-does-fulltext-search-work">How does fulltext search work?</a></h3>
<p>Fields marked <code>#[crudcrate(fulltext)]</code> are searched with <code>?q=</code>:</p>
<pre><code class="language-bash">GET /items?q=search terms
</code></pre>
<p>The query uses database-optimized search (GIN for Postgres, FULLTEXT for MySQL).</p>
<h3 id="can-i-combine-filters-and-search"><a class="header" href="#can-i-combine-filters-and-search">Can I combine filters and search?</a></h3>
<p>Yes:</p>
<pre><code class="language-bash">GET /items?filter={"status":"active"}&amp;q=urgent&amp;sort=["created_at","DESC"]
</code></pre>
<h2 id="relationships-1"><a class="header" href="#relationships-1">Relationships</a></h2>
<h3 id="how-do-i-load-related-entities"><a class="header" href="#how-do-i-load-related-entities">How do I load related entities?</a></h3>
<ol>
<li>Define Sea-ORM relations</li>
<li>Add join field with <code>#[crudcrate(non_db_attr, join(one))]</code></li>
</ol>
<pre><code class="language-rust">#[sea_orm(ignore)]
#[crudcrate(non_db_attr, join(one))]
pub comments: Vec&lt;Comment&gt;,</code></pre>
<h3 id="why-are-relationships-not-loading"><a class="header" href="#why-are-relationships-not-loading">Why are relationships not loading?</a></h3>
<p>Check that:</p>
<ol>
<li><code>#[sea_orm(ignore)]</code> is present</li>
<li><code>#[crudcrate(non_db_attr)]</code> is present</li>
<li>Sea-ORM <code>Related</code> trait is implemented</li>
<li><code>join(...)</code> specifies <code>one</code> and/or <code>all</code></li>
</ol>
<h3 id="how-do-i-prevent-circular-references"><a class="header" href="#how-do-i-prevent-circular-references">How do I prevent circular references?</a></h3>
<p>Use <code>depth</code> limit:</p>
<pre><code class="language-rust">#[crudcrate(non_db_attr, join(one, depth = 2))]</code></pre>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<h3 id="is-crudcrate-slow"><a class="header" href="#is-crudcrate-slow">Is CRUDCrate slow?</a></h3>
<p>No. Generated code has zero runtime overhead. All generation happens at compile time.</p>
<h3 id="how-do-i-optimize-for-large-tables"><a class="header" href="#how-do-i-optimize-for-large-tables">How do I optimize for large tables?</a></h3>
<ol>
<li>Add database indexes on filtered/sorted fields</li>
<li>Use pagination (built-in limits: 1000 items max)</li>
<li>Exclude heavy fields from lists: <code>#[crudcrate(exclude(list))]</code></li>
<li>Limit join depth</li>
</ol>
<h3 id="does-loading-relationships-cause-n1-queries"><a class="header" href="#does-loading-relationships-cause-n1-queries">Does loading relationships cause N+1 queries?</a></h3>
<p>Currently, yes. Relationships are loaded with additional queries. For performance-critical paths, consider custom handlers with batch loading.</p>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="compilation-error-cannot-find-derive-macro"><a class="header" href="#compilation-error-cannot-find-derive-macro">Compilation error: “cannot find derive macro”</a></h3>
<p>Import it:</p>
<pre><code class="language-rust">use crudcrate::EntityToModels;</code></pre>
<h3 id="error-field-not-found-when-filtering"><a class="header" href="#error-field-not-found-when-filtering">Error: “field not found” when filtering</a></h3>
<p>The field must be marked <code>filterable</code>:</p>
<pre><code class="language-rust">#[crudcrate(filterable)]
pub status: String,</code></pre>
<h3 id="relationships-return-empty"><a class="header" href="#relationships-return-empty">Relationships return empty</a></h3>
<p>Ensure:</p>
<ol>
<li>Database has related records</li>
<li>Sea-ORM <code>Related</code> trait is implemented</li>
<li>Join is configured: <code>join(one)</code> or <code>join(one, all)</code></li>
</ol>
<h3 id="too-many-items-error-on-bulk-delete"><a class="header" href="#too-many-items-error-on-bulk-delete">“Too many items” error on bulk delete</a></h3>
<p>Built-in safety limit is 100 items. Split into multiple requests.</p>
<h3 id="timestamp-fields-not-auto-updating"><a class="header" href="#timestamp-fields-not-auto-updating">Timestamp fields not auto-updating</a></h3>
<p>Check:</p>
<ol>
<li><code>on_create</code> and <code>on_update</code> are set</li>
<li>Field is excluded from update model: <code>exclude(update)</code></li>
</ol>
<pre><code class="language-rust">#[crudcrate(exclude(create, update), on_create = chrono::Utc::now(), on_update = chrono::Utc::now())]
pub updated_at: DateTimeUtc,</code></pre>
<h2 id="migration"><a class="header" href="#migration">Migration</a></h2>
<h3 id="can-i-migrate-from-manual-handlers"><a class="header" href="#can-i-migrate-from-manual-handlers">Can I migrate from manual handlers?</a></h3>
<p>Yes. CRUDCrate is additive. You can:</p>
<ol>
<li>Start with one entity</li>
<li>Keep existing handlers for others</li>
<li>Gradually migrate</li>
</ol>
<h3 id="how-do-i-migrate-to-a-new-version"><a class="header" href="#how-do-i-migrate-to-a-new-version">How do I migrate to a new version?</a></h3>
<p>Check the <a href="#changelog">Changelog</a> for breaking changes. Most updates are backward compatible.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<h3 id="how-can-i-contribute"><a class="header" href="#how-can-i-contribute">How can I contribute?</a></h3>
<p>See <a href="#contributing-to-crudcrate">Contributing</a> for guidelines.</p>
<h3 id="where-do-i-report-bugs"><a class="header" href="#where-do-i-report-bugs">Where do I report bugs?</a></h3>
<p>Open an issue on <a href="https://github.com/evanjt/crudcrate/issues">GitHub</a>.</p>
<h3 id="is-there-a-roadmap"><a class="header" href="#is-there-a-roadmap">Is there a roadmap?</a></h3>
<p>Planned features:</p>
<ul>
<li>GraphQL support</li>
<li>OpenAPI generation</li>
<li>More database optimizations</li>
<li>Cursor-based pagination option</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>All notable changes to the crudcrate project will be documented in this file.</p>
<p>The format is based on <a href="https://keepachangelog.com/en/1.1.0/">Keep a Changelog</a>,
and this project adheres to <a href="https://semver.org/spec/v2.0.0.html">Semantic Versioning</a>.</p>
<h2 id="070---2025-11-26"><a class="header" href="#070---2025-11-26">[0.7.0] - 2025-11-26</a></h2>
<h3 id="security-2"><a class="header" href="#security-2">Security</a></h3>
<ul>
<li>Harden search queries with proper wildcard escaping</li>
<li>Improve input sanitization in filtering and pagination</li>
<li>Add pagination limits to prevent excessive queries</li>
</ul>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<ul>
<li><strong>Join Filtering</strong>: Filter by related entity columns using dot-notation syntax
<ul>
<li><code>filterable("col1", "col2")</code> nested inside <code>join(...)</code> attribute</li>
<li>Query: <code>?filter={"vehicles.make":"BMW"}</code></li>
<li>All standard operators supported (<code>_gt</code>, <code>_gte</code>, <code>_lt</code>, <code>_lte</code>, <code>_neq</code>)</li>
<li>Single-level joins only (nested paths like <code>vehicles.parts.name</code> not supported)</li>
</ul>
</li>
<li><strong>Join Sorting</strong>: Sort by related entity columns using dot-notation syntax
<ul>
<li><code>sortable("col1", "col2")</code> nested inside <code>join(...)</code> attribute</li>
<li>Query: <code>?sort=["vehicles.year","DESC"]</code> or <code>?sort_by=vehicles.year&amp;order=DESC</code></li>
<li>Single-level joins only (nested paths not supported)</li>
</ul>
</li>
<li><strong>Hook System</strong>: Attribute-based customization with <code>{operation}::{cardinality}::{phase}</code> syntax
<ul>
<li>Operations: <code>create</code>, <code>read</code>, <code>update</code>, <code>delete</code></li>
<li>Cardinality: <code>one</code> (single), <code>many</code> (batch)</li>
<li>Phases: <code>pre</code>, <code>body</code>, <code>post</code></li>
<li>Example: <code>#[crudcrate(create::one::pre = validate_fn)]</code></li>
</ul>
</li>
<li>Batch operations: <code>create_many</code> and <code>update_many</code> with hook support</li>
<li><strong><code>ApiError</code> error type</strong>: Consistent error handling with separate internal/client messages (fixes #3)
<ul>
<li><code>impl From&lt;DbErr&gt;</code> for seamless Sea-ORM integration with automatic internal logging</li>
<li>Internal errors logged via <code>tracing</code>, generic message sent to client</li>
<li>Custom errors: <code>ApiError::custom(StatusCode::IM_A_TEAPOT, "client msg", Some("internal log"))</code></li>
<li>Variants: <code>NotFound</code>, <code>BadRequest</code>, <code>Unauthorized</code>, <code>Forbidden</code>, <code>Conflict</code>, <code>ValidationFailed</code>, <code>Database</code>, <code>Internal</code>, <code>Custom</code></li>
</ul>
</li>
<li>Lifecycle hooks in <code>CRUDOperations</code> trait</li>
<li>Improved test coverage across modules</li>
</ul>
<h3 id="changed"><a class="header" href="#changed">Changed</a></h3>
<ul>
<li>Major codebase refactoring (38% size reduction)
<ul>
<li>Removed <code>index_analysis</code> module</li>
<li>Simplified <code>relation_validator.rs</code></li>
<li>Consolidated join/recursion handling</li>
<li>Modular <code>codegen/</code> structure</li>
</ul>
</li>
<li>Handler code generation refactored for hook flow</li>
<li>Replace <code>eprintln!</code> with <code>tracing</code> for logging</li>
<li>Legacy <code>fn_*</code> attributes auto-map to new hook syntax</li>
</ul>
<h3 id="fixed"><a class="header" href="#fixed">Fixed</a></h3>
<ul>
<li>Improved error handling in join path parsing</li>
<li>Fixed flaky tests with serial execution</li>
<li>All clippy::pedantic warnings resolved</li>
</ul>
<h3 id="removed"><a class="header" href="#removed">Removed</a></h3>
<ul>
<li><strong><code>index_analysis</code> module</strong>: Database index recommendations moved to external tooling (pgAdmin, MySQL Workbench, etc.)</li>
<li><strong><code>register_crud_analyser!</code> macro</strong>: No longer needed without index analysis</li>
<li><strong><code>attributes.rs</code></strong>: Dead code (IDE autocomplete hints only, never used at runtime)</li>
<li><strong><code>join_strategies/</code> module</strong>: Consolidated into <code>codegen/joins/</code></li>
<li><strong><code>field_analyzer.rs</code></strong>: Reorganized into <code>fields/</code> module</li>
<li><strong>Redundant examples</strong>: <code>minimal_debug.rs</code>, <code>minimal_spring.rs</code>, <code>test_router_only.rs</code></li>
<li><strong>Verbose documentation</strong>: ~400 lines of excessive doc comments trimmed</li>
</ul>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<ul>
<li>Added <code>serial_test = "3.2"</code> for test isolation</li>
<li>Added <code>tracing</code> for structured logging</li>
</ul>
<h2 id="061---2025-11-03"><a class="header" href="#061---2025-11-03">[0.6.1] - 2025-11-03</a></h2>
<h3 id="fixed-1"><a class="header" href="#fixed-1">Fixed</a></h3>
<ul>
<li>Global path resolution of joined structs</li>
<li>Restructuring of crudcrate-derive into smaller modules, bit by bit.</li>
</ul>
<h2 id="060---2025-10-31"><a class="header" href="#060---2025-10-31"><a href="https://github.com/evanjt/crudcrate/compare/0.6.0...0.6.1">0.6.0</a> - 2025-10-31</a></h2>
<h3 id="added-1"><a class="header" href="#added-1">Added</a></h3>
<ul>
<li><strong>Recursive Join Loading</strong>: Multi-level relationship loading with <code>#[crudcrate(join(one, all))]</code> attribute</li>
<li>Cyclic dependency detection at compile-time with actionable error messages</li>
<li>Unlimited join depth support with default depth warnings for relationships &gt; 3 levels</li>
<li><code>exclude()</code> function-style syntax for model exclusion: <code>#[crudcrate(exclude(create, update))]</code></li>
<li>The get one response is now its own model, allowing for exclusion of fields from get one/create/update responses</li>
<li>New <code>recursive_join</code> example demonstrating nested relationship loading</li>
<li>Debug output functionality for procedural macros with <code>debug_output</code> attribute</li>
</ul>
<h3 id="changed-1"><a class="header" href="#changed-1">Changed</a></h3>
<ul>
<li><strong>derive</strong>: Removed requirement for <code>Eq</code> and <code>PartialEq</code> derives on generated API structs</li>
<li><strong>derive</strong>: Improved multi-pass code generation to handle cyclic dependencies</li>
</ul>
<h3 id="fixed-2"><a class="header" href="#fixed-2">Fixed</a></h3>
<ul>
<li>Database test cleanup logic for PostgreSQL and MySQL backends</li>
<li>Relationship loading in <code>get_one()</code> and <code>get_all()</code> endpoints</li>
</ul>
<h3 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h3>
<ul>
<li><strong>derive</strong>: Updated with recursive join support, cyclic dependency detection, and enhanced attribute parsing</li>
</ul>
<h2 id="050---2025-08-28"><a class="header" href="#050---2025-08-28"><a href="https://github.com/evanjt/crudcrate/compare/0.4.5...0.5.0">0.5.0</a> - 2025-08-28</a></h2>
<h3 id="added-2"><a class="header" href="#added-2">Added</a></h3>
<ul>
<li>Spring-RS framework support with minimal example in <code>/examples</code></li>
<li>Restored CRUD benchmarks from 0.4.5</li>
</ul>
<h3 id="changed-2"><a class="header" href="#changed-2">Changed</a></h3>
<ul>
<li>Moved <code>crudcrate-derive</code> and examples into repository</li>
<li>Simplified framework architecture - removed redundant code generation paths</li>
<li>Refactored macro code generation by splitting helpers.rs into focused modules</li>
</ul>
<h3 id="removed-1"><a class="header" href="#removed-1">Removed</a></h3>
<ul>
<li>BREAKING: Case-sensitive enum filtering functionality</li>
</ul>
<h2 id="045---2025-08-25"><a class="header" href="#045---2025-08-25"><a href="https://github.com/evanjt/crudcrate/compare/0.4.4...0.4.5">0.4.5</a> - 2025-08-25</a></h2>
<h3 id="fixed-3"><a class="header" href="#fixed-3">Fixed</a></h3>
<ul>
<li>Batch delete endpoints now returns the array of successfully deleted resource UUIDs, suitable for a react-admin batch delete response.</li>
</ul>
<h2 id="044---2025-08-20"><a class="header" href="#044---2025-08-20"><a href="https://github.com/evanjt/crudcrate/compare/0.4.3...0.4.4">0.4.4</a> - 2025-08-20</a></h2>
<h3 id="added-3"><a class="header" href="#added-3">Added</a></h3>
<ul>
<li>Index analysis system for database optimization recommendations</li>
<li><code>analyse_indexes_for_resource</code> and <code>analyse_all_registered_models</code> functions</li>
<li>Database-specific index recommendations with priority-based output</li>
</ul>
<h3 id="changed-3"><a class="header" href="#changed-3">Changed</a></h3>
<ul>
<li><strong>BREAKING</strong> (if still using CRUDResource manually): Added required <code>TABLE_NAME</code>
constant to <code>CRUDResource</code> trait. This does not affect <code>EntityToModel</code> functionality.</li>
<li>Made <code>validate_field_value</code> function const</li>
<li>Improved code organization with extracted helper functions</li>
</ul>
<h3 id="fixed-4"><a class="header" href="#fixed-4">Fixed</a></h3>
<ul>
<li>All clippy warnings (pessimistic and pedantic)</li>
<li>Test compilation errors and naming inconsistencies</li>
<li>Documentation examples and missing trait implementations</li>
</ul>
<h2 id="043---2025-08-19"><a class="header" href="#043---2025-08-19"><a href="https://github.com/evanjt/crudcrate/compare/0.4.2...0.4.3">0.4.3</a> - 2025-08-19</a></h2>
<h3 id="added-4"><a class="header" href="#added-4">Added</a></h3>
<ul>
<li><strong>Testing</strong>: Integration tests for <code>create_model=false</code> compatibility with <code>non_db_attr</code></li>
<li><strong>Testing</strong>: Comprehensive test suite for <code>use_target_models</code> functionality with cross-model referencing</li>
</ul>
<h3 id="fixed-5"><a class="header" href="#fixed-5">Fixed</a></h3>
<ul>
<li><strong>derive</strong>: Resolved lingering compilation errors from List model update</li>
<li><strong>derive</strong>: Fixed test compatibility issues following List model integration</li>
<li><strong>Filter system</strong>: Minor improvements to filtering logic consistency</li>
</ul>
<h3 id="dependencies-2"><a class="header" href="#dependencies-2">Dependencies</a></h3>
<ul>
<li><strong>derive</strong>: Updated to latest version with enhanced List model support and improved compatibility</li>
</ul>
<h2 id="042---2025-08-18"><a class="header" href="#042---2025-08-18"><a href="https://github.com/evanjt/crudcrate/compare/0.4.1...0.4.2">0.4.2</a> - 2025-08-18</a></h2>
<h3 id="added-5"><a class="header" href="#added-5">Added</a></h3>
<ul>
<li><strong>List Model Support</strong>: New <code>List</code> model generation capability for customizing fields returned in list/getAll endpoints, similar to Create and Update models</li>
<li>Generated List model behavior with field deselection support</li>
<li>Built-in <code>getAll</code> query optimization to only return fields specified in List model</li>
<li><strong>derive</strong>: Support for reserved field names using <code>r#</code> syntax (e.g., <code>r#type</code>)</li>
<li><strong>derive</strong>: Enhanced target model usage with CRUDResource structs for cross-model referencing</li>
<li><strong>derive</strong>: Automatic <code>From&lt;&gt;</code> trait generation for List structs from Sea-ORM DB models</li>
</ul>
<h3 id="changed-4"><a class="header" href="#changed-4">Changed</a></h3>
<ul>
<li><strong>derive</strong>: Improved trait compatibility by re-adding <code>PartialEq</code>, <code>Eq</code>, <code>Debug</code>, and <code>Clone</code> derives to models for Sea-ORM compatibility</li>
<li><strong>derive</strong>: Route generation now uses root-level paths instead of prefixed routes for better user control</li>
<li><strong>derive</strong>: Enhanced <code>use_target_models</code> functionality for better cross-model integration</li>
</ul>
<h3 id="fixed-6"><a class="header" href="#fixed-6">Fixed</a></h3>
<ul>
<li><strong>derive</strong>: Fixed ActiveModel generation when create model excludes keys</li>
<li><strong>derive</strong>: Fixed <code>create_model=false</code> compatibility with <code>non_db_attr</code></li>
<li><strong>derive</strong>: Improved function linking in crudcrate function overrides</li>
<li><strong>derive</strong>: Fixed trait signature for Condition in get_all operations</li>
<li><strong>derive</strong>: Various clippy warnings resolved</li>
</ul>
<h3 id="dependencies-3"><a class="header" href="#dependencies-3">Dependencies</a></h3>
<ul>
<li><strong>derive</strong>: Updated to 0.2.6 with List model support, reserved field handling, and enhanced model generation capabilities</li>
</ul>
<h2 id="041---2025-08-05"><a class="header" href="#041---2025-08-05"><a href="https://github.com/evanjt/crudcrate/compare/0.4.0...0.4.1">0.4.1</a> - 2025-08-05</a></h2>
<h3 id="added-6"><a class="header" href="#added-6">Added</a></h3>
<ul>
<li>Index analysis functionality with <code>analyze_indexes_for_resource()</code> and <code>analyze_and_display_indexes()</code> methods</li>
<li>Full-text search support in filtering system with <code>fulltext_searchable_columns()</code> method</li>
<li>REST-standard pagination and query filters alongside React Admin compatibility</li>
<li>Multi-database testing support (SQLite, PostgreSQL, MySQL) via <code>DATABASE_URL</code> environment variable</li>
<li>Comprehensive benchmark suite with performance testing across database backends</li>
<li>Security integration tests for SQL injection protection</li>
<li>Coverage reporting with Codecov integration</li>
<li>Database feature flags for selective driver compilation (<code>mysql</code>, <code>postgresql</code>, <code>sqlite</code>)</li>
<li>Binary size optimization through conditional database driver inclusion</li>
</ul>
<h3 id="changed-5"><a class="header" href="#changed-5">Changed</a></h3>
<ul>
<li>Enhanced filtering system with enum case insensitivity and improved edge case handling</li>
<li>Updated README with minimal examples and comprehensive testing documentation</li>
<li>Restructured test infrastructure to support multiple database backends</li>
<li>Improved error handling in filter parsing with better validation</li>
<li>Removed Clone requirement from generated API structs (Create/Update models)</li>
<li>Optimized trait methods to use references instead of owned values where possible</li>
<li>Sea-ORM dependency now uses <code>default-features = false</code> with selective feature enabling</li>
<li>Enhanced README with database feature selection examples</li>
</ul>
<h3 id="fixed-7"><a class="header" href="#fixed-7">Fixed</a></h3>
<ul>
<li>Enum filtering now supports case-insensitive matching</li>
<li>Filter edge cases handle malformed JSON gracefully</li>
<li>PostgreSQL test isolation issues with race conditions during parallel execution</li>
<li>Clippy warnings resolved across codebase</li>
<li><strong>derive</strong>: Improved integration tests and restructured codebase</li>
</ul>
<h3 id="dependencies-4"><a class="header" href="#dependencies-4">Dependencies</a></h3>
<ul>
<li><strong>derive</strong>: Updated to 0.2.1 with full-text search support and enhanced router generation capabilities</li>
<li><strong>derive</strong>: Removed Clone derives from generated structs to reduce memory overhead</li>
</ul>
<h2 id="040---2025-07-17"><a class="header" href="#040---2025-07-17"><a href="https://github.com/evanjt/crudcrate/compare/0.3.3...0.4.0">0.4.0</a> - 2025-07-17</a></h2>
<h3 id="added-7"><a class="header" href="#added-7">Added</a></h3>
<ul>
<li><strong>Enhanced Router Generation</strong>: Automatic router generation via <code>generate_router</code> attribute in <code>EntityToModels</code> macro</li>
<li><strong>Non-Database Field Support</strong>: Complete support for non-DB fields using <code>#[sea_orm(ignore)]</code> + <code>#[crudcrate(non_db_attr = true)]</code> pattern</li>
<li><strong>Single-File API Capability</strong>: Full CRUD API can now be implemented in under 60 lines of code</li>
<li>Documentation improvements for non-DB field usage with examples</li>
<li><strong>derive</strong>: EntityToModels macro with complete entity-to-API generation and CRUDResource implementation</li>
<li><strong>derive</strong>: Router generation capability integrated into EntityToModels</li>
<li><strong>derive</strong>: Enhanced support for non-database fields with proper Sea-ORM integration</li>
<li><strong>derive</strong>: Comprehensive integration tests and restructured codebase</li>
</ul>
<h3 id="changed-6"><a class="header" href="#changed-6">Changed</a></h3>
<ul>
<li>Enhanced <code>EntityToModels</code> macro to automatically generate router functions</li>
<li>Improved documentation with comprehensive non-DB field examples</li>
<li>Router generation now fully automated with zero boilerplate</li>
<li><strong>derive</strong>: Enhanced <code>ToCreateModel</code> and <code>ToUpdateModel</code> with new trait system</li>
<li><strong>derive</strong>: Added <code>MergeIntoActiveModel</code> trait implementation</li>
</ul>
<h3 id="fixed-8"><a class="header" href="#fixed-8">Fixed</a></h3>
<ul>
<li><strong>derive</strong>: Test infrastructure improvements and better error handling in macro generation</li>
</ul>
<h2 id="033---2025-06-23"><a class="header" href="#033---2025-06-23"><a href="https://github.com/evanjt/crudcrate/compare/0.3.2...0.3.3">0.3.3</a> - 2025-06-23</a></h2>
<h3 id="fixed-9"><a class="header" href="#fixed-9">Fixed</a></h3>
<ul>
<li>Fix newline formatting in auto-generated OpenAPI documentation</li>
<li>Remove debug messages from production builds</li>
</ul>
<h3 id="changed-7"><a class="header" href="#changed-7">Changed</a></h3>
<ul>
<li>Accept enum exact comparison in filter queries</li>
<li>Filter on integer columns support</li>
</ul>
<h2 id="032---2025-06-06"><a class="header" href="#032---2025-06-06"><a href="https://github.com/evanjt/crudcrate/compare/0.3.1...0.3.2">0.3.2</a> - 2025-06-06</a></h2>
<h3 id="changed-8"><a class="header" href="#changed-8">Changed</a></h3>
<ul>
<li>Bump dependencies including crudcrate-derive for improved <code>into()</code> casting support</li>
</ul>
<h3 id="dependencies-5"><a class="header" href="#dependencies-5">Dependencies</a></h3>
<ul>
<li><strong>derive</strong>: Updated to 0.1.6 with improved <code>.into()</code> casting support and enhanced field attribute handling</li>
</ul>
<h2 id="031---2025-05-12"><a class="header" href="#031---2025-05-12"><a href="https://github.com/evanjt/crudcrate/compare/0.3.0...0.3.1">0.3.1</a> - 2025-05-12</a></h2>
<h3 id="changed-9"><a class="header" href="#changed-9">Changed</a></h3>
<ul>
<li>Update lockfile and enhance filtering capabilities for enum and integer columns</li>
</ul>
<h2 id="030---2025-04-05"><a class="header" href="#030---2025-04-05"><a href="https://github.com/evanjt/crudcrate/compare/0.2.5...0.3.0">0.3.0</a> - 2025-04-05</a></h2>
<h3 id="added-8"><a class="header" href="#added-8">Added</a></h3>
<ul>
<li><strong>Major</strong>: Default implementations for <code>get_one</code>, <code>get_all</code>, and <code>update_one</code> in <code>CRUDResource</code> trait</li>
<li>New <code>MergeIntoActiveModel</code> trait for improved update model handling</li>
<li>Enhanced derive macro integration with new trait system</li>
</ul>
<h3 id="changed-10"><a class="header" href="#changed-10">Changed</a></h3>
<ul>
<li>Restructured core trait system for better usability</li>
<li>Updated derive macro to reference new <code>MergeIntoActiveModel</code> trait</li>
</ul>
<h3 id="dependencies-6"><a class="header" href="#dependencies-6">Dependencies</a></h3>
<ul>
<li><strong>derive</strong>: Updated to 0.1.5 with <code>IntoActiveModel</code> trait for <code>UpdateModel</code> and improved trait derivations</li>
</ul>
<h2 id="025---2025-04-04"><a class="header" href="#025---2025-04-04"><a href="https://github.com/evanjt/crudcrate/compare/0.2.4...0.2.5">0.2.5</a> - 2025-04-04</a></h2>
<h3 id="added-9"><a class="header" href="#added-9">Added</a></h3>
<ul>
<li>Export <code>serde_with</code> for better serialization support</li>
<li>Enhanced error responses in API endpoints</li>
<li>Documentation for query parameters</li>
</ul>
<h3 id="changed-11"><a class="header" href="#changed-11">Changed</a></h3>
<ul>
<li>Renamed <code>openapi.rs</code> to <code>routes.rs</code> for better organization</li>
<li>Updated dependencies</li>
</ul>
<h2 id="024---2025-03-11"><a class="header" href="#024---2025-03-11"><a href="https://github.com/evanjt/crudcrate/compare/0.2.3...0.2.4">0.2.4</a> - 2025-03-11</a></h2>
<h3 id="added-10"><a class="header" href="#added-10">Added</a></h3>
<ul>
<li>Description string support in CRUDResource</li>
<li>Auto-populated summary and description for macro-generated endpoints</li>
<li>Enhanced OpenAPI documentation generation</li>
</ul>
<h3 id="dependencies-7"><a class="header" href="#dependencies-7">Dependencies</a></h3>
<ul>
<li><strong>derive</strong>: Updated to 0.1.4 with improved serialization support using exported <code>serde_with</code></li>
</ul>
<h2 id="023---2025-03-07"><a class="header" href="#023---2025-03-07"><a href="https://github.com/evanjt/crudcrate/compare/0.2.2...0.2.3">0.2.3</a> - 2025-03-07</a></h2>
<h3 id="added-11"><a class="header" href="#added-11">Added</a></h3>
<ul>
<li>Comprehensive OpenAPI macro support</li>
<li>Better API documentation generation</li>
</ul>
<h3 id="fixed-10"><a class="header" href="#fixed-10">Fixed</a></h3>
<ul>
<li>Improved error responses in endpoints</li>
</ul>
<h2 id="022---2025-03-06"><a class="header" href="#022---2025-03-06"><a href="https://github.com/evanjt/crudcrate/compare/0.2.1...0.2.2">0.2.2</a> - 2025-03-06</a></h2>
<h3 id="added-12"><a class="header" href="#added-12">Added</a></h3>
<ul>
<li>Documentation for query parameters</li>
</ul>
<h2 id="021---2025-03-05"><a class="header" href="#021---2025-03-05"><a href="https://github.com/evanjt/crudcrate/compare/0.2.0...0.2.1">0.2.1</a> - 2025-03-05</a></h2>
<h3 id="added-13"><a class="header" href="#added-13">Added</a></h3>
<ul>
<li>Description string support in CRUDResource</li>
<li>Auto-populated summary and description for macro-generated endpoints</li>
</ul>
<h2 id="020---2025-03-05"><a class="header" href="#020---2025-03-05"><a href="https://github.com/evanjt/crudcrate/compare/0.1.4...0.2.0">0.2.0</a> - 2025-03-05</a></h2>
<h3 id="changed-12"><a class="header" href="#changed-12">Changed</a></h3>
<ul>
<li><strong>Breaking</strong>: Major refactor from route-based to macro-based approach</li>
<li>Introduced <code>crud_handlers!</code> macro for generating CRUD endpoints</li>
<li>Simplified API creation process significantly</li>
</ul>
<h3 id="removed-2"><a class="header" href="#removed-2">Removed</a></h3>
<ul>
<li>Legacy route-based implementation</li>
</ul>
<h2 id="014---2025-03-03"><a class="header" href="#014---2025-03-03"><a href="https://github.com/evanjt/crudcrate/compare/0.1.3...0.1.4">0.1.4</a> - 2025-03-03</a></h2>
<h3 id="fixed-11"><a class="header" href="#fixed-11">Fixed</a></h3>
<ul>
<li>Fixed return type of <code>delete_one</code> handler</li>
<li>Applied clippy suggestions for performance improvements</li>
</ul>
<h2 id="013---2025-02-19"><a class="header" href="#013---2025-02-19"><a href="https://github.com/evanjt/crudcrate/compare/0.1.2...0.1.3">0.1.3</a> - 2025-02-19</a></h2>
<h3 id="changed-13"><a class="header" href="#changed-13">Changed</a></h3>
<ul>
<li>Update crudcrate-derive to allow non-db parameters in update/create models</li>
</ul>
<h3 id="dependencies-8"><a class="header" href="#dependencies-8">Dependencies</a></h3>
<ul>
<li><strong>derive</strong>: Updated to 0.1.3 with support for auxiliary attributes in structs that don’t relate to DB model</li>
</ul>
<h2 id="012---2025-02-18"><a class="header" href="#012---2025-02-18"><a href="https://github.com/evanjt/crudcrate/compare/0.1.0...0.1.2">0.1.2</a> - 2025-02-18</a></h2>
<h3 id="changed-14"><a class="header" href="#changed-14">Changed</a></h3>
<ul>
<li>Update proc macro to 0.1.2</li>
</ul>
<h3 id="dependencies-9"><a class="header" href="#dependencies-9">Dependencies</a></h3>
<ul>
<li><strong>derive</strong>: Updated to 0.1.2 with improved trait derivations (Clone instead of Copy where appropriate)</li>
</ul>
<h2 id="010---2025-02-18"><a class="header" href="#010---2025-02-18"><a href="https://github.com/evanjt/crudcrate/releases/tag/0.1.0">0.1.0</a> - 2025-02-18</a></h2>
<h3 id="added-14"><a class="header" href="#added-14">Added</a></h3>
<ul>
<li>Initial release of crudcrate</li>
<li>Basic CRUD operation framework</li>
<li>Sea-ORM and Axum integration</li>
<li>OpenAPI documentation support</li>
<li>Move common functions and traits from existing API</li>
<li>Import proc-macros from crudcrate-derive</li>
</ul>
<h3 id="dependencies-10"><a class="header" href="#dependencies-10">Dependencies</a></h3>
<ul>
<li><strong>derive</strong>: Initial release (0.1.0) with <code>ToCreateModel</code> and <code>ToUpdateModel</code> derive macros, field-level attribute support for CRUD customization, and integration with Sea-ORM ActiveModel system</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="contributing-to-crudcrate"><a class="header" href="#contributing-to-crudcrate">Contributing to CRUDCrate</a></h1>
<p>Thank you for your interest in contributing to CRUDCrate!</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<h3 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h3>
<ul>
<li>Rust 1.70+</li>
<li>Git</li>
<li>A database for testing (SQLite works for most tests)</li>
</ul>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/evanjt/crudcrate.git
cd crudcrate

# Build the project
cargo build

# Run tests
cargo test

# Run clippy
cargo clippy
</code></pre>
<h2 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h2>
<h3 id="1-create-an-issue"><a class="header" href="#1-create-an-issue">1. Create an Issue</a></h3>
<p>Before starting work, create or find an issue describing:</p>
<ul>
<li>Bug reports: Steps to reproduce, expected vs actual behavior</li>
<li>Features: Use case, proposed API</li>
</ul>
<h3 id="2-fork-and-branch"><a class="header" href="#2-fork-and-branch">2. Fork and Branch</a></h3>
<pre><code class="language-bash"># Fork on GitHub, then:
git clone https://github.com/YOUR-USERNAME/crudcrate.git
cd crudcrate
git checkout -b feature/your-feature-name
</code></pre>
<h3 id="3-make-changes"><a class="header" href="#3-make-changes">3. Make Changes</a></h3>
<ul>
<li>Follow the existing code style</li>
<li>Add tests for new functionality</li>
<li>Update documentation as needed</li>
<li>Keep commits focused and atomic</li>
</ul>
<h3 id="4-test"><a class="header" href="#4-test">4. Test</a></h3>
<pre><code class="language-bash"># Run all tests
cargo test

# Run specific test
cargo test test_name

# Run with logging
RUST_LOG=debug cargo test

# Check for warnings
cargo clippy

# Format code
cargo fmt
</code></pre>
<h3 id="5-submit-pull-request"><a class="header" href="#5-submit-pull-request">5. Submit Pull Request</a></h3>
<ul>
<li>Push to your fork</li>
<li>Open PR against <code>main</code></li>
<li>Fill out the PR template</li>
<li>Wait for review</li>
</ul>
<h2 id="code-style"><a class="header" href="#code-style">Code Style</a></h2>
<h3 id="rust-guidelines"><a class="header" href="#rust-guidelines">Rust Guidelines</a></h3>
<ul>
<li>Follow <a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a></li>
<li>Use <code>cargo fmt</code> for formatting</li>
<li>Fix all <code>cargo clippy</code> warnings</li>
<li>Document public APIs with doc comments</li>
</ul>
<h3 id="commit-messages"><a class="header" href="#commit-messages">Commit Messages</a></h3>
<pre><code>type(scope): short description

Longer explanation if needed.

Fixes #123
</code></pre>
<p>Types: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>style</code>, <code>refactor</code>, <code>test</code>, <code>chore</code></p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code>feat(filtering): add _in operator for multiple values

Adds support for filtering with multiple values using
the _in suffix: ?status_in=active,pending

Fixes #42
</code></pre>
<h2 id="project-structure-1"><a class="header" href="#project-structure-1">Project Structure</a></h2>
<pre><code>crudcrate/
├── crudcrate/              # Runtime library
│   ├── src/
│   │   ├── lib.rs          # Public API
│   │   ├── core/           # Core traits
│   │   ├── filtering/      # Query parsing
│   │   └── ...
│   └── Cargo.toml
│
├── crudcrate-derive/       # Proc macro crate
│   ├── src/
│   │   ├── lib.rs          # Macro entry points
│   │   ├── codegen/        # Code generation
│   │   └── ...
│   └── Cargo.toml
│
├── examples/               # Example projects
│
└── docs/                   # Documentation (this site)
</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h3>
<pre><code class="language-rust">#[test]
fn test_filter_parsing() {
    let result = parse_filter(r#"{"status":"active"}"#);
    assert!(result.is_ok());
}</code></pre>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<pre><code class="language-rust">#[tokio::test]
async fn test_crud_operations() {
    let db = setup_test_db().await;
    // Test full CRUD flow
}</code></pre>
<h3 id="documentation-tests"><a class="header" href="#documentation-tests">Documentation Tests</a></h3>
<pre><code class="language-rust">/// Filters items by status.
///
/// # Example
///
/// ```
/// let condition = apply_filters::&lt;Entity&gt;(&amp;params)?;
/// ```
pub fn apply_filters&lt;E&gt;(...) { }</code></pre>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<h3 id="code-documentation"><a class="header" href="#code-documentation">Code Documentation</a></h3>
<ul>
<li>All public items need doc comments</li>
<li>Include examples in doc comments</li>
<li>Use <code>///</code> for items, <code>//!</code> for modules</li>
</ul>
<h3 id="user-documentation"><a class="header" href="#user-documentation">User Documentation</a></h3>
<p>Documentation is in <code>docs/src/</code>. To build locally:</p>
<pre><code class="language-bash"># Install mdbook
cargo install mdbook

# Build and serve
cd docs
mdbook serve
</code></pre>
<h2 id="review-process"><a class="header" href="#review-process">Review Process</a></h2>
<ol>
<li><strong>Automated checks</strong>: CI runs tests, clippy, format</li>
<li><strong>Code review</strong>: At least one maintainer review</li>
<li><strong>Documentation</strong>: Ensure docs are updated</li>
<li><strong>Changelog</strong>: Add entry for user-facing changes</li>
</ol>
<h2 id="release-process"><a class="header" href="#release-process">Release Process</a></h2>
<p>(For maintainers)</p>
<ol>
<li>Update version in <code>Cargo.toml</code></li>
<li>Update <code>CHANGELOG.md</code></li>
<li>Create git tag: <code>git tag v0.X.Y</code></li>
<li>Push tag: <code>git push origin v0.X.Y</code></li>
<li>CI publishes to crates.io</li>
</ol>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li><strong>Questions</strong>: Open a Discussion on GitHub</li>
<li><strong>Bugs</strong>: Open an Issue</li>
<li><strong>Chat</strong>: Join our Discord (link TBD)</li>
</ul>
<h2 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h2>
<p>We follow the <a href="https://www.rust-lang.org/policies/code-of-conduct">Rust Code of Conduct</a>.</p>
<p>Be respectful, constructive, and welcoming to all contributors.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>By contributing, you agree that your contributions will be licensed under the same license as the project (MIT/Apache-2.0).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/version-selector-f75b1977.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
