//! # CRUDOperations Trait Example
//!
//! This example demonstrates the **Operations Pattern** - a clean way to customize CRUD behavior
//! by separating your data model from your business logic.
//!
//! ## The Pattern: Data vs Operations
//!
//! - **`Asset`** (generated) = What your data looks like
//! - **`AssetOperations`** (you write) = How you work with it
//!
//! This separation keeps code clean and makes customizations obvious. Instead of scattered
//! `fn_*` attributes, all your custom CRUD logic lives in one place.
//!
//! ## Real-World Example
//!
//! Our Asset entity needs to delete files from S3 before deleting from database. We only
//! override `delete()` - everything else (get, create, update) uses sensible defaults.
//!
//! Run with: `cargo run --example crud_operations`

use async_trait::async_trait;
use axum::Router;
use sea_orm::{Database, DatabaseConnection, entity::prelude::*};
use uuid::Uuid;
use crudcrate::{CRUDOperations, CRUDResource, EntityToModels};

//
// STEP 1: Define your entity with the operations attribute
//

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, EntityToModels)]
#[sea_orm(table_name = "assets")]
#[crudcrate(
    api_struct = "Asset",
    generate_router,
    operations = AssetOperations  // â† Your custom operations
)]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[crudcrate(primary_key, exclude(create, update), on_create = Uuid::new_v4())]
    pub id: Uuid,

    #[crudcrate(filterable, sortable)]
    pub name: String,

    #[crudcrate(filterable)]
    pub s3_key: String,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

//
// STEP 2: Define your operations struct
//
// This is just a unit struct - it holds no data, just behavior.
// Think of it as a "handler" or "service" for your Asset model.
//

pub struct AssetOperations;

#[async_trait]
impl CRUDOperations for AssetOperations {
    type Resource = Asset;

    // Override delete to add S3 cleanup
    async fn delete(&self, db: &DatabaseConnection, id: Uuid) -> Result<Uuid, DbErr> {
        use sea_orm::EntityTrait;

        // First, fetch the asset to get the S3 key (uses default get_one)
        let asset = self.get_one(db, id).await?;

        // Delete from S3 (simulated here)
        delete_from_s3(&asset.s3_key).await
            .map_err(|e| DbErr::Custom(format!("S3 cleanup failed: {}", e)))?;

        // Then delete from database using entity methods directly
        let res = <Asset as CRUDResource>::EntityType::delete_by_id(id).exec(db).await?;
        match res.rows_affected {
            0 => Err(DbErr::RecordNotFound("Asset not found".to_string())),
            _ => Ok(id),
        }
    }

    // All other methods (get_one, get_all, create, update, delete_many) use defaults!
    // No need to write them - sensible implementations are provided.
}

/// Simulated S3 deletion function
async fn delete_from_s3(s3_key: &str) -> Result<(), String> {
    println!("ðŸ—‘ï¸  Deleting S3 object: {}", s3_key);
    // In real code: s3_client.delete_object().send().await?
    Ok(())
}

//
// STEP 3: Use it in your application
//

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Setup database (in-memory SQLite for demo)
    let db = Database::connect("sqlite::memory:").await?;

    // Create schema
    create_schema(&db).await?;

    // Build router - the Asset::router() uses AssetOperations automatically!
    let app = Router::new()
        .nest("/api/assets", Asset::router(&db).into())
        .route("/", axum::routing::get(|| async { "CRUDOperations Example - try /api/assets" }));

    // Demo: Create and delete an asset
    demo_operations(&db).await?;

    println!("\nâœ… CRUDOperations example completed successfully!");
    println!("\nðŸ“š The Operations Pattern:");
    println!("  1. Define your model: Asset (generated by macro)");
    println!("  2. Define your operations: AssetOperations (your custom logic)");
    println!("  3. Use #[crudcrate(operations = AssetOperations)]");
    println!("  4. Override only what you need - defaults handle the rest");
    println!("\nðŸ’¡ Benefits:");
    println!("  âœ“ Clean separation: data vs behavior");
    println!("  âœ“ All CRUD logic in one place (not scattered fn_* attributes)");
    println!("  âœ“ Easy to test operations independently");
    println!("  âœ“ Compose operations (delete called self.get_one)");
    println!("\nThis is the recommended pattern for complex CRUD customizations!");

    Ok(())
}

async fn demo_operations(db: &DatabaseConnection) -> Result<(), DbErr> {
    println!("\nðŸ“ Creating test asset...");
    let create_data = AssetCreate {
        name: "test-file.pdf".to_string(),
        s3_key: "uploads/2024/test-file.pdf".to_string(),
    };
    let asset = Asset::create(db, create_data).await?;
    println!("   Created: {} (ID: {})", asset.name, asset.id);

    println!("\nðŸ—‘ï¸  Deleting asset (will trigger S3 cleanup)...");
    let deleted_id = Asset::delete(db, asset.id).await?;
    println!("   Deleted: {}", deleted_id);

    Ok(())
}

async fn create_schema(db: &DatabaseConnection) -> Result<(), DbErr> {
    use sea_orm::{ConnectionTrait, Statement};

    db.execute(Statement::from_string(
        sea_orm::DatabaseBackend::Sqlite,
        r#"
        CREATE TABLE IF NOT EXISTS assets (
            id TEXT PRIMARY KEY NOT NULL,
            name TEXT NOT NULL,
            s3_key TEXT NOT NULL
        )
        "#
    )).await?;

    Ok(())
}
